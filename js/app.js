(() => {
    var __webpack_modules__ = {
        5158: module => {
            module.exports = function prettierBytes(num) {
                if ("number" !== typeof num || isNaN(num)) throw new TypeError("Expected a number, got " + typeof num);
                var neg = num < 0;
                var units = [ "B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB" ];
                if (neg) num = -num;
                if (num < 1) return (neg ? "-" : "") + num + " B";
                var exponent = Math.min(Math.floor(Math.log(num) / Math.log(1024)), units.length - 1);
                num = Number(num / Math.pow(1024, exponent));
                var unit = units[exponent];
                if (num >= 10 || num % 1 === 0) return (neg ? "-" : "") + num.toFixed(0) + " " + unit; else return (neg ? "-" : "") + num.toFixed(1) + " " + unit;
            };
        },
        1220: module => {
            "use strict";
            class AuthError extends Error {
                constructor() {
                    super("Authorization required");
                    this.name = "AuthError";
                    this.isAuthError = true;
                }
            }
            module.exports = AuthError;
        },
        6808: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const RequestClient = __webpack_require__(2368);
            const tokenStorage = __webpack_require__(8871);
            const getName = id => id.split("-").map((s => s.charAt(0).toUpperCase() + s.slice(1))).join(" ");
            module.exports = class Provider extends RequestClient {
                constructor(uppy, opts) {
                    super(uppy, opts);
                    this.provider = opts.provider;
                    this.id = this.provider;
                    this.name = this.opts.name || getName(this.id);
                    this.pluginId = this.opts.pluginId;
                    this.tokenKey = `companion-${this.pluginId}-auth-token`;
                    this.companionKeysParams = this.opts.companionKeysParams;
                    this.preAuthToken = null;
                }
                headers() {
                    return Promise.all([ super.headers(), this.getAuthToken() ]).then((_ref => {
                        let [headers, token] = _ref;
                        const authHeaders = {};
                        if (token) authHeaders["uppy-auth-token"] = token;
                        if (this.companionKeysParams) authHeaders["uppy-credentials-params"] = btoa(JSON.stringify({
                            params: this.companionKeysParams
                        }));
                        return {
                            ...headers,
                            ...authHeaders
                        };
                    }));
                }
                onReceiveResponse(response) {
                    response = super.onReceiveResponse(response);
                    const plugin = this.uppy.getPlugin(this.pluginId);
                    const oldAuthenticated = plugin.getPluginState().authenticated;
                    const authenticated = oldAuthenticated ? 401 !== response.status : response.status < 400;
                    plugin.setPluginState({
                        authenticated
                    });
                    return response;
                }
                setAuthToken(token) {
                    return this.uppy.getPlugin(this.pluginId).storage.setItem(this.tokenKey, token);
                }
                getAuthToken() {
                    return this.uppy.getPlugin(this.pluginId).storage.getItem(this.tokenKey);
                }
                async ensurePreAuth() {
                    if (this.companionKeysParams && !this.preAuthToken) {
                        await this.fetchPreAuthToken();
                        if (!this.preAuthToken) throw new Error("Could not load authentication data required for third-party login. Please try again later.");
                    }
                }
                authUrl(queries) {
                    if (void 0 === queries) queries = {};
                    const params = new URLSearchParams(queries);
                    if (this.preAuthToken) params.set("uppyPreAuthToken", this.preAuthToken);
                    return `${this.hostname}/${this.id}/connect?${params}`;
                }
                fileUrl(id) {
                    return `${this.hostname}/${this.id}/get/${id}`;
                }
                async fetchPreAuthToken() {
                    if (!this.companionKeysParams) return;
                    try {
                        const res = await this.post(`${this.id}/preauth/`, {
                            params: this.companionKeysParams
                        });
                        this.preAuthToken = res.token;
                    } catch (err) {
                        this.uppy.log(`[CompanionClient] unable to fetch preAuthToken ${err}`, "warning");
                    }
                }
                list(directory) {
                    return this.get(`${this.id}/list/${directory || ""}`);
                }
                logout() {
                    return this.get(`${this.id}/logout`).then((response => Promise.all([ response, this.uppy.getPlugin(this.pluginId).storage.removeItem(this.tokenKey) ]))).then((_ref2 => {
                        let [response] = _ref2;
                        return response;
                    }));
                }
                static initPlugin(plugin, opts, defaultOpts) {
                    plugin.type = "acquirer";
                    plugin.files = [];
                    if (defaultOpts) plugin.opts = {
                        ...defaultOpts,
                        ...opts
                    };
                    if (opts.serverUrl || opts.serverPattern) throw new Error("`serverUrl` and `serverPattern` have been renamed to `companionUrl` and `companionAllowedHosts` respectively in the 0.30.5 release. Please consult the docs (for example, https://uppy.io/docs/instagram/ for the Instagram plugin) and use the updated options.`");
                    if (opts.companionAllowedHosts) {
                        const pattern = opts.companionAllowedHosts;
                        if ("string" !== typeof pattern && !Array.isArray(pattern) && !(pattern instanceof RegExp)) throw new TypeError(`${plugin.id}: the option "companionAllowedHosts" must be one of string, Array, RegExp`);
                        plugin.opts.companionAllowedHosts = pattern;
                    } else if (/^(?!https?:\/\/).*$/i.test(opts.companionUrl)) plugin.opts.companionAllowedHosts = `https://${opts.companionUrl.replace(/^\/\//, "")}`; else plugin.opts.companionAllowedHosts = new URL(opts.companionUrl).origin;
                    plugin.storage = plugin.opts.storage || tokenStorage;
                }
            };
        },
        2368: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var _class, _getPostResponseFunc, _getUrl, _errorHandler, _temp;
            function _classPrivateFieldLooseBase(receiver, privateKey) {
                if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) throw new TypeError("attempted to use private field on non-instance");
                return receiver;
            }
            var id = 0;
            function _classPrivateFieldLooseKey(name) {
                return "__private_" + id++ + "_" + name;
            }
            const fetchWithNetworkError = __webpack_require__(6865);
            const ErrorWithCause = __webpack_require__(5570);
            const AuthError = __webpack_require__(1220);
            function stripSlash(url) {
                return url.replace(/\/$/, "");
            }
            async function handleJSONResponse(res) {
                if (401 === res.status) throw new AuthError;
                const jsonPromise = res.json();
                if (res.status < 200 || res.status > 300) {
                    let errMsg = `Failed request with status: ${res.status}. ${res.statusText}`;
                    try {
                        const errData = await jsonPromise;
                        errMsg = errData.message ? `${errMsg} message: ${errData.message}` : errMsg;
                        errMsg = errData.requestId ? `${errMsg} request-Id: ${errData.requestId}` : errMsg;
                    } finally {
                        throw new Error(errMsg);
                    }
                }
                return jsonPromise;
            }
            module.exports = (_temp = (_getPostResponseFunc = _classPrivateFieldLooseKey("getPostResponseFunc"), 
            _getUrl = _classPrivateFieldLooseKey("getUrl"), _errorHandler = _classPrivateFieldLooseKey("errorHandler"), 
            _class = class RequestClient {
                constructor(uppy, opts) {
                    Object.defineProperty(this, _errorHandler, {
                        value: _errorHandler2
                    });
                    Object.defineProperty(this, _getUrl, {
                        value: _getUrl2
                    });
                    Object.defineProperty(this, _getPostResponseFunc, {
                        writable: true,
                        value: skip => response => skip ? response : this.onReceiveResponse(response)
                    });
                    this.uppy = uppy;
                    this.opts = opts;
                    this.onReceiveResponse = this.onReceiveResponse.bind(this);
                    this.allowedHeaders = [ "accept", "content-type", "uppy-auth-token" ];
                    this.preflightDone = false;
                }
                get hostname() {
                    const {companion} = this.uppy.getState();
                    const host = this.opts.companionUrl;
                    return stripSlash(companion && companion[host] ? companion[host] : host);
                }
                headers() {
                    const userHeaders = this.opts.companionHeaders || {};
                    return Promise.resolve({
                        ...RequestClient.defaultHeaders,
                        ...userHeaders
                    });
                }
                onReceiveResponse(response) {
                    const state = this.uppy.getState();
                    const companion = state.companion || {};
                    const host = this.opts.companionUrl;
                    const {headers} = response;
                    if (headers.has("i-am") && headers.get("i-am") !== companion[host]) this.uppy.setState({
                        companion: {
                            ...companion,
                            [host]: headers.get("i-am")
                        }
                    });
                    return response;
                }
                preflight(path) {
                    if (this.preflightDone) return Promise.resolve(this.allowedHeaders.slice());
                    return fetch(_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path), {
                        method: "OPTIONS"
                    }).then((response => {
                        if (response.headers.has("access-control-allow-headers")) this.allowedHeaders = response.headers.get("access-control-allow-headers").split(",").map((headerName => headerName.trim().toLowerCase()));
                        this.preflightDone = true;
                        return this.allowedHeaders.slice();
                    })).catch((err => {
                        this.uppy.log(`[CompanionClient] unable to make preflight request ${err}`, "warning");
                        this.preflightDone = true;
                        return this.allowedHeaders.slice();
                    }));
                }
                preflightAndHeaders(path) {
                    return Promise.all([ this.preflight(path), this.headers() ]).then((_ref => {
                        let [allowedHeaders, headers] = _ref;
                        Object.keys(headers).forEach((header => {
                            if (!allowedHeaders.includes(header.toLowerCase())) {
                                this.uppy.log(`[CompanionClient] excluding disallowed header ${header}`);
                                delete headers[header];
                            }
                        }));
                        return headers;
                    }));
                }
                get(path, skipPostResponse) {
                    const method = "get";
                    return this.preflightAndHeaders(path).then((headers => fetchWithNetworkError(_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path), {
                        method,
                        headers,
                        credentials: this.opts.companionCookiesRule || "same-origin"
                    }))).then(_classPrivateFieldLooseBase(this, _getPostResponseFunc)[_getPostResponseFunc](skipPostResponse)).then(handleJSONResponse).catch(_classPrivateFieldLooseBase(this, _errorHandler)[_errorHandler](method, path));
                }
                post(path, data, skipPostResponse) {
                    const method = "post";
                    return this.preflightAndHeaders(path).then((headers => fetchWithNetworkError(_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path), {
                        method,
                        headers,
                        credentials: this.opts.companionCookiesRule || "same-origin",
                        body: JSON.stringify(data)
                    }))).then(_classPrivateFieldLooseBase(this, _getPostResponseFunc)[_getPostResponseFunc](skipPostResponse)).then(handleJSONResponse).catch(_classPrivateFieldLooseBase(this, _errorHandler)[_errorHandler](method, path));
                }
                delete(path, data, skipPostResponse) {
                    const method = "delete";
                    return this.preflightAndHeaders(path).then((headers => fetchWithNetworkError(`${this.hostname}/${path}`, {
                        method,
                        headers,
                        credentials: this.opts.companionCookiesRule || "same-origin",
                        body: data ? JSON.stringify(data) : null
                    }))).then(_classPrivateFieldLooseBase(this, _getPostResponseFunc)[_getPostResponseFunc](skipPostResponse)).then(handleJSONResponse).catch(_classPrivateFieldLooseBase(this, _errorHandler)[_errorHandler](method, path));
                }
            }), _class.VERSION = "2.0.6", _class.defaultHeaders = {
                Accept: "application/json",
                "Content-Type": "application/json",
                "Uppy-Versions": `@uppy/companion-client=${_class.VERSION}`
            }, _temp);
            function _getUrl2(url) {
                if (/^(https?:|)\/\//.test(url)) return url;
                return `${this.hostname}/${url}`;
            }
            function _errorHandler2(method, path) {
                return err => {
                    var _err;
                    if (!(null != (_err = err) && _err.isAuthError)) err = new ErrorWithCause(`Could not ${method} ${_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path)}`, {
                        cause: err
                    });
                    return Promise.reject(err);
                };
            }
        },
        3145: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const RequestClient = __webpack_require__(2368);
            const getName = id => id.split("-").map((s => s.charAt(0).toUpperCase() + s.slice(1))).join(" ");
            module.exports = class SearchProvider extends RequestClient {
                constructor(uppy, opts) {
                    super(uppy, opts);
                    this.provider = opts.provider;
                    this.id = this.provider;
                    this.name = this.opts.name || getName(this.id);
                    this.pluginId = this.opts.pluginId;
                }
                fileUrl(id) {
                    return `${this.hostname}/search/${this.id}/get/${id}`;
                }
                search(text, queries) {
                    queries = queries ? `&${queries}` : "";
                    return this.get(`search/${this.id}/list?q=${encodeURIComponent(text)}${queries}`);
                }
            };
        },
        9906: (module, __unused_webpack_exports, __webpack_require__) => {
            var _queued, _emitter, _isOpen, _socket, _handleMessage;
            let _Symbol$for, _Symbol$for2;
            function _classPrivateFieldLooseBase(receiver, privateKey) {
                if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) throw new TypeError("attempted to use private field on non-instance");
                return receiver;
            }
            var id = 0;
            function _classPrivateFieldLooseKey(name) {
                return "__private_" + id++ + "_" + name;
            }
            const ee = __webpack_require__(4800);
            module.exports = (_queued = _classPrivateFieldLooseKey("queued"), _emitter = _classPrivateFieldLooseKey("emitter"), 
            _isOpen = _classPrivateFieldLooseKey("isOpen"), _socket = _classPrivateFieldLooseKey("socket"), 
            _handleMessage = _classPrivateFieldLooseKey("handleMessage"), _Symbol$for = Symbol.for("uppy test: getSocket"), 
            _Symbol$for2 = Symbol.for("uppy test: getQueued"), class UppySocket {
                constructor(opts) {
                    Object.defineProperty(this, _queued, {
                        writable: true,
                        value: []
                    });
                    Object.defineProperty(this, _emitter, {
                        writable: true,
                        value: ee()
                    });
                    Object.defineProperty(this, _isOpen, {
                        writable: true,
                        value: false
                    });
                    Object.defineProperty(this, _socket, {
                        writable: true,
                        value: void 0
                    });
                    Object.defineProperty(this, _handleMessage, {
                        writable: true,
                        value: e => {
                            try {
                                const message = JSON.parse(e.data);
                                this.emit(message.action, message.payload);
                            } catch (err) {
                                console.log(err);
                            }
                        }
                    });
                    this.opts = opts;
                    if (!opts || false !== opts.autoOpen) this.open();
                }
                get isOpen() {
                    return _classPrivateFieldLooseBase(this, _isOpen)[_isOpen];
                }
                [_Symbol$for]() {
                    return _classPrivateFieldLooseBase(this, _socket)[_socket];
                }
                [_Symbol$for2]() {
                    return _classPrivateFieldLooseBase(this, _queued)[_queued];
                }
                open() {
                    _classPrivateFieldLooseBase(this, _socket)[_socket] = new WebSocket(this.opts.target);
                    _classPrivateFieldLooseBase(this, _socket)[_socket].onopen = () => {
                        _classPrivateFieldLooseBase(this, _isOpen)[_isOpen] = true;
                        while (_classPrivateFieldLooseBase(this, _queued)[_queued].length > 0 && _classPrivateFieldLooseBase(this, _isOpen)[_isOpen]) {
                            const first = _classPrivateFieldLooseBase(this, _queued)[_queued].shift();
                            this.send(first.action, first.payload);
                        }
                    };
                    _classPrivateFieldLooseBase(this, _socket)[_socket].onclose = () => {
                        _classPrivateFieldLooseBase(this, _isOpen)[_isOpen] = false;
                    };
                    _classPrivateFieldLooseBase(this, _socket)[_socket].onmessage = _classPrivateFieldLooseBase(this, _handleMessage)[_handleMessage];
                }
                close() {
                    var _classPrivateFieldLoo;
                    null == (_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _socket)[_socket]) ? void 0 : _classPrivateFieldLoo.close();
                }
                send(action, payload) {
                    if (!_classPrivateFieldLooseBase(this, _isOpen)[_isOpen]) {
                        _classPrivateFieldLooseBase(this, _queued)[_queued].push({
                            action,
                            payload
                        });
                        return;
                    }
                    _classPrivateFieldLooseBase(this, _socket)[_socket].send(JSON.stringify({
                        action,
                        payload
                    }));
                }
                on(action, handler) {
                    _classPrivateFieldLooseBase(this, _emitter)[_emitter].on(action, handler);
                }
                emit(action, payload) {
                    _classPrivateFieldLooseBase(this, _emitter)[_emitter].emit(action, payload);
                }
                once(action, handler) {
                    _classPrivateFieldLooseBase(this, _emitter)[_emitter].once(action, handler);
                }
            });
        },
        6385: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const RequestClient = __webpack_require__(2368);
            const Provider = __webpack_require__(6808);
            const SearchProvider = __webpack_require__(3145);
            const Socket = __webpack_require__(9906);
            module.exports = {
                RequestClient,
                Provider,
                SearchProvider,
                Socket
            };
        },
        8871: module => {
            "use strict";
            module.exports.setItem = (key, value) => new Promise((resolve => {
                localStorage.setItem(key, value);
                resolve();
            }));
            module.exports.getItem = key => Promise.resolve(localStorage.getItem(key));
            module.exports.removeItem = key => new Promise((resolve => {
                localStorage.removeItem(key);
                resolve();
            }));
        },
        8937: (module, __unused_webpack_exports, __webpack_require__) => {
            const Translator = __webpack_require__(3363);
            module.exports = class BasePlugin {
                constructor(uppy, opts) {
                    if (void 0 === opts) opts = {};
                    this.uppy = uppy;
                    this.opts = opts;
                }
                getPluginState() {
                    const {plugins} = this.uppy.getState();
                    return plugins[this.id] || {};
                }
                setPluginState(update) {
                    const {plugins} = this.uppy.getState();
                    this.uppy.setState({
                        plugins: {
                            ...plugins,
                            [this.id]: {
                                ...plugins[this.id],
                                ...update
                            }
                        }
                    });
                }
                setOptions(newOpts) {
                    this.opts = {
                        ...this.opts,
                        ...newOpts
                    };
                    this.setPluginState();
                    this.i18nInit();
                }
                i18nInit() {
                    const translator = new Translator([ this.defaultLocale, this.uppy.locale, this.opts.locale ]);
                    this.i18n = translator.translate.bind(translator);
                    this.i18nArray = translator.translateArray.bind(translator);
                    this.setPluginState();
                }
                addTarget() {
                    throw new Error("Extend the addTarget method to add your plugin to another plugin's target");
                }
                install() {}
                uninstall() {}
                render() {
                    throw new Error("Extend the render method to add your plugin to a DOM element");
                }
                update() {}
                afterUpdate() {}
            };
        },
        3e3: (module, __unused_webpack_exports, __webpack_require__) => {
            const prettierBytes = __webpack_require__(5158);
            const match = __webpack_require__(4193);
            const defaultOptions = {
                maxFileSize: null,
                minFileSize: null,
                maxTotalFileSize: null,
                maxNumberOfFiles: null,
                minNumberOfFiles: null,
                allowedFileTypes: null,
                requiredMetaFields: []
            };
            class RestrictionError extends Error {
                constructor() {
                    super(...arguments);
                    this.isRestriction = true;
                }
            }
            if ("undefined" === typeof AggregateError) globalThis.AggregateError = class AggregateError extends Error {
                constructor(errors, message) {
                    super(message);
                    this.errors = errors;
                }
            };
            class Restricter {
                constructor(getOpts, i18n) {
                    this.i18n = i18n;
                    this.getOpts = () => {
                        const opts = getOpts();
                        if (null != opts.restrictions.allowedFileTypes && !Array.isArray(opts.restrictions.allowedFileTypes)) throw new TypeError("`restrictions.allowedFileTypes` must be an array");
                        return opts;
                    };
                }
                validate(file, files) {
                    const {maxFileSize, minFileSize, maxTotalFileSize, maxNumberOfFiles, allowedFileTypes} = this.getOpts().restrictions;
                    if (maxNumberOfFiles && files.length + 1 > maxNumberOfFiles) throw new RestrictionError(`${this.i18n("youCanOnlyUploadX", {
                        smart_count: maxNumberOfFiles
                    })}`);
                    if (allowedFileTypes) {
                        const isCorrectFileType = allowedFileTypes.some((type => {
                            if (type.includes("/")) {
                                if (!file.type) return false;
                                return match(file.type.replace(/;.*?$/, ""), type);
                            }
                            if ("." === type[0] && file.extension) return file.extension.toLowerCase() === type.slice(1).toLowerCase();
                            return false;
                        }));
                        if (!isCorrectFileType) {
                            const allowedFileTypesString = allowedFileTypes.join(", ");
                            throw new RestrictionError(this.i18n("youCanOnlyUploadFileTypes", {
                                types: allowedFileTypesString
                            }));
                        }
                    }
                    if (maxTotalFileSize && null != file.size) {
                        const totalFilesSize = files.reduce(((total, f) => total + f.size), file.size);
                        if (totalFilesSize > maxTotalFileSize) throw new RestrictionError(this.i18n("exceedsSize", {
                            size: prettierBytes(maxTotalFileSize),
                            file: file.name
                        }));
                    }
                    if (maxFileSize && null != file.size && file.size > maxFileSize) throw new RestrictionError(this.i18n("exceedsSize", {
                        size: prettierBytes(maxFileSize),
                        file: file.name
                    }));
                    if (minFileSize && null != file.size && file.size < minFileSize) throw new RestrictionError(this.i18n("inferiorSize", {
                        size: prettierBytes(minFileSize)
                    }));
                }
                validateMinNumberOfFiles(files) {
                    const {minNumberOfFiles} = this.getOpts().restrictions;
                    if (Object.keys(files).length < minNumberOfFiles) throw new RestrictionError(this.i18n("youHaveToAtLeastSelectX", {
                        smart_count: minNumberOfFiles
                    }));
                }
                getMissingRequiredMetaFields(file) {
                    const error = new RestrictionError(this.i18n("missingRequiredMetaFieldOnFile", {
                        fileName: file.name
                    }));
                    const {requiredMetaFields} = this.getOpts().restrictions;
                    const own = Object.prototype.hasOwnProperty;
                    const missingFields = [];
                    for (const field of requiredMetaFields) if (!own.call(file.meta, field) || "" === file.meta[field]) missingFields.push(field);
                    return {
                        missingFields,
                        error
                    };
                }
            }
            module.exports = {
                Restricter,
                defaultOptions,
                RestrictionError
            };
        },
        4649: (module, __unused_webpack_exports, __webpack_require__) => {
            function _classPrivateFieldLooseBase(receiver, privateKey) {
                if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) throw new TypeError("attempted to use private field on non-instance");
                return receiver;
            }
            var id = 0;
            function _classPrivateFieldLooseKey(name) {
                return "__private_" + id++ + "_" + name;
            }
            const {render} = __webpack_require__(6400);
            const findDOMElement = __webpack_require__(2729);
            const BasePlugin = __webpack_require__(8937);
            function debounce(fn) {
                let calling = null;
                let latestArgs = null;
                return function() {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    latestArgs = args;
                    if (!calling) calling = Promise.resolve().then((() => {
                        calling = null;
                        return fn(...latestArgs);
                    }));
                    return calling;
                };
            }
            var _updateUI = _classPrivateFieldLooseKey("updateUI");
            class UIPlugin extends BasePlugin {
                constructor() {
                    super(...arguments);
                    Object.defineProperty(this, _updateUI, {
                        writable: true,
                        value: void 0
                    });
                }
                mount(target, plugin) {
                    const callerPluginName = plugin.id;
                    const targetElement = findDOMElement(target);
                    if (targetElement) {
                        this.isTargetDOMEl = true;
                        const uppyRootElement = document.createDocumentFragment();
                        _classPrivateFieldLooseBase(this, _updateUI)[_updateUI] = debounce((state => {
                            if (!this.uppy.getPlugin(this.id)) return;
                            render(this.render(state), uppyRootElement);
                            this.afterUpdate();
                        }));
                        this.uppy.log(`Installing ${callerPluginName} to a DOM element '${target}'`);
                        if (this.opts.replaceTargetContent) targetElement.innerHTML = "";
                        render(this.render(this.uppy.getState()), uppyRootElement);
                        this.el = uppyRootElement.firstElementChild;
                        targetElement.appendChild(uppyRootElement);
                        this.onMount();
                        return this.el;
                    }
                    let targetPlugin;
                    if ("object" === typeof target && target instanceof UIPlugin) targetPlugin = target; else if ("function" === typeof target) {
                        const Target = target;
                        this.uppy.iteratePlugins((p => {
                            if (p instanceof Target) {
                                targetPlugin = p;
                                return false;
                            }
                        }));
                    }
                    if (targetPlugin) {
                        this.uppy.log(`Installing ${callerPluginName} to ${targetPlugin.id}`);
                        this.parent = targetPlugin;
                        this.el = targetPlugin.addTarget(plugin);
                        this.onMount();
                        return this.el;
                    }
                    this.uppy.log(`Not installing ${callerPluginName}`);
                    let message = `Invalid target option given to ${callerPluginName}.`;
                    if ("function" === typeof target) message += " The given target is not a Plugin class. " + "Please check that you're not specifying a React Component instead of a plugin. " + "If you are using @uppy/* packages directly, make sure you have only 1 version of @uppy/core installed: " + "run `npm ls @uppy/core` on the command line and verify that all the versions match and are deduped correctly."; else message += "If you meant to target an HTML element, please make sure that the element exists. " + "Check that the <script> tag initializing Uppy is right before the closing </body> tag at the end of the page. " + "(see https://github.com/transloadit/uppy/issues/1042)\n\n" + "If you meant to target a plugin, please confirm that your `import` statements or `require` calls are correct.";
                    throw new Error(message);
                }
                update(state) {
                    if (null != this.el) {
                        var _classPrivateFieldLoo, _classPrivateFieldLoo2;
                        null == (_classPrivateFieldLoo = (_classPrivateFieldLoo2 = _classPrivateFieldLooseBase(this, _updateUI))[_updateUI]) ? void 0 : _classPrivateFieldLoo.call(_classPrivateFieldLoo2, state);
                    }
                }
                unmount() {
                    if (this.isTargetDOMEl) {
                        var _this$el;
                        null == (_this$el = this.el) ? void 0 : _this$el.remove();
                    }
                    this.onUnmount();
                }
                onMount() {}
                onUnmount() {}
            }
            module.exports = UIPlugin;
        },
        1790: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            let _Symbol$for, _Symbol$for2;
            function _classPrivateFieldLooseBase(receiver, privateKey) {
                if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) throw new TypeError("attempted to use private field on non-instance");
                return receiver;
            }
            var id = 0;
            function _classPrivateFieldLooseKey(name) {
                return "__private_" + id++ + "_" + name;
            }
            const Translator = __webpack_require__(3363);
            const ee = __webpack_require__(4800);
            const {nanoid} = __webpack_require__(2961);
            const throttle = __webpack_require__(3096);
            const DefaultStore = __webpack_require__(6273);
            const getFileType = __webpack_require__(9404);
            const getFileNameAndExtension = __webpack_require__(8744);
            const generateFileID = __webpack_require__(8619);
            const supportsUploadProgress = __webpack_require__(8585);
            const getFileName = __webpack_require__(2008);
            const {justErrorsLogger, debugLogger} = __webpack_require__(4519);
            const {Restricter, defaultOptions: defaultRestrictionOptions, RestrictionError} = __webpack_require__(3e3);
            const locale = __webpack_require__(8998);
            var _plugins = _classPrivateFieldLooseKey("plugins");
            var _restricter = _classPrivateFieldLooseKey("restricter");
            var _storeUnsubscribe = _classPrivateFieldLooseKey("storeUnsubscribe");
            var _emitter = _classPrivateFieldLooseKey("emitter");
            var _preProcessors = _classPrivateFieldLooseKey("preProcessors");
            var _uploaders = _classPrivateFieldLooseKey("uploaders");
            var _postProcessors = _classPrivateFieldLooseKey("postProcessors");
            var _informAndEmit = _classPrivateFieldLooseKey("informAndEmit");
            var _checkRequiredMetaFieldsOnFile = _classPrivateFieldLooseKey("checkRequiredMetaFieldsOnFile");
            var _checkRequiredMetaFields = _classPrivateFieldLooseKey("checkRequiredMetaFields");
            var _assertNewUploadAllowed = _classPrivateFieldLooseKey("assertNewUploadAllowed");
            var _checkAndCreateFileStateObject = _classPrivateFieldLooseKey("checkAndCreateFileStateObject");
            var _startIfAutoProceed = _classPrivateFieldLooseKey("startIfAutoProceed");
            var _addListeners = _classPrivateFieldLooseKey("addListeners");
            var _updateOnlineStatus = _classPrivateFieldLooseKey("updateOnlineStatus");
            var _createUpload = _classPrivateFieldLooseKey("createUpload");
            var _getUpload = _classPrivateFieldLooseKey("getUpload");
            var _removeUpload = _classPrivateFieldLooseKey("removeUpload");
            var _runUpload = _classPrivateFieldLooseKey("runUpload");
            _Symbol$for = Symbol.for("uppy test: getPlugins");
            _Symbol$for2 = Symbol.for("uppy test: createUpload");
            class Uppy {
                constructor(_opts) {
                    Object.defineProperty(this, _runUpload, {
                        value: _runUpload2
                    });
                    Object.defineProperty(this, _removeUpload, {
                        value: _removeUpload2
                    });
                    Object.defineProperty(this, _getUpload, {
                        value: _getUpload2
                    });
                    Object.defineProperty(this, _createUpload, {
                        value: _createUpload2
                    });
                    Object.defineProperty(this, _addListeners, {
                        value: _addListeners2
                    });
                    Object.defineProperty(this, _startIfAutoProceed, {
                        value: _startIfAutoProceed2
                    });
                    Object.defineProperty(this, _checkAndCreateFileStateObject, {
                        value: _checkAndCreateFileStateObject2
                    });
                    Object.defineProperty(this, _assertNewUploadAllowed, {
                        value: _assertNewUploadAllowed2
                    });
                    Object.defineProperty(this, _checkRequiredMetaFields, {
                        value: _checkRequiredMetaFields2
                    });
                    Object.defineProperty(this, _checkRequiredMetaFieldsOnFile, {
                        value: _checkRequiredMetaFieldsOnFile2
                    });
                    Object.defineProperty(this, _informAndEmit, {
                        value: _informAndEmit2
                    });
                    Object.defineProperty(this, _plugins, {
                        writable: true,
                        value: Object.create(null)
                    });
                    Object.defineProperty(this, _restricter, {
                        writable: true,
                        value: void 0
                    });
                    Object.defineProperty(this, _storeUnsubscribe, {
                        writable: true,
                        value: void 0
                    });
                    Object.defineProperty(this, _emitter, {
                        writable: true,
                        value: ee()
                    });
                    Object.defineProperty(this, _preProcessors, {
                        writable: true,
                        value: new Set
                    });
                    Object.defineProperty(this, _uploaders, {
                        writable: true,
                        value: new Set
                    });
                    Object.defineProperty(this, _postProcessors, {
                        writable: true,
                        value: new Set
                    });
                    Object.defineProperty(this, _updateOnlineStatus, {
                        writable: true,
                        value: this.updateOnlineStatus.bind(this)
                    });
                    this.defaultLocale = locale;
                    const defaultOptions = {
                        id: "uppy",
                        autoProceed: false,
                        allowMultipleUploads: true,
                        allowMultipleUploadBatches: true,
                        debug: false,
                        restrictions: defaultRestrictionOptions,
                        meta: {},
                        onBeforeFileAdded: currentFile => currentFile,
                        onBeforeUpload: files => files,
                        store: DefaultStore(),
                        logger: justErrorsLogger,
                        infoTimeout: 5e3
                    };
                    this.opts = {
                        ...defaultOptions,
                        ..._opts,
                        restrictions: {
                            ...defaultOptions.restrictions,
                            ..._opts && _opts.restrictions
                        }
                    };
                    if (_opts && _opts.logger && _opts.debug) this.log("You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.", "warning"); else if (_opts && _opts.debug) this.opts.logger = debugLogger;
                    this.log(`Using Core v${this.constructor.VERSION}`);
                    this.i18nInit();
                    this.calculateProgress = throttle(this.calculateProgress.bind(this), 500, {
                        leading: true,
                        trailing: true
                    });
                    this.store = this.opts.store;
                    this.setState({
                        plugins: {},
                        files: {},
                        currentUploads: {},
                        allowNewUpload: true,
                        capabilities: {
                            uploadProgress: supportsUploadProgress(),
                            individualCancellation: true,
                            resumableUploads: false
                        },
                        totalProgress: 0,
                        meta: {
                            ...this.opts.meta
                        },
                        info: [],
                        recoveredState: null
                    });
                    _classPrivateFieldLooseBase(this, _restricter)[_restricter] = new Restricter((() => this.opts), this.i18n);
                    _classPrivateFieldLooseBase(this, _storeUnsubscribe)[_storeUnsubscribe] = this.store.subscribe(((prevState, nextState, patch) => {
                        this.emit("state-update", prevState, nextState, patch);
                        this.updateAll(nextState);
                    }));
                    if (this.opts.debug && "undefined" !== typeof window) window[this.opts.id] = this;
                    _classPrivateFieldLooseBase(this, _addListeners)[_addListeners]();
                }
                emit(event) {
                    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                    _classPrivateFieldLooseBase(this, _emitter)[_emitter].emit(event, ...args);
                }
                on(event, callback) {
                    _classPrivateFieldLooseBase(this, _emitter)[_emitter].on(event, callback);
                    return this;
                }
                once(event, callback) {
                    _classPrivateFieldLooseBase(this, _emitter)[_emitter].once(event, callback);
                    return this;
                }
                off(event, callback) {
                    _classPrivateFieldLooseBase(this, _emitter)[_emitter].off(event, callback);
                    return this;
                }
                updateAll(state) {
                    this.iteratePlugins((plugin => {
                        plugin.update(state);
                    }));
                }
                setState(patch) {
                    this.store.setState(patch);
                }
                getState() {
                    return this.store.getState();
                }
                get state() {
                    return this.getState();
                }
                setFileState(fileID, state) {
                    if (!this.getState().files[fileID]) throw new Error(`Can’t set state for ${fileID} (the file could have been removed)`);
                    this.setState({
                        files: {
                            ...this.getState().files,
                            [fileID]: {
                                ...this.getState().files[fileID],
                                ...state
                            }
                        }
                    });
                }
                i18nInit() {
                    const translator = new Translator([ this.defaultLocale, this.opts.locale ]);
                    this.i18n = translator.translate.bind(translator);
                    this.i18nArray = translator.translateArray.bind(translator);
                    this.locale = translator.locale;
                }
                setOptions(newOpts) {
                    this.opts = {
                        ...this.opts,
                        ...newOpts,
                        restrictions: {
                            ...this.opts.restrictions,
                            ...newOpts && newOpts.restrictions
                        }
                    };
                    if (newOpts.meta) this.setMeta(newOpts.meta);
                    this.i18nInit();
                    if (newOpts.locale) this.iteratePlugins((plugin => {
                        plugin.setOptions();
                    }));
                    this.setState();
                }
                resetProgress() {
                    const defaultProgress = {
                        percentage: 0,
                        bytesUploaded: 0,
                        uploadComplete: false,
                        uploadStarted: null
                    };
                    const files = {
                        ...this.getState().files
                    };
                    const updatedFiles = {};
                    Object.keys(files).forEach((fileID => {
                        const updatedFile = {
                            ...files[fileID]
                        };
                        updatedFile.progress = {
                            ...updatedFile.progress,
                            ...defaultProgress
                        };
                        updatedFiles[fileID] = updatedFile;
                    }));
                    this.setState({
                        files: updatedFiles,
                        totalProgress: 0
                    });
                    this.emit("reset-progress");
                }
                addPreProcessor(fn) {
                    _classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors].add(fn);
                }
                removePreProcessor(fn) {
                    return _classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors].delete(fn);
                }
                addPostProcessor(fn) {
                    _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].add(fn);
                }
                removePostProcessor(fn) {
                    return _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].delete(fn);
                }
                addUploader(fn) {
                    _classPrivateFieldLooseBase(this, _uploaders)[_uploaders].add(fn);
                }
                removeUploader(fn) {
                    return _classPrivateFieldLooseBase(this, _uploaders)[_uploaders].delete(fn);
                }
                setMeta(data) {
                    const updatedMeta = {
                        ...this.getState().meta,
                        ...data
                    };
                    const updatedFiles = {
                        ...this.getState().files
                    };
                    Object.keys(updatedFiles).forEach((fileID => {
                        updatedFiles[fileID] = {
                            ...updatedFiles[fileID],
                            meta: {
                                ...updatedFiles[fileID].meta,
                                ...data
                            }
                        };
                    }));
                    this.log("Adding metadata:");
                    this.log(data);
                    this.setState({
                        meta: updatedMeta,
                        files: updatedFiles
                    });
                }
                setFileMeta(fileID, data) {
                    const updatedFiles = {
                        ...this.getState().files
                    };
                    if (!updatedFiles[fileID]) {
                        this.log("Was trying to set metadata for a file that has been removed: ", fileID);
                        return;
                    }
                    const newMeta = {
                        ...updatedFiles[fileID].meta,
                        ...data
                    };
                    updatedFiles[fileID] = {
                        ...updatedFiles[fileID],
                        meta: newMeta
                    };
                    this.setState({
                        files: updatedFiles
                    });
                }
                getFile(fileID) {
                    return this.getState().files[fileID];
                }
                getFiles() {
                    const {files} = this.getState();
                    return Object.values(files);
                }
                getObjectOfFilesPerState() {
                    const {files: filesObject, totalProgress, error} = this.getState();
                    const files = Object.values(filesObject);
                    const inProgressFiles = files.filter((_ref => {
                        let {progress} = _ref;
                        return !progress.uploadComplete && progress.uploadStarted;
                    }));
                    const newFiles = files.filter((file => !file.progress.uploadStarted));
                    const startedFiles = files.filter((file => file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess));
                    const uploadStartedFiles = files.filter((file => file.progress.uploadStarted));
                    const pausedFiles = files.filter((file => file.isPaused));
                    const completeFiles = files.filter((file => file.progress.uploadComplete));
                    const erroredFiles = files.filter((file => file.error));
                    const inProgressNotPausedFiles = inProgressFiles.filter((file => !file.isPaused));
                    const processingFiles = files.filter((file => file.progress.preprocess || file.progress.postprocess));
                    return {
                        newFiles,
                        startedFiles,
                        uploadStartedFiles,
                        pausedFiles,
                        completeFiles,
                        erroredFiles,
                        inProgressFiles,
                        inProgressNotPausedFiles,
                        processingFiles,
                        isUploadStarted: uploadStartedFiles.length > 0,
                        isAllComplete: 100 === totalProgress && completeFiles.length === files.length && 0 === processingFiles.length,
                        isAllErrored: !!error && erroredFiles.length === files.length,
                        isAllPaused: 0 !== inProgressFiles.length && pausedFiles.length === inProgressFiles.length,
                        isUploadInProgress: inProgressFiles.length > 0,
                        isSomeGhost: files.some((file => file.isGhost))
                    };
                }
                validateRestrictions(file, files) {
                    if (void 0 === files) files = this.getFiles();
                    try {
                        _classPrivateFieldLooseBase(this, _restricter)[_restricter].validate(file, files);
                        return {
                            result: true
                        };
                    } catch (err) {
                        return {
                            result: false,
                            reason: err.message
                        };
                    }
                }
                checkIfFileAlreadyExists(fileID) {
                    const {files} = this.getState();
                    if (files[fileID] && !files[fileID].isGhost) return true;
                    return false;
                }
                addFile(file) {
                    _classPrivateFieldLooseBase(this, _assertNewUploadAllowed)[_assertNewUploadAllowed](file);
                    const {files} = this.getState();
                    let newFile = _classPrivateFieldLooseBase(this, _checkAndCreateFileStateObject)[_checkAndCreateFileStateObject](files, file);
                    if (files[newFile.id] && files[newFile.id].isGhost) {
                        newFile = {
                            ...files[newFile.id],
                            data: file.data,
                            isGhost: false
                        };
                        this.log(`Replaced the blob in the restored ghost file: ${newFile.name}, ${newFile.id}`);
                    }
                    this.setState({
                        files: {
                            ...files,
                            [newFile.id]: newFile
                        }
                    });
                    this.emit("file-added", newFile);
                    this.emit("files-added", [ newFile ]);
                    this.log(`Added file: ${newFile.name}, ${newFile.id}, mime type: ${newFile.type}`);
                    _classPrivateFieldLooseBase(this, _startIfAutoProceed)[_startIfAutoProceed]();
                    return newFile.id;
                }
                addFiles(fileDescriptors) {
                    _classPrivateFieldLooseBase(this, _assertNewUploadAllowed)[_assertNewUploadAllowed]();
                    const files = {
                        ...this.getState().files
                    };
                    const newFiles = [];
                    const errors = [];
                    for (let i = 0; i < fileDescriptors.length; i++) try {
                        let newFile = _classPrivateFieldLooseBase(this, _checkAndCreateFileStateObject)[_checkAndCreateFileStateObject](files, fileDescriptors[i]);
                        if (files[newFile.id] && files[newFile.id].isGhost) {
                            newFile = {
                                ...files[newFile.id],
                                data: fileDescriptors[i].data,
                                isGhost: false
                            };
                            this.log(`Replaced blob in a ghost file: ${newFile.name}, ${newFile.id}`);
                        }
                        files[newFile.id] = newFile;
                        newFiles.push(newFile);
                    } catch (err) {
                        if (!err.isRestriction) errors.push(err);
                    }
                    this.setState({
                        files
                    });
                    newFiles.forEach((newFile => {
                        this.emit("file-added", newFile);
                    }));
                    this.emit("files-added", newFiles);
                    if (newFiles.length > 5) this.log(`Added batch of ${newFiles.length} files`); else Object.keys(newFiles).forEach((fileID => {
                        this.log(`Added file: ${newFiles[fileID].name}\n id: ${newFiles[fileID].id}\n type: ${newFiles[fileID].type}`);
                    }));
                    if (newFiles.length > 0) _classPrivateFieldLooseBase(this, _startIfAutoProceed)[_startIfAutoProceed]();
                    if (errors.length > 0) {
                        let message = "Multiple errors occurred while adding files:\n";
                        errors.forEach((subError => {
                            message += `\n * ${subError.message}`;
                        }));
                        this.info({
                            message: this.i18n("addBulkFilesFailed", {
                                smart_count: errors.length
                            }),
                            details: message
                        }, "error", this.opts.infoTimeout);
                        if ("function" === typeof AggregateError) throw new AggregateError(errors, message); else {
                            const err = new Error(message);
                            err.errors = errors;
                            throw err;
                        }
                    }
                }
                removeFiles(fileIDs, reason) {
                    const {files, currentUploads} = this.getState();
                    const updatedFiles = {
                        ...files
                    };
                    const updatedUploads = {
                        ...currentUploads
                    };
                    const removedFiles = Object.create(null);
                    fileIDs.forEach((fileID => {
                        if (files[fileID]) {
                            removedFiles[fileID] = files[fileID];
                            delete updatedFiles[fileID];
                        }
                    }));
                    function fileIsNotRemoved(uploadFileID) {
                        return void 0 === removedFiles[uploadFileID];
                    }
                    Object.keys(updatedUploads).forEach((uploadID => {
                        const newFileIDs = currentUploads[uploadID].fileIDs.filter(fileIsNotRemoved);
                        if (0 === newFileIDs.length) {
                            delete updatedUploads[uploadID];
                            return;
                        }
                        updatedUploads[uploadID] = {
                            ...currentUploads[uploadID],
                            fileIDs: newFileIDs
                        };
                    }));
                    const stateUpdate = {
                        currentUploads: updatedUploads,
                        files: updatedFiles
                    };
                    if (0 === Object.keys(updatedFiles).length) {
                        stateUpdate.allowNewUpload = true;
                        stateUpdate.error = null;
                        stateUpdate.recoveredState = null;
                    }
                    this.setState(stateUpdate);
                    this.calculateTotalProgress();
                    const removedFileIDs = Object.keys(removedFiles);
                    removedFileIDs.forEach((fileID => {
                        this.emit("file-removed", removedFiles[fileID], reason);
                    }));
                    if (removedFileIDs.length > 5) this.log(`Removed ${removedFileIDs.length} files`); else this.log(`Removed files: ${removedFileIDs.join(", ")}`);
                }
                removeFile(fileID, reason) {
                    if (void 0 === reason) reason = null;
                    this.removeFiles([ fileID ], reason);
                }
                pauseResume(fileID) {
                    if (!this.getState().capabilities.resumableUploads || this.getFile(fileID).uploadComplete) return;
                    const wasPaused = this.getFile(fileID).isPaused || false;
                    const isPaused = !wasPaused;
                    this.setFileState(fileID, {
                        isPaused
                    });
                    this.emit("upload-pause", fileID, isPaused);
                    return isPaused;
                }
                pauseAll() {
                    const updatedFiles = {
                        ...this.getState().files
                    };
                    const inProgressUpdatedFiles = Object.keys(updatedFiles).filter((file => !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted));
                    inProgressUpdatedFiles.forEach((file => {
                        const updatedFile = {
                            ...updatedFiles[file],
                            isPaused: true
                        };
                        updatedFiles[file] = updatedFile;
                    }));
                    this.setState({
                        files: updatedFiles
                    });
                    this.emit("pause-all");
                }
                resumeAll() {
                    const updatedFiles = {
                        ...this.getState().files
                    };
                    const inProgressUpdatedFiles = Object.keys(updatedFiles).filter((file => !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted));
                    inProgressUpdatedFiles.forEach((file => {
                        const updatedFile = {
                            ...updatedFiles[file],
                            isPaused: false,
                            error: null
                        };
                        updatedFiles[file] = updatedFile;
                    }));
                    this.setState({
                        files: updatedFiles
                    });
                    this.emit("resume-all");
                }
                retryAll() {
                    const updatedFiles = {
                        ...this.getState().files
                    };
                    const filesToRetry = Object.keys(updatedFiles).filter((file => updatedFiles[file].error));
                    filesToRetry.forEach((file => {
                        const updatedFile = {
                            ...updatedFiles[file],
                            isPaused: false,
                            error: null
                        };
                        updatedFiles[file] = updatedFile;
                    }));
                    this.setState({
                        files: updatedFiles,
                        error: null
                    });
                    this.emit("retry-all", filesToRetry);
                    if (0 === filesToRetry.length) return Promise.resolve({
                        successful: [],
                        failed: []
                    });
                    const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](filesToRetry, {
                        forceAllowNewUpload: true
                    });
                    return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);
                }
                cancelAll() {
                    this.emit("cancel-all");
                    const {files} = this.getState();
                    const fileIDs = Object.keys(files);
                    if (fileIDs.length) this.removeFiles(fileIDs, "cancel-all");
                    this.setState({
                        totalProgress: 0,
                        error: null,
                        recoveredState: null
                    });
                }
                retryUpload(fileID) {
                    this.setFileState(fileID, {
                        error: null,
                        isPaused: false
                    });
                    this.emit("upload-retry", fileID);
                    const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload]([ fileID ], {
                        forceAllowNewUpload: true
                    });
                    return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);
                }
                reset() {
                    this.cancelAll();
                }
                logout() {
                    this.iteratePlugins((plugin => {
                        if (plugin.provider && plugin.provider.logout) plugin.provider.logout();
                    }));
                }
                calculateProgress(file, data) {
                    if (!this.getFile(file.id)) {
                        this.log(`Not setting progress for a file that has been removed: ${file.id}`);
                        return;
                    }
                    const canHavePercentage = Number.isFinite(data.bytesTotal) && data.bytesTotal > 0;
                    this.setFileState(file.id, {
                        progress: {
                            ...this.getFile(file.id).progress,
                            bytesUploaded: data.bytesUploaded,
                            bytesTotal: data.bytesTotal,
                            percentage: canHavePercentage ? Math.round(data.bytesUploaded / data.bytesTotal * 100) : 0
                        }
                    });
                    this.calculateTotalProgress();
                }
                calculateTotalProgress() {
                    const files = this.getFiles();
                    const inProgress = files.filter((file => file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess));
                    if (0 === inProgress.length) {
                        this.emit("progress", 0);
                        this.setState({
                            totalProgress: 0
                        });
                        return;
                    }
                    const sizedFiles = inProgress.filter((file => null != file.progress.bytesTotal));
                    const unsizedFiles = inProgress.filter((file => null == file.progress.bytesTotal));
                    if (0 === sizedFiles.length) {
                        const progressMax = 100 * inProgress.length;
                        const currentProgress = unsizedFiles.reduce(((acc, file) => acc + file.progress.percentage), 0);
                        const totalProgress = Math.round(currentProgress / progressMax * 100);
                        this.setState({
                            totalProgress
                        });
                        return;
                    }
                    let totalSize = sizedFiles.reduce(((acc, file) => acc + file.progress.bytesTotal), 0);
                    const averageSize = totalSize / sizedFiles.length;
                    totalSize += averageSize * unsizedFiles.length;
                    let uploadedSize = 0;
                    sizedFiles.forEach((file => {
                        uploadedSize += file.progress.bytesUploaded;
                    }));
                    unsizedFiles.forEach((file => {
                        uploadedSize += averageSize * (file.progress.percentage || 0) / 100;
                    }));
                    let totalProgress = 0 === totalSize ? 0 : Math.round(uploadedSize / totalSize * 100);
                    if (totalProgress > 100) totalProgress = 100;
                    this.setState({
                        totalProgress
                    });
                    this.emit("progress", totalProgress);
                }
                updateOnlineStatus() {
                    const online = "undefined" !== typeof window.navigator.onLine ? window.navigator.onLine : true;
                    if (!online) {
                        this.emit("is-offline");
                        this.info(this.i18n("noInternetConnection"), "error", 0);
                        this.wasOffline = true;
                    } else {
                        this.emit("is-online");
                        if (this.wasOffline) {
                            this.emit("back-online");
                            this.info(this.i18n("connectedToInternet"), "success", 3e3);
                            this.wasOffline = false;
                        }
                    }
                }
                getID() {
                    return this.opts.id;
                }
                use(Plugin, opts) {
                    if ("function" !== typeof Plugin) {
                        const msg = `Expected a plugin class, but got ${null === Plugin ? "null" : typeof Plugin}.` + " Please verify that the plugin was imported and spelled correctly.";
                        throw new TypeError(msg);
                    }
                    const plugin = new Plugin(this, opts);
                    const pluginId = plugin.id;
                    if (!pluginId) throw new Error("Your plugin must have an id");
                    if (!plugin.type) throw new Error("Your plugin must have a type");
                    const existsPluginAlready = this.getPlugin(pluginId);
                    if (existsPluginAlready) {
                        const msg = `Already found a plugin named '${existsPluginAlready.id}'. ` + `Tried to use: '${pluginId}'.\n` + "Uppy plugins must have unique `id` options. See https://uppy.io/docs/plugins/#id.";
                        throw new Error(msg);
                    }
                    if (Plugin.VERSION) this.log(`Using ${pluginId} v${Plugin.VERSION}`);
                    if (plugin.type in _classPrivateFieldLooseBase(this, _plugins)[_plugins]) _classPrivateFieldLooseBase(this, _plugins)[_plugins][plugin.type].push(plugin); else _classPrivateFieldLooseBase(this, _plugins)[_plugins][plugin.type] = [ plugin ];
                    plugin.install();
                    return this;
                }
                getPlugin(id) {
                    for (const plugins of Object.values(_classPrivateFieldLooseBase(this, _plugins)[_plugins])) {
                        const foundPlugin = plugins.find((plugin => plugin.id === id));
                        if (null != foundPlugin) return foundPlugin;
                    }
                    return;
                }
                [_Symbol$for](type) {
                    return _classPrivateFieldLooseBase(this, _plugins)[_plugins][type];
                }
                iteratePlugins(method) {
                    Object.values(_classPrivateFieldLooseBase(this, _plugins)[_plugins]).flat(1).forEach(method);
                }
                removePlugin(instance) {
                    this.log(`Removing plugin ${instance.id}`);
                    this.emit("plugin-remove", instance);
                    if (instance.uninstall) instance.uninstall();
                    const list = _classPrivateFieldLooseBase(this, _plugins)[_plugins][instance.type];
                    const index = list.findIndex((item => item.id === instance.id));
                    if (-1 !== index) list.splice(index, 1);
                    const state = this.getState();
                    const updatedState = {
                        plugins: {
                            ...state.plugins,
                            [instance.id]: void 0
                        }
                    };
                    this.setState(updatedState);
                }
                close() {
                    this.log(`Closing Uppy instance ${this.opts.id}: removing all files and uninstalling plugins`);
                    this.reset();
                    _classPrivateFieldLooseBase(this, _storeUnsubscribe)[_storeUnsubscribe]();
                    this.iteratePlugins((plugin => {
                        this.removePlugin(plugin);
                    }));
                    if ("undefined" !== typeof window && window.removeEventListener) {
                        window.removeEventListener("online", _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);
                        window.removeEventListener("offline", _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);
                    }
                }
                hideInfo() {
                    const {info} = this.getState();
                    this.setState({
                        info: info.slice(1)
                    });
                    this.emit("info-hidden");
                }
                info(message, type, duration) {
                    if (void 0 === type) type = "info";
                    if (void 0 === duration) duration = 3e3;
                    const isComplexMessage = "object" === typeof message;
                    this.setState({
                        info: [ ...this.getState().info, {
                            type,
                            message: isComplexMessage ? message.message : message,
                            details: isComplexMessage ? message.details : null
                        } ]
                    });
                    setTimeout((() => this.hideInfo()), duration);
                    this.emit("info-visible");
                }
                log(message, type) {
                    const {logger} = this.opts;
                    switch (type) {
                      case "error":
                        logger.error(message);
                        break;

                      case "warning":
                        logger.warn(message);
                        break;

                      default:
                        logger.debug(message);
                        break;
                    }
                }
                restore(uploadID) {
                    this.log(`Core: attempting to restore upload "${uploadID}"`);
                    if (!this.getState().currentUploads[uploadID]) {
                        _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);
                        return Promise.reject(new Error("Nonexistent upload"));
                    }
                    return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);
                }
                [_Symbol$for2]() {
                    return _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](...arguments);
                }
                addResultData(uploadID, data) {
                    if (!_classPrivateFieldLooseBase(this, _getUpload)[_getUpload](uploadID)) {
                        this.log(`Not setting result for an upload that has been removed: ${uploadID}`);
                        return;
                    }
                    const {currentUploads} = this.getState();
                    const currentUpload = {
                        ...currentUploads[uploadID],
                        result: {
                            ...currentUploads[uploadID].result,
                            ...data
                        }
                    };
                    this.setState({
                        currentUploads: {
                            ...currentUploads,
                            [uploadID]: currentUpload
                        }
                    });
                }
                upload() {
                    var _classPrivateFieldLoo;
                    if (!(null != (_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _plugins)[_plugins].uploader) && _classPrivateFieldLoo.length)) this.log("No uploader type plugins are used", "warning");
                    let {files} = this.getState();
                    const onBeforeUploadResult = this.opts.onBeforeUpload(files);
                    if (false === onBeforeUploadResult) return Promise.reject(new Error("Not starting the upload because onBeforeUpload returned false"));
                    if (onBeforeUploadResult && "object" === typeof onBeforeUploadResult) {
                        files = onBeforeUploadResult;
                        this.setState({
                            files
                        });
                    }
                    return Promise.resolve().then((() => _classPrivateFieldLooseBase(this, _restricter)[_restricter].validateMinNumberOfFiles(files))).catch((err => {
                        _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](err);
                        throw err;
                    })).then((() => {
                        if (!_classPrivateFieldLooseBase(this, _checkRequiredMetaFields)[_checkRequiredMetaFields](files)) throw new RestrictionError(this.i18n("missingRequiredMetaField"));
                    })).catch((err => {
                        throw err;
                    })).then((() => {
                        const {currentUploads} = this.getState();
                        const currentlyUploadingFiles = Object.values(currentUploads).flatMap((curr => curr.fileIDs));
                        const waitingFileIDs = [];
                        Object.keys(files).forEach((fileID => {
                            const file = this.getFile(fileID);
                            if (!file.progress.uploadStarted && -1 === currentlyUploadingFiles.indexOf(fileID)) waitingFileIDs.push(file.id);
                        }));
                        const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](waitingFileIDs);
                        return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);
                    })).catch((err => {
                        this.emit("error", err);
                        this.log(err, "error");
                        throw err;
                    }));
                }
            }
            function _informAndEmit2(error, file) {
                const {message, details = ""} = error;
                if (error.isRestriction) this.emit("restriction-failed", file, error); else this.emit("error", error);
                this.info({
                    message,
                    details
                }, "error", this.opts.infoTimeout);
                this.log(`${message} ${details}`.trim(), "error");
            }
            function _checkRequiredMetaFieldsOnFile2(file) {
                const {missingFields, error} = _classPrivateFieldLooseBase(this, _restricter)[_restricter].getMissingRequiredMetaFields(file);
                if (missingFields.length > 0) {
                    this.setFileState(file.id, {
                        missingRequiredMetaFields: missingFields
                    });
                    this.log(error.message);
                    this.emit("restriction-failed", file, error);
                    return false;
                }
                return true;
            }
            function _checkRequiredMetaFields2(files) {
                let success = true;
                for (const file of Object.values(files)) if (!_classPrivateFieldLooseBase(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file)) success = false;
                return success;
            }
            function _assertNewUploadAllowed2(file) {
                const {allowNewUpload} = this.getState();
                if (false === allowNewUpload) {
                    const error = new RestrictionError(this.i18n("noMoreFilesAllowed"));
                    _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](error, file);
                    throw error;
                }
            }
            function _checkAndCreateFileStateObject2(files, fileDescriptor) {
                const fileType = getFileType(fileDescriptor);
                const fileName = getFileName(fileType, fileDescriptor);
                const fileExtension = getFileNameAndExtension(fileName).extension;
                const isRemote = Boolean(fileDescriptor.isRemote);
                const fileID = generateFileID({
                    ...fileDescriptor,
                    type: fileType
                });
                if (this.checkIfFileAlreadyExists(fileID)) {
                    const error = new RestrictionError(this.i18n("noDuplicates", {
                        fileName
                    }));
                    _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](error, fileDescriptor);
                    throw error;
                }
                const meta = fileDescriptor.meta || {};
                meta.name = fileName;
                meta.type = fileType;
                const size = Number.isFinite(fileDescriptor.data.size) ? fileDescriptor.data.size : null;
                let newFile = {
                    source: fileDescriptor.source || "",
                    id: fileID,
                    name: fileName,
                    extension: fileExtension || "",
                    meta: {
                        ...this.getState().meta,
                        ...meta
                    },
                    type: fileType,
                    data: fileDescriptor.data,
                    progress: {
                        percentage: 0,
                        bytesUploaded: 0,
                        bytesTotal: size,
                        uploadComplete: false,
                        uploadStarted: null
                    },
                    size,
                    isRemote,
                    remote: fileDescriptor.remote || "",
                    preview: fileDescriptor.preview
                };
                const onBeforeFileAddedResult = this.opts.onBeforeFileAdded(newFile, files);
                if (false === onBeforeFileAddedResult) {
                    const error = new RestrictionError("Cannot add the file because onBeforeFileAdded returned false.");
                    this.emit("restriction-failed", fileDescriptor, error);
                    throw error;
                } else if ("object" === typeof onBeforeFileAddedResult && null !== onBeforeFileAddedResult) newFile = onBeforeFileAddedResult;
                try {
                    const filesArray = Object.keys(files).map((i => files[i]));
                    _classPrivateFieldLooseBase(this, _restricter)[_restricter].validate(newFile, filesArray);
                } catch (err) {
                    _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](err, newFile);
                    throw err;
                }
                return newFile;
            }
            function _startIfAutoProceed2() {
                if (this.opts.autoProceed && !this.scheduledAutoProceed) this.scheduledAutoProceed = setTimeout((() => {
                    this.scheduledAutoProceed = null;
                    this.upload().catch((err => {
                        if (!err.isRestriction) this.log(err.stack || err.message || err);
                    }));
                }), 4);
            }
            function _addListeners2() {
                const errorHandler = (error, file, response) => {
                    let errorMsg = error.message || "Unknown error";
                    if (error.details) errorMsg += ` ${error.details}`;
                    this.setState({
                        error: errorMsg
                    });
                    if (null != file && file.id in this.getState().files) this.setFileState(file.id, {
                        error: errorMsg,
                        response
                    });
                };
                this.on("error", errorHandler);
                this.on("upload-error", ((file, error, response) => {
                    errorHandler(error, file, response);
                    if ("object" === typeof error && error.message) {
                        const newError = new Error(error.message);
                        newError.details = error.message;
                        if (error.details) newError.details += ` ${error.details}`;
                        newError.message = this.i18n("failedToUpload", {
                            file: file.name
                        });
                        _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](newError);
                    } else _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](error);
                }));
                this.on("upload", (() => {
                    this.setState({
                        error: null
                    });
                }));
                this.on("upload-started", (file => {
                    if (null == file || !this.getFile(file.id)) {
                        this.log(`Not setting progress for a file that has been removed: ${file.id}`);
                        return;
                    }
                    this.setFileState(file.id, {
                        progress: {
                            uploadStarted: Date.now(),
                            uploadComplete: false,
                            percentage: 0,
                            bytesUploaded: 0,
                            bytesTotal: file.size
                        }
                    });
                }));
                this.on("upload-progress", this.calculateProgress);
                this.on("upload-success", ((file, uploadResp) => {
                    if (null == file || !this.getFile(file.id)) {
                        this.log(`Not setting progress for a file that has been removed: ${file.id}`);
                        return;
                    }
                    const currentProgress = this.getFile(file.id).progress;
                    this.setFileState(file.id, {
                        progress: {
                            ...currentProgress,
                            postprocess: _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].size > 0 ? {
                                mode: "indeterminate"
                            } : null,
                            uploadComplete: true,
                            percentage: 100,
                            bytesUploaded: currentProgress.bytesTotal
                        },
                        response: uploadResp,
                        uploadURL: uploadResp.uploadURL,
                        isPaused: false
                    });
                    if (null == file.size) this.setFileState(file.id, {
                        size: uploadResp.bytesUploaded || currentProgress.bytesTotal
                    });
                    this.calculateTotalProgress();
                }));
                this.on("preprocess-progress", ((file, progress) => {
                    if (null == file || !this.getFile(file.id)) {
                        this.log(`Not setting progress for a file that has been removed: ${file.id}`);
                        return;
                    }
                    this.setFileState(file.id, {
                        progress: {
                            ...this.getFile(file.id).progress,
                            preprocess: progress
                        }
                    });
                }));
                this.on("preprocess-complete", (file => {
                    if (null == file || !this.getFile(file.id)) {
                        this.log(`Not setting progress for a file that has been removed: ${file.id}`);
                        return;
                    }
                    const files = {
                        ...this.getState().files
                    };
                    files[file.id] = {
                        ...files[file.id],
                        progress: {
                            ...files[file.id].progress
                        }
                    };
                    delete files[file.id].progress.preprocess;
                    this.setState({
                        files
                    });
                }));
                this.on("postprocess-progress", ((file, progress) => {
                    if (null == file || !this.getFile(file.id)) {
                        this.log(`Not setting progress for a file that has been removed: ${file.id}`);
                        return;
                    }
                    this.setFileState(file.id, {
                        progress: {
                            ...this.getState().files[file.id].progress,
                            postprocess: progress
                        }
                    });
                }));
                this.on("postprocess-complete", (file => {
                    if (null == file || !this.getFile(file.id)) {
                        this.log(`Not setting progress for a file that has been removed: ${file.id}`);
                        return;
                    }
                    const files = {
                        ...this.getState().files
                    };
                    files[file.id] = {
                        ...files[file.id],
                        progress: {
                            ...files[file.id].progress
                        }
                    };
                    delete files[file.id].progress.postprocess;
                    this.setState({
                        files
                    });
                }));
                this.on("restored", (() => {
                    this.calculateTotalProgress();
                }));
                this.on("dashboard:file-edit-complete", (file => {
                    if (file) _classPrivateFieldLooseBase(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file);
                }));
                if ("undefined" !== typeof window && window.addEventListener) {
                    window.addEventListener("online", _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);
                    window.addEventListener("offline", _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);
                    setTimeout(_classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus], 3e3);
                }
            }
            function _createUpload2(fileIDs, opts) {
                if (void 0 === opts) opts = {};
                const {forceAllowNewUpload = false} = opts;
                const {allowNewUpload, currentUploads} = this.getState();
                if (!allowNewUpload && !forceAllowNewUpload) throw new Error("Cannot create a new upload: already uploading.");
                const uploadID = nanoid();
                this.emit("upload", {
                    id: uploadID,
                    fileIDs
                });
                this.setState({
                    allowNewUpload: false !== this.opts.allowMultipleUploadBatches && false !== this.opts.allowMultipleUploads,
                    currentUploads: {
                        ...currentUploads,
                        [uploadID]: {
                            fileIDs,
                            step: 0,
                            result: {}
                        }
                    }
                });
                return uploadID;
            }
            function _getUpload2(uploadID) {
                const {currentUploads} = this.getState();
                return currentUploads[uploadID];
            }
            function _removeUpload2(uploadID) {
                const currentUploads = {
                    ...this.getState().currentUploads
                };
                delete currentUploads[uploadID];
                this.setState({
                    currentUploads
                });
            }
            async function _runUpload2(uploadID) {
                let {currentUploads} = this.getState();
                let currentUpload = currentUploads[uploadID];
                const restoreStep = currentUpload.step || 0;
                const steps = [ ..._classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors], ..._classPrivateFieldLooseBase(this, _uploaders)[_uploaders], ..._classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors] ];
                try {
                    for (let step = restoreStep; step < steps.length; step++) {
                        if (!currentUpload) break;
                        const fn = steps[step];
                        const updatedUpload = {
                            ...currentUpload,
                            step
                        };
                        this.setState({
                            currentUploads: {
                                ...currentUploads,
                                [uploadID]: updatedUpload
                            }
                        });
                        await fn(updatedUpload.fileIDs, uploadID);
                        currentUploads = this.getState().currentUploads;
                        currentUpload = currentUploads[uploadID];
                    }
                } catch (err) {
                    _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);
                    throw err;
                }
                if (currentUpload) {
                    currentUpload.fileIDs.forEach((fileID => {
                        const file = this.getFile(fileID);
                        if (file && file.progress.postprocess) this.emit("postprocess-complete", file);
                    }));
                    const files = currentUpload.fileIDs.map((fileID => this.getFile(fileID)));
                    const successful = files.filter((file => !file.error));
                    const failed = files.filter((file => file.error));
                    await this.addResultData(uploadID, {
                        successful,
                        failed,
                        uploadID
                    });
                    currentUploads = this.getState().currentUploads;
                    currentUpload = currentUploads[uploadID];
                }
                let result;
                if (currentUpload) {
                    result = currentUpload.result;
                    this.emit("complete", result);
                    _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);
                }
                if (null == result) this.log(`Not setting result for an upload that has been removed: ${uploadID}`);
                return result;
            }
            Uppy.VERSION = "2.1.8";
            module.exports = Uppy;
        },
        2008: module => {
            module.exports = function getFileName(fileType, fileDescriptor) {
                if (fileDescriptor.name) return fileDescriptor.name;
                if ("image" === fileType.split("/")[0]) return `${fileType.split("/")[0]}.${fileType.split("/")[1]}`;
                return "noname";
            };
        },
        9429: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const Uppy = __webpack_require__(1790);
            const UIPlugin = __webpack_require__(4649);
            const BasePlugin = __webpack_require__(8937);
            const {debugLogger} = __webpack_require__(4519);
            module.exports = Uppy;
            module.exports.Uppy = Uppy;
            module.exports.UIPlugin = UIPlugin;
            module.exports.BasePlugin = BasePlugin;
            module.exports.debugLogger = debugLogger;
        },
        8998: module => {
            module.exports = {
                strings: {
                    addBulkFilesFailed: {
                        0: "Failed to add %{smart_count} file due to an internal error",
                        1: "Failed to add %{smart_count} files due to internal errors"
                    },
                    youCanOnlyUploadX: {
                        0: "You can only upload %{smart_count} file",
                        1: "You can only upload %{smart_count} files"
                    },
                    youHaveToAtLeastSelectX: {
                        0: "You have to select at least %{smart_count} file",
                        1: "You have to select at least %{smart_count} files"
                    },
                    exceedsSize: "%{file} exceeds maximum allowed size of %{size}",
                    missingRequiredMetaField: "Missing required meta fields",
                    missingRequiredMetaFieldOnFile: "Missing required meta fields in %{fileName}",
                    inferiorSize: "This file is smaller than the allowed size of %{size}",
                    youCanOnlyUploadFileTypes: "You can only upload: %{types}",
                    noMoreFilesAllowed: "Cannot add more files",
                    noDuplicates: "Cannot add the duplicate file '%{fileName}', it already exists",
                    companionError: "Connection with Companion failed",
                    authAborted: "Authentication aborted",
                    companionUnauthorizeHint: "To unauthorize to your %{provider} account, please go to %{url}",
                    failedToUpload: "Failed to upload %{file}",
                    noInternetConnection: "No Internet connection",
                    connectedToInternet: "Connected to the Internet",
                    noFilesFound: "You have no files or folders here",
                    selectX: {
                        0: "Select %{smart_count}",
                        1: "Select %{smart_count}"
                    },
                    allFilesFromFolderNamed: "All files from folder %{name}",
                    openFolderNamed: "Open folder %{name}",
                    cancel: "Cancel",
                    logOut: "Log out",
                    filter: "Filter",
                    resetFilter: "Reset filter",
                    loading: "Loading...",
                    authenticateWithTitle: "Please authenticate with %{pluginName} to select files",
                    authenticateWith: "Connect to %{pluginName}",
                    signInWithGoogle: "Sign in with Google",
                    searchImages: "Search for images",
                    enterTextToSearch: "Enter text to search for images",
                    search: "Search",
                    emptyFolderAdded: "No files were added from empty folder",
                    folderAlreadyAdded: 'The folder "%{folder}" was already added',
                    folderAdded: {
                        0: "Added %{smart_count} file from %{folder}",
                        1: "Added %{smart_count} files from %{folder}"
                    }
                }
            };
        },
        4519: (module, __unused_webpack_exports, __webpack_require__) => {
            const getTimeStamp = __webpack_require__(6770);
            const justErrorsLogger = {
                debug: () => {},
                warn: () => {},
                error: function() {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return console.error(`[Uppy] [${getTimeStamp()}]`, ...args);
                }
            };
            const debugLogger = {
                debug: function() {
                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                    return console.debug(`[Uppy] [${getTimeStamp()}]`, ...args);
                },
                warn: function() {
                    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
                    return console.warn(`[Uppy] [${getTimeStamp()}]`, ...args);
                },
                error: function() {
                    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
                    return console.error(`[Uppy] [${getTimeStamp()}]`, ...args);
                }
            };
            module.exports = {
                justErrorsLogger,
                debugLogger
            };
        },
        8585: module => {
            module.exports = function supportsUploadProgress(userAgent) {
                if (null == userAgent) userAgent = "undefined" !== typeof navigator ? navigator.userAgent : null;
                if (!userAgent) return true;
                const m = /Edge\/(\d+\.\d+)/.exec(userAgent);
                if (!m) return true;
                const edgeVersion = m[1];
                let [major, minor] = edgeVersion.split(".");
                major = parseInt(major, 10);
                minor = parseInt(minor, 10);
                if (major < 15 || 15 === major && minor < 15063) return true;
                if (major > 18 || 18 === major && minor >= 18218) return true;
                return false;
            };
        },
        6052: (module, __unused_webpack_exports, __webpack_require__) => {
            let _Symbol$for;
            const {h, Component} = __webpack_require__(6400);
            _Symbol$for = Symbol.for("uppy test: disable unused locale key warning");
            class AddFiles extends Component {
                constructor() {
                    super(...arguments);
                    this.triggerFileInputClick = () => {
                        this.fileInput.click();
                    };
                    this.triggerFolderInputClick = () => {
                        this.folderInput.click();
                    };
                    this.onFileInputChange = event => {
                        this.props.handleInputChange(event);
                        event.target.value = null;
                    };
                    this.renderHiddenInput = (isFolder, refCallback) => h("input", {
                        className: "uppy-Dashboard-input",
                        hidden: true,
                        "aria-hidden": "true",
                        tabIndex: -1,
                        webkitdirectory: isFolder,
                        type: "file",
                        name: "files[]",
                        multiple: 1 !== this.props.maxNumberOfFiles,
                        onChange: this.onFileInputChange,
                        accept: this.props.allowedFileTypes,
                        ref: refCallback
                    });
                    this.renderMyDeviceAcquirer = () => h("div", {
                        className: "uppy-DashboardTab",
                        role: "presentation",
                        "data-uppy-acquirer-id": "MyDevice"
                    }, h("button", {
                        type: "button",
                        className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
                        role: "tab",
                        tabIndex: 0,
                        "data-uppy-super-focusable": true,
                        onClick: this.triggerFileInputClick
                    }, h("svg", {
                        "aria-hidden": "true",
                        focusable: "false",
                        width: "32",
                        height: "32",
                        viewBox: "0 0 32 32"
                    }, h("g", {
                        fill: "none",
                        fillRule: "evenodd"
                    }, h("rect", {
                        className: "uppy-ProviderIconBg",
                        width: "32",
                        height: "32",
                        rx: "16",
                        fill: "#2275D7"
                    }), h("path", {
                        d: "M21.973 21.152H9.863l-1.108-5.087h14.464l-1.246 5.087zM9.935 11.37h3.958l.886 1.444a.673.673 0 0 0 .585.316h6.506v1.37H9.935v-3.13zm14.898 3.44a.793.793 0 0 0-.616-.31h-.978v-2.126c0-.379-.275-.613-.653-.613H15.75l-.886-1.445a.673.673 0 0 0-.585-.316H9.232c-.378 0-.667.209-.667.587V14.5h-.782a.793.793 0 0 0-.61.303.795.795 0 0 0-.155.663l1.45 6.633c.078.36.396.618.764.618h13.354c.36 0 .674-.246.76-.595l1.631-6.636a.795.795 0 0 0-.144-.675z",
                        fill: "#FFF"
                    }))), h("div", {
                        className: "uppy-DashboardTab-name"
                    }, this.props.i18n("myDevice"))));
                    this.renderBrowseButton = (text, onClickFn) => {
                        const numberOfAcquirers = this.props.acquirers.length;
                        return h("button", {
                            type: "button",
                            className: "uppy-u-reset uppy-Dashboard-browse",
                            onClick: onClickFn,
                            "data-uppy-super-focusable": 0 === numberOfAcquirers
                        }, text);
                    };
                    this.renderDropPasteBrowseTagline = () => {
                        const numberOfAcquirers = this.props.acquirers.length;
                        const browseFiles = this.renderBrowseButton(this.props.i18n("browseFiles"), this.triggerFileInputClick);
                        const browseFolders = this.renderBrowseButton(this.props.i18n("browseFolders"), this.triggerFolderInputClick);
                        const lowerFMSelectionType = this.props.fileManagerSelectionType;
                        const camelFMSelectionType = lowerFMSelectionType.charAt(0).toUpperCase() + lowerFMSelectionType.slice(1);
                        return h("div", {
                            class: "uppy-Dashboard-AddFiles-title"
                        }, this.props.disableLocalFiles ? this.props.i18n("importFiles") : numberOfAcquirers > 0 ? this.props.i18nArray(`dropPasteImport${camelFMSelectionType}`, {
                            browseFiles,
                            browseFolders,
                            browse: browseFiles
                        }) : this.props.i18nArray(`dropPaste${camelFMSelectionType}`, {
                            browseFiles,
                            browseFolders,
                            browse: browseFiles
                        }));
                    };
                    this.renderAcquirer = acquirer => h("div", {
                        className: "uppy-DashboardTab",
                        role: "presentation",
                        "data-uppy-acquirer-id": acquirer.id
                    }, h("button", {
                        type: "button",
                        className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
                        role: "tab",
                        tabIndex: 0,
                        "data-cy": acquirer.id,
                        "aria-controls": `uppy-DashboardContent-panel--${acquirer.id}`,
                        "aria-selected": this.props.activePickerPanel.id === acquirer.id,
                        "data-uppy-super-focusable": true,
                        onClick: () => this.props.showPanel(acquirer.id)
                    }, acquirer.icon(), h("div", {
                        className: "uppy-DashboardTab-name"
                    }, acquirer.name)));
                    this.renderAcquirers = (acquirers, disableLocalFiles) => {
                        const acquirersWithoutLastTwo = [ ...acquirers ];
                        const lastTwoAcquirers = acquirersWithoutLastTwo.splice(acquirers.length - 2, acquirers.length);
                        return h("div", {
                            className: "uppy-Dashboard-AddFiles-list",
                            role: "tablist"
                        }, !disableLocalFiles && this.renderMyDeviceAcquirer(), acquirersWithoutLastTwo.map((acquirer => this.renderAcquirer(acquirer))), h("span", {
                            role: "presentation",
                            style: {
                                "white-space": "nowrap"
                            }
                        }, lastTwoAcquirers.map((acquirer => this.renderAcquirer(acquirer)))));
                    };
                }
                [_Symbol$for]() {
                    this.props.i18nArray("dropPasteBoth");
                    this.props.i18nArray("dropPasteFiles");
                    this.props.i18nArray("dropPasteFolders");
                    this.props.i18nArray("dropPasteImportBoth");
                    this.props.i18nArray("dropPasteImportFiles");
                    this.props.i18nArray("dropPasteImportFolders");
                }
                renderPoweredByUppy() {
                    const {i18nArray} = this.props;
                    const uppyBranding = h("span", null, h("svg", {
                        "aria-hidden": "true",
                        focusable: "false",
                        className: "uppy-c-icon uppy-Dashboard-poweredByIcon",
                        width: "11",
                        height: "11",
                        viewBox: "0 0 11 11"
                    }, h("path", {
                        d: "M7.365 10.5l-.01-4.045h2.612L5.5.806l-4.467 5.65h2.604l.01 4.044h3.718z",
                        fillRule: "evenodd"
                    })), h("span", {
                        className: "uppy-Dashboard-poweredByUppy"
                    }, "Uppy"));
                    const linkText = i18nArray("poweredBy", {
                        uppy: uppyBranding
                    });
                    return h("a", {
                        tabIndex: "-1",
                        href: "https://uppy.io",
                        rel: "noreferrer noopener",
                        target: "_blank",
                        className: "uppy-Dashboard-poweredBy"
                    }, linkText);
                }
                render() {
                    return h("div", {
                        className: "uppy-Dashboard-AddFiles"
                    }, this.renderHiddenInput(false, (ref => {
                        this.fileInput = ref;
                    })), this.renderHiddenInput(true, (ref => {
                        this.folderInput = ref;
                    })), this.renderDropPasteBrowseTagline(), this.props.acquirers.length > 0 && this.renderAcquirers(this.props.acquirers, this.props.disableLocalFiles), h("div", {
                        className: "uppy-Dashboard-AddFiles-info"
                    }, this.props.note && h("div", {
                        className: "uppy-Dashboard-note"
                    }, this.props.note), this.props.proudlyDisplayPoweredByUppy && this.renderPoweredByUppy(this.props)));
                }
            }
            module.exports = AddFiles;
        },
        5808: (module, __unused_webpack_exports, __webpack_require__) => {
            const {h} = __webpack_require__(6400);
            const classNames = __webpack_require__(4184);
            const AddFiles = __webpack_require__(6052);
            const AddFilesPanel = props => h("div", {
                className: classNames("uppy-Dashboard-AddFilesPanel", props.className),
                "data-uppy-panelType": "AddFiles",
                "aria-hidden": props.showAddFilesPanel
            }, h("div", {
                className: "uppy-DashboardContent-bar"
            }, h("div", {
                className: "uppy-DashboardContent-title",
                role: "heading",
                "aria-level": "1"
            }, props.i18n("addingMoreFiles")), h("button", {
                className: "uppy-DashboardContent-back",
                type: "button",
                onClick: () => props.toggleAddFilesPanel(false)
            }, props.i18n("back"))), h(AddFiles, props));
            module.exports = AddFilesPanel;
        },
        5519: (module, __unused_webpack_exports, __webpack_require__) => {
            function _extends() {
                _extends = Object.assign || function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i];
                        for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
                    }
                    return target;
                };
                return _extends.apply(this, arguments);
            }
            const {h} = __webpack_require__(6400);
            const classNames = __webpack_require__(4184);
            const isDragDropSupported = __webpack_require__(3754);
            const FileList = __webpack_require__(8689);
            const AddFiles = __webpack_require__(6052);
            const AddFilesPanel = __webpack_require__(5808);
            const PickerPanelContent = __webpack_require__(5859);
            const EditorPanel = __webpack_require__(4477);
            const PanelTopBar = __webpack_require__(7246);
            const FileCard = __webpack_require__(5261);
            const Slide = __webpack_require__(9167);
            const WIDTH_XL = 900;
            const WIDTH_LG = 700;
            const WIDTH_MD = 576;
            const HEIGHT_MD = 400;
            module.exports = function Dashboard(props) {
                const noFiles = 0 === props.totalFileCount;
                const isSizeMD = props.containerWidth > WIDTH_MD;
                const wrapperClassName = classNames({
                    "uppy-Root": props.isTargetDOMEl
                });
                const dashboardClassName = classNames({
                    "uppy-Dashboard": true,
                    "uppy-Dashboard--isDisabled": props.disabled,
                    "uppy-Dashboard--animateOpenClose": props.animateOpenClose,
                    "uppy-Dashboard--isClosing": props.isClosing,
                    "uppy-Dashboard--isDraggingOver": props.isDraggingOver,
                    "uppy-Dashboard--modal": !props.inline,
                    "uppy-size--md": props.containerWidth > WIDTH_MD,
                    "uppy-size--lg": props.containerWidth > WIDTH_LG,
                    "uppy-size--xl": props.containerWidth > WIDTH_XL,
                    "uppy-size--height-md": props.containerHeight > HEIGHT_MD,
                    "uppy-Dashboard--isAddFilesPanelVisible": props.showAddFilesPanel,
                    "uppy-Dashboard--isInnerWrapVisible": props.areInsidesReadyToBeVisible
                });
                let itemsPerRow = 1;
                if (props.containerWidth > WIDTH_XL) itemsPerRow = 5; else if (props.containerWidth > WIDTH_LG) itemsPerRow = 4; else if (props.containerWidth > WIDTH_MD) itemsPerRow = 3;
                const showFileList = props.showSelectedFiles && !noFiles;
                const numberOfFilesForRecovery = props.recoveredState ? Object.keys(props.recoveredState.files).length : null;
                const numberOfGhosts = props.files ? Object.keys(props.files).filter((fileID => props.files[fileID].isGhost)).length : null;
                const renderRestoredText = () => {
                    if (numberOfGhosts > 0) return props.i18n("recoveredXFiles", {
                        smart_count: numberOfGhosts
                    });
                    return props.i18n("recoveredAllFiles");
                };
                const dashboard = h("div", {
                    className: dashboardClassName,
                    "data-uppy-theme": props.theme,
                    "data-uppy-num-acquirers": props.acquirers.length,
                    "data-uppy-drag-drop-supported": !props.disableLocalFiles && isDragDropSupported(),
                    "aria-hidden": props.inline ? "false" : props.isHidden,
                    "aria-disabled": props.disabled,
                    "aria-label": !props.inline ? props.i18n("dashboardWindowTitle") : props.i18n("dashboardTitle"),
                    onPaste: props.handlePaste,
                    onDragOver: props.handleDragOver,
                    onDragLeave: props.handleDragLeave,
                    onDrop: props.handleDrop
                }, h("div", {
                    "aria-hidden": "true",
                    className: "uppy-Dashboard-overlay",
                    tabIndex: -1,
                    onClick: props.handleClickOutside
                }), h("div", {
                    className: "uppy-Dashboard-inner",
                    "aria-modal": !props.inline && "true",
                    role: !props.inline && "dialog",
                    style: {
                        width: props.inline && props.width ? props.width : "",
                        height: props.inline && props.height ? props.height : ""
                    }
                }, !props.inline ? h("button", {
                    className: "uppy-u-reset uppy-Dashboard-close",
                    type: "button",
                    "aria-label": props.i18n("closeModal"),
                    title: props.i18n("closeModal"),
                    onClick: props.closeModal
                }, h("span", {
                    "aria-hidden": "true"
                }, "×")) : null, h("div", {
                    className: "uppy-Dashboard-innerWrap"
                }, h("div", {
                    className: "uppy-Dashboard-dropFilesHereHint"
                }, props.i18n("dropHint")), showFileList && h(PanelTopBar, props), numberOfFilesForRecovery && h("div", {
                    className: "uppy-Dashboard-serviceMsg"
                }, h("svg", {
                    className: "uppy-Dashboard-serviceMsg-icon",
                    "aria-hidden": "true",
                    focusable: "false",
                    width: "21",
                    height: "16",
                    viewBox: "0 0 24 19"
                }, h("g", {
                    transform: "translate(0 -1)",
                    fill: "none",
                    fillRule: "evenodd"
                }, h("path", {
                    d: "M12.857 1.43l10.234 17.056A1 1 0 0122.234 20H1.766a1 1 0 01-.857-1.514L11.143 1.429a1 1 0 011.714 0z",
                    fill: "#FFD300"
                }), h("path", {
                    fill: "#000",
                    d: "M11 6h2l-.3 8h-1.4z"
                }), h("circle", {
                    fill: "#000",
                    cx: "12",
                    cy: "17",
                    r: "1"
                }))), h("strong", {
                    className: "uppy-Dashboard-serviceMsg-title"
                }, props.i18n("sessionRestored")), h("div", {
                    className: "uppy-Dashboard-serviceMsg-text"
                }, renderRestoredText())), showFileList ? h(FileList, _extends({}, props, {
                    itemsPerRow
                })) : h(AddFiles, _extends({}, props, {
                    isSizeMD
                })), h(Slide, null, props.showAddFilesPanel ? h(AddFilesPanel, _extends({
                    key: "AddFiles"
                }, props, {
                    isSizeMD
                })) : null), h(Slide, null, props.fileCardFor ? h(FileCard, _extends({
                    key: "FileCard"
                }, props)) : null), h(Slide, null, props.activePickerPanel ? h(PickerPanelContent, _extends({
                    key: "Picker"
                }, props)) : null), h(Slide, null, props.showFileEditor ? h(EditorPanel, _extends({
                    key: "Editor"
                }, props)) : null), h("div", {
                    className: "uppy-Dashboard-progressindicators"
                }, props.progressindicators.map((target => props.uppy.getPlugin(target.id).render(props.state)))))));
                return h("div", {
                    className: wrapperClassName,
                    dir: props.direction
                }, dashboard);
            };
        },
        4477: (module, __unused_webpack_exports, __webpack_require__) => {
            const {h} = __webpack_require__(6400);
            const classNames = __webpack_require__(4184);
            function EditorPanel(props) {
                const file = props.files[props.fileCardFor];
                return h("div", {
                    className: classNames("uppy-DashboardContent-panel", props.className),
                    role: "tabpanel",
                    "data-uppy-panelType": "FileEditor",
                    id: "uppy-DashboardContent-panel--editor"
                }, h("div", {
                    className: "uppy-DashboardContent-bar"
                }, h("div", {
                    className: "uppy-DashboardContent-title",
                    role: "heading",
                    "aria-level": "1"
                }, props.i18nArray("editing", {
                    file: h("span", {
                        className: "uppy-DashboardContent-titleFile"
                    }, file.meta ? file.meta.name : file.name)
                })), h("button", {
                    className: "uppy-DashboardContent-back",
                    type: "button",
                    onClick: props.hideAllPanels
                }, props.i18n("cancel")), h("button", {
                    className: "uppy-DashboardContent-save",
                    type: "button",
                    onClick: props.saveFileEditor
                }, props.i18n("save"))), h("div", {
                    className: "uppy-DashboardContent-panelBody"
                }, props.editors.map((target => props.uppy.getPlugin(target.id).render(props.state)))));
            }
            module.exports = EditorPanel;
        },
        5261: (module, __unused_webpack_exports, __webpack_require__) => {
            const {h, Component} = __webpack_require__(6400);
            const classNames = __webpack_require__(4184);
            const {nanoid} = __webpack_require__(2961);
            const getFileTypeIcon = __webpack_require__(1882);
            const ignoreEvent = __webpack_require__(8805);
            const FilePreview = __webpack_require__(9282);
            class FileCard extends Component {
                constructor(props) {
                    super(props);
                    this.form = document.createElement("form");
                    this.updateMeta = (newVal, name) => {
                        this.setState((_ref => {
                            let {formState} = _ref;
                            return {
                                formState: {
                                    ...formState,
                                    [name]: newVal
                                }
                            };
                        }));
                    };
                    this.handleSave = e => {
                        e.preventDefault();
                        const fileID = this.props.fileCardFor;
                        this.props.saveFileCard(this.state.formState, fileID);
                    };
                    this.handleCancel = () => {
                        this.props.toggleFileCard(false);
                    };
                    this.saveOnEnter = ev => {
                        if (13 === ev.keyCode) {
                            ev.stopPropagation();
                            ev.preventDefault();
                            const file = this.props.files[this.props.fileCardFor];
                            this.props.saveFileCard(this.state.formState, file.id);
                        }
                    };
                    this.renderMetaFields = () => {
                        const metaFields = this.getMetaFields() || [];
                        const fieldCSSClasses = {
                            text: "uppy-u-reset uppy-c-textInput uppy-Dashboard-FileCard-input"
                        };
                        return metaFields.map((field => {
                            const id = `uppy-Dashboard-FileCard-input-${field.id}`;
                            const required = this.props.requiredMetaFields.includes(field.id);
                            return h("fieldset", {
                                key: field.id,
                                className: "uppy-Dashboard-FileCard-fieldset"
                            }, h("label", {
                                className: "uppy-Dashboard-FileCard-label",
                                htmlFor: id
                            }, field.name), void 0 !== field.render ? field.render({
                                value: this.state.formState[field.id],
                                onChange: newVal => this.updateMeta(newVal, field.id),
                                fieldCSSClasses,
                                required,
                                form: this.form.id
                            }, h) : h("input", {
                                className: fieldCSSClasses.text,
                                id,
                                form: this.form.id,
                                type: field.type || "text",
                                required,
                                value: this.state.formState[field.id],
                                placeholder: field.placeholder,
                                onKeyUp: "form" in HTMLInputElement.prototype ? void 0 : this.saveOnEnter,
                                onKeyDown: "form" in HTMLInputElement.prototype ? void 0 : this.saveOnEnter,
                                onKeyPress: "form" in HTMLInputElement.prototype ? void 0 : this.saveOnEnter,
                                onInput: ev => this.updateMeta(ev.target.value, field.id),
                                "data-uppy-super-focusable": true
                            }));
                        }));
                    };
                    const _file = this.props.files[this.props.fileCardFor];
                    const _metaFields = this.getMetaFields() || [];
                    const storedMetaData = {};
                    _metaFields.forEach((field => {
                        storedMetaData[field.id] = _file.meta[field.id] || "";
                    }));
                    this.state = {
                        formState: storedMetaData
                    };
                    this.form.id = nanoid();
                }
                componentWillMount() {
                    this.form.addEventListener("submit", this.handleSave);
                    document.body.appendChild(this.form);
                }
                componentWillUnmount() {
                    this.form.removeEventListener("submit", this.handleSave);
                    document.body.removeChild(this.form);
                }
                getMetaFields() {
                    return "function" === typeof this.props.metaFields ? this.props.metaFields(this.props.files[this.props.fileCardFor]) : this.props.metaFields;
                }
                render() {
                    const file = this.props.files[this.props.fileCardFor];
                    const showEditButton = this.props.canEditFile(file);
                    return h("div", {
                        className: classNames("uppy-Dashboard-FileCard", this.props.className),
                        "data-uppy-panelType": "FileCard",
                        onDragOver: ignoreEvent,
                        onDragLeave: ignoreEvent,
                        onDrop: ignoreEvent,
                        onPaste: ignoreEvent
                    }, h("div", {
                        className: "uppy-DashboardContent-bar"
                    }, h("div", {
                        className: "uppy-DashboardContent-title",
                        role: "heading",
                        "aria-level": "1"
                    }, this.props.i18nArray("editing", {
                        file: h("span", {
                            className: "uppy-DashboardContent-titleFile"
                        }, file.meta ? file.meta.name : file.name)
                    })), h("button", {
                        className: "uppy-DashboardContent-back",
                        type: "button",
                        form: this.form.id,
                        title: this.props.i18n("finishEditingFile"),
                        onClick: this.handleCancel
                    }, this.props.i18n("cancel"))), h("div", {
                        className: "uppy-Dashboard-FileCard-inner"
                    }, h("div", {
                        className: "uppy-Dashboard-FileCard-preview",
                        style: {
                            backgroundColor: getFileTypeIcon(file.type).color
                        }
                    }, h(FilePreview, {
                        file
                    }), showEditButton && h("button", {
                        type: "button",
                        className: "uppy-u-reset uppy-c-btn uppy-Dashboard-FileCard-edit",
                        onClick: event => {
                            this.handleSave(event);
                            this.props.openFileEditor(file);
                        },
                        form: this.form.id
                    }, this.props.i18n("editFile"))), h("div", {
                        className: "uppy-Dashboard-FileCard-info"
                    }, this.renderMetaFields()), h("div", {
                        className: "uppy-Dashboard-FileCard-actions"
                    }, h("button", {
                        className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Dashboard-FileCard-actionsBtn",
                        type: "form" in HTMLButtonElement.prototype ? "submit" : "button",
                        onClick: "form" in HTMLButtonElement.prototype ? void 0 : this.handleSave,
                        form: this.form.id
                    }, this.props.i18n("saveChanges")), h("button", {
                        className: "uppy-u-reset uppy-c-btn uppy-c-btn-link uppy-Dashboard-FileCard-actionsBtn",
                        type: "button",
                        onClick: this.handleCancel,
                        form: this.form.id
                    }, this.props.i18n("cancel")))));
                }
            }
            module.exports = FileCard;
        },
        6757: (module, __unused_webpack_exports, __webpack_require__) => {
            const {h} = __webpack_require__(6400);
            const copyToClipboard = __webpack_require__(818);
            function EditButton(_ref) {
                let {file, uploadInProgressOrComplete, metaFields, canEditFile, i18n, onClick} = _ref;
                if (!uploadInProgressOrComplete && metaFields && metaFields.length > 0 || !uploadInProgressOrComplete && canEditFile(file)) return h("button", {
                    className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--edit",
                    type: "button",
                    "aria-label": i18n("editFileWithFilename", {
                        file: file.meta.name
                    }),
                    title: i18n("editFileWithFilename", {
                        file: file.meta.name
                    }),
                    onClick: () => onClick()
                }, h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    className: "uppy-c-icon",
                    width: "14",
                    height: "14",
                    viewBox: "0 0 14 14"
                }, h("g", {
                    fillRule: "evenodd"
                }, h("path", {
                    d: "M1.5 10.793h2.793A1 1 0 0 0 5 10.5L11.5 4a1 1 0 0 0 0-1.414L9.707.793a1 1 0 0 0-1.414 0l-6.5 6.5A1 1 0 0 0 1.5 8v2.793zm1-1V8L9 1.5l1.793 1.793-6.5 6.5H2.5z",
                    fillRule: "nonzero"
                }), h("rect", {
                    x: "1",
                    y: "12.293",
                    width: "11",
                    height: "1",
                    rx: ".5"
                }), h("path", {
                    fillRule: "nonzero",
                    d: "M6.793 2.5L9.5 5.207l.707-.707L7.5 1.793z"
                }))));
                return null;
            }
            function RemoveButton(_ref2) {
                let {i18n, onClick, file} = _ref2;
                return h("button", {
                    className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--remove",
                    type: "button",
                    "aria-label": i18n("removeFile", {
                        file: file.meta.name
                    }),
                    title: i18n("removeFile", {
                        file: file.meta.name
                    }),
                    onClick: () => onClick()
                }, h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    className: "uppy-c-icon",
                    width: "18",
                    height: "18",
                    viewBox: "0 0 18 18"
                }, h("path", {
                    d: "M9 0C4.034 0 0 4.034 0 9s4.034 9 9 9 9-4.034 9-9-4.034-9-9-9z"
                }), h("path", {
                    fill: "#FFF",
                    d: "M13 12.222l-.778.778L9 9.778 5.778 13 5 12.222 8.222 9 5 5.778 5.778 5 9 8.222 12.222 5l.778.778L9.778 9z"
                })));
            }
            const copyLinkToClipboard = (event, props) => {
                copyToClipboard(props.file.uploadURL, props.i18n("copyLinkToClipboardFallback")).then((() => {
                    props.uppy.log("Link copied to clipboard.");
                    props.uppy.info(props.i18n("copyLinkToClipboardSuccess"), "info", 3e3);
                })).catch(props.uppy.log).then((() => event.target.focus({
                    preventScroll: true
                })));
            };
            function CopyLinkButton(props) {
                const {i18n} = props;
                return h("button", {
                    className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--copyLink",
                    type: "button",
                    "aria-label": i18n("copyLink"),
                    title: i18n("copyLink"),
                    onClick: event => copyLinkToClipboard(event, props)
                }, h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    className: "uppy-c-icon",
                    width: "14",
                    height: "14",
                    viewBox: "0 0 14 12"
                }, h("path", {
                    d: "M7.94 7.703a2.613 2.613 0 0 1-.626 2.681l-.852.851a2.597 2.597 0 0 1-1.849.766A2.616 2.616 0 0 1 2.764 7.54l.852-.852a2.596 2.596 0 0 1 2.69-.625L5.267 7.099a1.44 1.44 0 0 0-.833.407l-.852.851a1.458 1.458 0 0 0 1.03 2.486c.39 0 .755-.152 1.03-.426l.852-.852c.231-.231.363-.522.406-.824l1.04-1.038zm4.295-5.937A2.596 2.596 0 0 0 10.387 1c-.698 0-1.355.272-1.849.766l-.852.851a2.614 2.614 0 0 0-.624 2.688l1.036-1.036c.041-.304.173-.6.407-.833l.852-.852c.275-.275.64-.426 1.03-.426a1.458 1.458 0 0 1 1.03 2.486l-.852.851a1.442 1.442 0 0 1-.824.406l-1.04 1.04a2.596 2.596 0 0 0 2.683-.628l.851-.85a2.616 2.616 0 0 0 0-3.697zm-6.88 6.883a.577.577 0 0 0 .82 0l3.474-3.474a.579.579 0 1 0-.819-.82L5.355 7.83a.579.579 0 0 0 0 .819z"
                })));
            }
            module.exports = function Buttons(props) {
                const {uppy, file, uploadInProgressOrComplete, canEditFile, metaFields, showLinkToFileUploadResult, showRemoveButton, i18n, toggleFileCard, openFileEditor} = props;
                const editAction = () => {
                    if (metaFields && metaFields.length > 0) toggleFileCard(true, file.id); else openFileEditor(file);
                };
                return h("div", {
                    className: "uppy-Dashboard-Item-actionWrapper"
                }, h(EditButton, {
                    i18n,
                    file,
                    uploadInProgressOrComplete,
                    canEditFile,
                    metaFields,
                    onClick: editAction
                }), showLinkToFileUploadResult && file.uploadURL ? h(CopyLinkButton, {
                    file,
                    uppy,
                    i18n
                }) : null, showRemoveButton ? h(RemoveButton, {
                    i18n,
                    file,
                    uppy,
                    onClick: () => props.uppy.removeFile(file.id, "removed-by-user")
                }) : null);
            };
        },
        3844: (module, __unused_webpack_exports, __webpack_require__) => {
            const {h, Fragment} = __webpack_require__(6400);
            const prettierBytes = __webpack_require__(5158);
            const truncateString = __webpack_require__(469);
            const MetaErrorMessage = __webpack_require__(8092);
            const renderFileName = props => {
                const {author, name} = props.file.meta;
                function getMaxNameLength() {
                    if (props.containerWidth <= 352) return 35;
                    if (props.containerWidth <= 576) return 60;
                    return author ? 20 : 30;
                }
                return h("div", {
                    className: "uppy-Dashboard-Item-name",
                    title: name
                }, truncateString(name, getMaxNameLength()));
            };
            const renderAuthor = props => {
                const {author} = props.file.meta;
                const {providerName} = props.file.remote;
                const dot = `·`;
                if (!author) return null;
                return h("div", {
                    className: "uppy-Dashboard-Item-author"
                }, h("a", {
                    href: `${author.url}?utm_source=Companion&utm_medium=referral`,
                    target: "_blank",
                    rel: "noopener noreferrer"
                }, truncateString(author.name, 13)), providerName ? h(Fragment, null, ` ${dot} `, providerName, ` ${dot} `) : null);
            };
            const renderFileSize = props => props.file.size && h("div", {
                className: "uppy-Dashboard-Item-statusSize"
            }, prettierBytes(props.file.size));
            const ReSelectButton = props => props.file.isGhost && h("span", null, " • ", h("button", {
                className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-reSelect",
                type: "button",
                onClick: props.toggleAddFilesPanel
            }, props.i18n("reSelect")));
            const ErrorButton = _ref => {
                let {file, onClick} = _ref;
                if (file.error) return h("button", {
                    className: "uppy-u-reset uppy-Dashboard-Item-errorDetails",
                    "aria-label": file.error,
                    "data-microtip-position": "bottom",
                    "data-microtip-size": "medium",
                    onClick,
                    type: "button"
                }, "?");
                return null;
            };
            module.exports = function FileInfo(props) {
                const {file} = props;
                return h("div", {
                    className: "uppy-Dashboard-Item-fileInfo",
                    "data-uppy-file-source": file.source
                }, h("div", {
                    className: "uppy-Dashboard-Item-fileName"
                }, renderFileName(props), h(ErrorButton, {
                    file: props.file,
                    onClick: () => alert(props.file.error)
                })), h("div", {
                    className: "uppy-Dashboard-Item-status"
                }, renderAuthor(props), renderFileSize(props), ReSelectButton(props)), h(MetaErrorMessage, {
                    file: props.file,
                    i18n: props.i18n,
                    toggleFileCard: props.toggleFileCard,
                    metaFields: props.metaFields
                }));
            };
        },
        6012: (module, __unused_webpack_exports, __webpack_require__) => {
            const {h} = __webpack_require__(6400);
            const FilePreview = __webpack_require__(9282);
            const MetaErrorMessage = __webpack_require__(8092);
            const getFileTypeIcon = __webpack_require__(1882);
            module.exports = function FilePreviewAndLink(props) {
                return h("div", {
                    className: "uppy-Dashboard-Item-previewInnerWrap",
                    style: {
                        backgroundColor: getFileTypeIcon(props.file.type).color
                    }
                }, props.showLinkToFileUploadResult && props.file.uploadURL && h("a", {
                    className: "uppy-Dashboard-Item-previewLink",
                    href: props.file.uploadURL,
                    rel: "noreferrer noopener",
                    target: "_blank",
                    "aria-label": props.file.meta.name
                }, h("span", {
                    hidden: true
                }, props.file.meta.name)), h(FilePreview, {
                    file: props.file
                }), h(MetaErrorMessage, {
                    file: props.file,
                    i18n: props.i18n,
                    toggleFileCard: props.toggleFileCard,
                    metaFields: props.metaFields
                }));
            };
        },
        1911: (module, __unused_webpack_exports, __webpack_require__) => {
            const {h} = __webpack_require__(6400);
            function onPauseResumeCancelRetry(props) {
                if (props.isUploaded) return;
                if (props.error && !props.hideRetryButton) {
                    props.uppy.retryUpload(props.file.id);
                    return;
                }
                if (props.resumableUploads && !props.hidePauseResumeButton) props.uppy.pauseResume(props.file.id); else if (props.individualCancellation && !props.hideCancelButton) props.uppy.removeFile(props.file.id);
            }
            function progressIndicatorTitle(props) {
                if (props.isUploaded) return props.i18n("uploadComplete");
                if (props.error) return props.i18n("retryUpload");
                if (props.resumableUploads) {
                    if (props.file.isPaused) return props.i18n("resumeUpload");
                    return props.i18n("pauseUpload");
                }
                if (props.individualCancellation) return props.i18n("cancelUpload");
                return "";
            }
            function ProgressIndicatorButton(props) {
                return h("div", {
                    className: "uppy-Dashboard-Item-progress"
                }, h("button", {
                    className: "uppy-u-reset uppy-Dashboard-Item-progressIndicator",
                    type: "button",
                    "aria-label": progressIndicatorTitle(props),
                    title: progressIndicatorTitle(props),
                    onClick: () => onPauseResumeCancelRetry(props)
                }, props.children));
            }
            function ProgressCircleContainer(_ref) {
                let {children} = _ref;
                return h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    width: "70",
                    height: "70",
                    viewBox: "0 0 36 36",
                    className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--circle"
                }, children);
            }
            function ProgressCircle(_ref2) {
                let {progress} = _ref2;
                const circleLength = 2 * Math.PI * 15;
                return h("g", null, h("circle", {
                    className: "uppy-Dashboard-Item-progressIcon--bg",
                    r: "15",
                    cx: "18",
                    cy: "18",
                    "stroke-width": "2",
                    fill: "none"
                }), h("circle", {
                    className: "uppy-Dashboard-Item-progressIcon--progress",
                    r: "15",
                    cx: "18",
                    cy: "18",
                    transform: "rotate(-90, 18, 18)",
                    fill: "none",
                    "stroke-width": "2",
                    "stroke-dasharray": circleLength,
                    "stroke-dashoffset": circleLength - circleLength / 100 * progress
                }));
            }
            module.exports = function FileProgress(props) {
                if (!props.file.progress.uploadStarted) return null;
                if (props.isUploaded) return h("div", {
                    className: "uppy-Dashboard-Item-progress"
                }, h("div", {
                    className: "uppy-Dashboard-Item-progressIndicator"
                }, h(ProgressCircleContainer, null, h("circle", {
                    r: "15",
                    cx: "18",
                    cy: "18",
                    fill: "#1bb240"
                }), h("polygon", {
                    className: "uppy-Dashboard-Item-progressIcon--check",
                    transform: "translate(2, 3)",
                    points: "14 22.5 7 15.2457065 8.99985857 13.1732815 14 18.3547104 22.9729883 9 25 11.1005634"
                }))));
                if (props.recoveredState) return;
                if (props.error && !props.hideRetryButton) return h(ProgressIndicatorButton, props, h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--retry",
                    width: "28",
                    height: "31",
                    viewBox: "0 0 16 19"
                }, h("path", {
                    d: "M16 11a8 8 0 1 1-8-8v2a6 6 0 1 0 6 6h2z"
                }), h("path", {
                    d: "M7.9 3H10v2H7.9z"
                }), h("path", {
                    d: "M8.536.5l3.535 3.536-1.414 1.414L7.12 1.914z"
                }), h("path", {
                    d: "M10.657 2.621l1.414 1.415L8.536 7.57 7.12 6.157z"
                })));
                if (props.resumableUploads && !props.hidePauseResumeButton) return h(ProgressIndicatorButton, props, h(ProgressCircleContainer, null, h(ProgressCircle, {
                    progress: props.file.progress.percentage
                }), props.file.isPaused ? h("polygon", {
                    className: "uppy-Dashboard-Item-progressIcon--play",
                    transform: "translate(3, 3)",
                    points: "12 20 12 10 20 15"
                }) : h("g", {
                    className: "uppy-Dashboard-Item-progressIcon--pause",
                    transform: "translate(14.5, 13)"
                }, h("rect", {
                    x: "0",
                    y: "0",
                    width: "2",
                    height: "10",
                    rx: "0"
                }), h("rect", {
                    x: "5",
                    y: "0",
                    width: "2",
                    height: "10",
                    rx: "0"
                }))));
                if (!props.resumableUploads && props.individualCancellation && !props.hideCancelButton) return h(ProgressIndicatorButton, props, h(ProgressCircleContainer, null, h(ProgressCircle, {
                    progress: props.file.progress.percentage
                }), h("polygon", {
                    className: "cancel",
                    transform: "translate(2, 2)",
                    points: "19.8856516 11.0625 16 14.9481516 12.1019737 11.0625 11.0625 12.1143484 14.9481516 16 11.0625 19.8980263 12.1019737 20.9375 16 17.0518484 19.8856516 20.9375 20.9375 19.8980263 17.0518484 16 20.9375 12"
                })));
                return h("div", {
                    className: "uppy-Dashboard-Item-progress"
                }, h("div", {
                    className: "uppy-Dashboard-Item-progressIndicator"
                }, h(ProgressCircleContainer, null, h(ProgressCircle, {
                    progress: props.file.progress.percentage
                }))));
            };
        },
        8092: (module, __unused_webpack_exports, __webpack_require__) => {
            const {h} = __webpack_require__(6400);
            const metaFieldIdToName = (metaFieldId, metaFields) => {
                const field = metaFields.filter((f => f.id === metaFieldId));
                return field[0].name;
            };
            module.exports = function renderMissingMetaFieldsError(props) {
                const {file, toggleFileCard, i18n, metaFields} = props;
                const {missingRequiredMetaFields} = file;
                if (!(null != missingRequiredMetaFields && missingRequiredMetaFields.length)) return null;
                const metaFieldsString = missingRequiredMetaFields.map((missingMetaField => metaFieldIdToName(missingMetaField, metaFields))).join(", ");
                return h("div", {
                    className: "uppy-Dashboard-Item-errorMessage"
                }, i18n("missingRequiredMetaFields", {
                    smart_count: missingRequiredMetaFields.length,
                    fields: metaFieldsString
                }), " ", h("button", {
                    type: "button",
                    class: "uppy-u-reset uppy-Dashboard-Item-errorMessageBtn",
                    onClick: () => toggleFileCard(true, file.id)
                }, i18n("editFile")));
            };
        },
        5845: (module, __unused_webpack_exports, __webpack_require__) => {
            const {h, Component} = __webpack_require__(6400);
            const classNames = __webpack_require__(4184);
            const shallowEqual = __webpack_require__(81);
            const FilePreviewAndLink = __webpack_require__(6012);
            const FileProgress = __webpack_require__(1911);
            const FileInfo = __webpack_require__(3844);
            const Buttons = __webpack_require__(6757);
            module.exports = class FileItem extends Component {
                componentDidMount() {
                    const {file} = this.props;
                    if (!file.preview) this.props.handleRequestThumbnail(file);
                }
                shouldComponentUpdate(nextProps) {
                    return !shallowEqual(this.props, nextProps);
                }
                componentDidUpdate() {
                    const {file} = this.props;
                    if (!file.preview) this.props.handleRequestThumbnail(file);
                }
                componentWillUnmount() {
                    const {file} = this.props;
                    if (!file.preview) this.props.handleCancelThumbnail(file);
                }
                render() {
                    const {file} = this.props;
                    const isProcessing = file.progress.preprocess || file.progress.postprocess;
                    const isUploaded = file.progress.uploadComplete && !isProcessing && !file.error;
                    const uploadInProgressOrComplete = file.progress.uploadStarted || isProcessing;
                    const uploadInProgress = file.progress.uploadStarted && !file.progress.uploadComplete || isProcessing;
                    const error = file.error || false;
                    const {isGhost} = file;
                    let showRemoveButton = this.props.individualCancellation ? !isUploaded : !uploadInProgress && !isUploaded;
                    if (isUploaded && this.props.showRemoveButtonAfterComplete) showRemoveButton = true;
                    const dashboardItemClass = classNames({
                        "uppy-Dashboard-Item": true,
                        "is-inprogress": uploadInProgress && !this.props.recoveredState,
                        "is-processing": isProcessing,
                        "is-complete": isUploaded,
                        "is-error": !!error,
                        "is-resumable": this.props.resumableUploads,
                        "is-noIndividualCancellation": !this.props.individualCancellation,
                        "is-ghost": isGhost
                    });
                    return h("div", {
                        className: dashboardItemClass,
                        id: `uppy_${file.id}`,
                        role: this.props.role
                    }, h("div", {
                        className: "uppy-Dashboard-Item-preview"
                    }, h(FilePreviewAndLink, {
                        file,
                        showLinkToFileUploadResult: this.props.showLinkToFileUploadResult,
                        i18n: this.props.i18n,
                        toggleFileCard: this.props.toggleFileCard,
                        metaFields: this.props.metaFields
                    }), h(FileProgress, {
                        uppy: this.props.uppy,
                        file,
                        error,
                        isUploaded,
                        hideRetryButton: this.props.hideRetryButton,
                        hideCancelButton: this.props.hideCancelButton,
                        hidePauseResumeButton: this.props.hidePauseResumeButton,
                        recoveredState: this.props.recoveredState,
                        showRemoveButtonAfterComplete: this.props.showRemoveButtonAfterComplete,
                        resumableUploads: this.props.resumableUploads,
                        individualCancellation: this.props.individualCancellation,
                        i18n: this.props.i18n
                    })), h("div", {
                        className: "uppy-Dashboard-Item-fileInfoAndButtons"
                    }, h(FileInfo, {
                        file,
                        id: this.props.id,
                        acquirers: this.props.acquirers,
                        containerWidth: this.props.containerWidth,
                        i18n: this.props.i18n,
                        toggleAddFilesPanel: this.props.toggleAddFilesPanel,
                        toggleFileCard: this.props.toggleFileCard,
                        metaFields: this.props.metaFields
                    }), h(Buttons, {
                        file,
                        metaFields: this.props.metaFields,
                        showLinkToFileUploadResult: this.props.showLinkToFileUploadResult,
                        showRemoveButton,
                        canEditFile: this.props.canEditFile,
                        uploadInProgressOrComplete,
                        toggleFileCard: this.props.toggleFileCard,
                        openFileEditor: this.props.openFileEditor,
                        uppy: this.props.uppy,
                        i18n: this.props.i18n
                    })));
                }
            };
        },
        8689: (module, __unused_webpack_exports, __webpack_require__) => {
            function _extends() {
                _extends = Object.assign || function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i];
                        for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
                    }
                    return target;
                };
                return _extends.apply(this, arguments);
            }
            const classNames = __webpack_require__(4184);
            const {h} = __webpack_require__(6400);
            const FileItem = __webpack_require__(5845);
            const VirtualList = __webpack_require__(4825);
            function chunks(list, size) {
                const chunked = [];
                let currentChunk = [];
                list.forEach((item => {
                    if (currentChunk.length < size) currentChunk.push(item); else {
                        chunked.push(currentChunk);
                        currentChunk = [ item ];
                    }
                }));
                if (currentChunk.length) chunked.push(currentChunk);
                return chunked;
            }
            module.exports = props => {
                const noFiles = 0 === props.totalFileCount;
                const dashboardFilesClass = classNames("uppy-Dashboard-files", {
                    "uppy-Dashboard-files--noFiles": noFiles
                });
                const rowHeight = 1 === props.itemsPerRow ? 71 : 200;
                const fileProps = {
                    id: props.id,
                    error: props.error,
                    i18n: props.i18n,
                    uppy: props.uppy,
                    acquirers: props.acquirers,
                    resumableUploads: props.resumableUploads,
                    individualCancellation: props.individualCancellation,
                    hideRetryButton: props.hideRetryButton,
                    hidePauseResumeButton: props.hidePauseResumeButton,
                    hideCancelButton: props.hideCancelButton,
                    showLinkToFileUploadResult: props.showLinkToFileUploadResult,
                    showRemoveButtonAfterComplete: props.showRemoveButtonAfterComplete,
                    isWide: props.isWide,
                    metaFields: props.metaFields,
                    recoveredState: props.recoveredState,
                    toggleFileCard: props.toggleFileCard,
                    handleRequestThumbnail: props.handleRequestThumbnail,
                    handleCancelThumbnail: props.handleCancelThumbnail
                };
                const sortByGhostComesFirst = (file1, file2) => props.files[file2].isGhost - props.files[file1].isGhost;
                const files = Object.keys(props.files);
                if (props.recoveredState) files.sort(sortByGhostComesFirst);
                const rows = chunks(files, props.itemsPerRow);
                const renderRow = row => h("div", {
                    role: "presentation",
                    key: row[0]
                }, row.map((fileID => h(FileItem, _extends({
                    key: fileID,
                    uppy: props.uppy
                }, fileProps, {
                    role: "listitem",
                    openFileEditor: props.openFileEditor,
                    canEditFile: props.canEditFile,
                    toggleAddFilesPanel: props.toggleAddFilesPanel,
                    file: props.files[fileID]
                })))));
                return h(VirtualList, {
                    class: dashboardFilesClass,
                    role: "list",
                    data: rows,
                    renderRow,
                    rowHeight
                });
            };
        },
        9282: (module, __unused_webpack_exports, __webpack_require__) => {
            const {h} = __webpack_require__(6400);
            const getFileTypeIcon = __webpack_require__(1882);
            module.exports = function FilePreview(props) {
                const {file} = props;
                if (file.preview) return h("img", {
                    className: "uppy-Dashboard-Item-previewImg",
                    alt: file.name,
                    src: file.preview
                });
                const {color, icon} = getFileTypeIcon(file.type);
                return h("div", {
                    className: "uppy-Dashboard-Item-previewIconWrap"
                }, h("span", {
                    className: "uppy-Dashboard-Item-previewIcon",
                    style: {
                        color
                    }
                }, icon), h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    className: "uppy-Dashboard-Item-previewIconBg",
                    width: "58",
                    height: "76",
                    viewBox: "0 0 58 76"
                }, h("rect", {
                    fill: "#FFF",
                    width: "58",
                    height: "76",
                    rx: "3",
                    fillRule: "evenodd"
                })));
            };
        },
        5859: (module, __unused_webpack_exports, __webpack_require__) => {
            const {h} = __webpack_require__(6400);
            const classNames = __webpack_require__(4184);
            const ignoreEvent = __webpack_require__(8805);
            function PickerPanelContent(props) {
                return h("div", {
                    className: classNames("uppy-DashboardContent-panel", props.className),
                    role: "tabpanel",
                    "data-uppy-panelType": "PickerPanel",
                    id: `uppy-DashboardContent-panel--${props.activePickerPanel.id}`,
                    onDragOver: ignoreEvent,
                    onDragLeave: ignoreEvent,
                    onDrop: ignoreEvent,
                    onPaste: ignoreEvent
                }, h("div", {
                    className: "uppy-DashboardContent-bar"
                }, h("div", {
                    className: "uppy-DashboardContent-title",
                    role: "heading",
                    "aria-level": "1"
                }, props.i18n("importFrom", {
                    name: props.activePickerPanel.name
                })), h("button", {
                    className: "uppy-DashboardContent-back",
                    type: "button",
                    onClick: props.hideAllPanels
                }, props.i18n("cancel"))), h("div", {
                    className: "uppy-DashboardContent-panelBody"
                }, props.uppy.getPlugin(props.activePickerPanel.id).render(props.state)));
            }
            module.exports = PickerPanelContent;
        },
        7246: (module, __unused_webpack_exports, __webpack_require__) => {
            const {h} = __webpack_require__(6400);
            const uploadStates = {
                STATE_ERROR: "error",
                STATE_WAITING: "waiting",
                STATE_PREPROCESSING: "preprocessing",
                STATE_UPLOADING: "uploading",
                STATE_POSTPROCESSING: "postprocessing",
                STATE_COMPLETE: "complete",
                STATE_PAUSED: "paused"
            };
            function getUploadingState(isAllErrored, isAllComplete, isAllPaused, files) {
                if (void 0 === files) files = {};
                if (isAllErrored) return uploadStates.STATE_ERROR;
                if (isAllComplete) return uploadStates.STATE_COMPLETE;
                if (isAllPaused) return uploadStates.STATE_PAUSED;
                let state = uploadStates.STATE_WAITING;
                const fileIDs = Object.keys(files);
                for (let i = 0; i < fileIDs.length; i++) {
                    const {progress} = files[fileIDs[i]];
                    if (progress.uploadStarted && !progress.uploadComplete) return uploadStates.STATE_UPLOADING;
                    if (progress.preprocess && state !== uploadStates.STATE_UPLOADING) state = uploadStates.STATE_PREPROCESSING;
                    if (progress.postprocess && state !== uploadStates.STATE_UPLOADING && state !== uploadStates.STATE_PREPROCESSING) state = uploadStates.STATE_POSTPROCESSING;
                }
                return state;
            }
            function UploadStatus(props) {
                const uploadingState = getUploadingState(props.isAllErrored, props.isAllComplete, props.isAllPaused, props.files);
                switch (uploadingState) {
                  case "uploading":
                    return props.i18n("uploadingXFiles", {
                        smart_count: props.inProgressNotPausedFiles.length
                    });

                  case "preprocessing":
                  case "postprocessing":
                    return props.i18n("processingXFiles", {
                        smart_count: props.processingFiles.length
                    });

                  case "paused":
                    return props.i18n("uploadPaused");

                  case "waiting":
                    return props.i18n("xFilesSelected", {
                        smart_count: props.newFiles.length
                    });

                  case "complete":
                    return props.i18n("uploadComplete");
                }
            }
            function PanelTopBar(props) {
                let {allowNewUpload} = props;
                if (allowNewUpload && props.maxNumberOfFiles) allowNewUpload = props.totalFileCount < props.maxNumberOfFiles;
                return h("div", {
                    className: "uppy-DashboardContent-bar"
                }, !props.isAllComplete && !props.hideCancelButton ? h("button", {
                    className: "uppy-DashboardContent-back",
                    type: "button",
                    onClick: () => props.uppy.cancelAll()
                }, props.i18n("cancel")) : h("div", null), h("div", {
                    className: "uppy-DashboardContent-title",
                    role: "heading",
                    "aria-level": "1"
                }, h(UploadStatus, props)), allowNewUpload ? h("button", {
                    className: "uppy-DashboardContent-addMore",
                    type: "button",
                    "aria-label": props.i18n("addMoreFiles"),
                    title: props.i18n("addMoreFiles"),
                    onClick: () => props.toggleAddFilesPanel(true)
                }, h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    className: "uppy-c-icon",
                    width: "15",
                    height: "15",
                    viewBox: "0 0 15 15"
                }, h("path", {
                    d: "M8 6.5h6a.5.5 0 0 1 .5.5v.5a.5.5 0 0 1-.5.5H8v6a.5.5 0 0 1-.5.5H7a.5.5 0 0 1-.5-.5V8h-6a.5.5 0 0 1-.5-.5V7a.5.5 0 0 1 .5-.5h6v-6A.5.5 0 0 1 7 0h.5a.5.5 0 0 1 .5.5v6z"
                })), h("span", {
                    className: "uppy-DashboardContent-addMoreCaption"
                }, props.i18n("addMore"))) : h("div", null));
            }
            module.exports = PanelTopBar;
        },
        9167: (module, __unused_webpack_exports, __webpack_require__) => {
            const {cloneElement, Component, toChildArray} = __webpack_require__(6400);
            const classNames = __webpack_require__(4184);
            const transitionName = "uppy-transition-slideDownUp";
            const duration = 250;
            class Slide extends Component {
                constructor(props) {
                    super(props);
                    this.state = {
                        cachedChildren: null,
                        className: ""
                    };
                }
                componentWillUpdate(nextProps) {
                    const {cachedChildren} = this.state;
                    const child = toChildArray(nextProps.children)[0];
                    if (cachedChildren === child) return null;
                    const patch = {
                        cachedChildren: child
                    };
                    if (child && !cachedChildren) {
                        patch.className = `${transitionName}-enter`;
                        cancelAnimationFrame(this.animationFrame);
                        clearTimeout(this.leaveTimeout);
                        this.leaveTimeout = void 0;
                        this.animationFrame = requestAnimationFrame((() => {
                            this.setState({
                                className: `${transitionName}-enter ${transitionName}-enter-active`
                            });
                            this.enterTimeout = setTimeout((() => {
                                this.setState({
                                    className: ""
                                });
                            }), duration);
                        }));
                    }
                    if (cachedChildren && !child && void 0 === this.leaveTimeout) {
                        patch.cachedChildren = cachedChildren;
                        patch.className = `${transitionName}-leave`;
                        cancelAnimationFrame(this.animationFrame);
                        clearTimeout(this.enterTimeout);
                        this.enterTimeout = void 0;
                        this.animationFrame = requestAnimationFrame((() => {
                            this.setState({
                                className: `${transitionName}-leave ${transitionName}-leave-active`
                            });
                            this.leaveTimeout = setTimeout((() => {
                                this.setState({
                                    cachedChildren: null,
                                    className: ""
                                });
                            }), duration);
                        }));
                    }
                    this.setState(patch);
                }
                render() {
                    const {cachedChildren, className} = this.state;
                    if (!cachedChildren) return null;
                    return cloneElement(cachedChildren, {
                        className: classNames(className, cachedChildren.props.className)
                    });
                }
            }
            module.exports = Slide;
        },
        4825: (module, __unused_webpack_exports, __webpack_require__) => {
            function _extends() {
                _extends = Object.assign || function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i];
                        for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
                    }
                    return target;
                };
                return _extends.apply(this, arguments);
            }
            const {h, Component} = __webpack_require__(6400);
            const STYLE_INNER = {
                position: "relative",
                width: "100%",
                minHeight: "100%"
            };
            const STYLE_CONTENT = {
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                overflow: "visible"
            };
            class VirtualList extends Component {
                constructor(props) {
                    super(props);
                    this.handleScroll = () => {
                        this.setState({
                            offset: this.base.scrollTop
                        });
                    };
                    this.handleResize = () => {
                        this.resize();
                    };
                    this.focusElement = null;
                    this.state = {
                        offset: 0,
                        height: 0
                    };
                }
                componentDidMount() {
                    this.resize();
                    window.addEventListener("resize", this.handleResize);
                }
                componentWillUpdate() {
                    if (this.base.contains(document.activeElement)) this.focusElement = document.activeElement;
                }
                componentDidUpdate() {
                    if (this.focusElement && this.focusElement.parentNode && document.activeElement !== this.focusElement) this.focusElement.focus();
                    this.focusElement = null;
                    this.resize();
                }
                componentWillUnmount() {
                    window.removeEventListener("resize", this.handleResize);
                }
                resize() {
                    const {height} = this.state;
                    if (height !== this.base.offsetHeight) this.setState({
                        height: this.base.offsetHeight
                    });
                }
                render(_ref) {
                    let {data, rowHeight, renderRow, overscanCount = 10, ...props} = _ref;
                    const {offset, height} = this.state;
                    let start = Math.floor(offset / rowHeight);
                    let visibleRowCount = Math.floor(height / rowHeight);
                    if (overscanCount) {
                        start = Math.max(0, start - start % overscanCount);
                        visibleRowCount += overscanCount;
                    }
                    const end = start + visibleRowCount + 4;
                    const selection = data.slice(start, end);
                    const styleInner = {
                        ...STYLE_INNER,
                        height: data.length * rowHeight
                    };
                    const styleContent = {
                        ...STYLE_CONTENT,
                        top: start * rowHeight
                    };
                    return h("div", _extends({
                        onScroll: this.handleScroll
                    }, props), h("div", {
                        role: "presentation",
                        style: styleInner
                    }, h("div", {
                        role: "presentation",
                        style: styleContent
                    }, selection.map(renderRow))));
                }
            }
            module.exports = VirtualList;
        },
        3121: (module, __unused_webpack_exports, __webpack_require__) => {
            var _class, _openFileEditorWhenFilesAdded, _attachRenderFunctionToTarget, _isTargetSupported, _getAcquirers, _getProgressIndicators, _getEditors, _temp;
            function _classPrivateFieldLooseBase(receiver, privateKey) {
                if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) throw new TypeError("attempted to use private field on non-instance");
                return receiver;
            }
            var id = 0;
            function _classPrivateFieldLooseKey(name) {
                return "__private_" + id++ + "_" + name;
            }
            const {h} = __webpack_require__(6400);
            const {UIPlugin} = __webpack_require__(9429);
            const StatusBar = __webpack_require__(3215);
            const Informer = __webpack_require__(873);
            const ThumbnailGenerator = __webpack_require__(7753);
            const findAllDOMElements = __webpack_require__(1147);
            const toArray = __webpack_require__(6361);
            const getDroppedFiles = __webpack_require__(4031);
            const getTextDirection = __webpack_require__(8958);
            const {nanoid} = __webpack_require__(2961);
            const trapFocus = __webpack_require__(3962);
            const createSuperFocus = __webpack_require__(6673);
            const memoize = __webpack_require__(845)["default"] || __webpack_require__(845);
            const FOCUSABLE_ELEMENTS = __webpack_require__(9045);
            const DashboardUI = __webpack_require__(5519);
            const locale = __webpack_require__(5233);
            const TAB_KEY = 9;
            const ESC_KEY = 27;
            function createPromise() {
                const o = {};
                o.promise = new Promise(((resolve, reject) => {
                    o.resolve = resolve;
                    o.reject = reject;
                }));
                return o;
            }
            function defaultPickerIcon() {
                return h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    width: "30",
                    height: "30",
                    viewBox: "0 0 30 30"
                }, h("path", {
                    d: "M15 30c8.284 0 15-6.716 15-15 0-8.284-6.716-15-15-15C6.716 0 0 6.716 0 15c0 8.284 6.716 15 15 15zm4.258-12.676v6.846h-8.426v-6.846H5.204l9.82-12.364 9.82 12.364H19.26z"
                }));
            }
            module.exports = (_temp = (_openFileEditorWhenFilesAdded = _classPrivateFieldLooseKey("openFileEditorWhenFilesAdded"), 
            _attachRenderFunctionToTarget = _classPrivateFieldLooseKey("attachRenderFunctionToTarget"), 
            _isTargetSupported = _classPrivateFieldLooseKey("isTargetSupported"), _getAcquirers = _classPrivateFieldLooseKey("getAcquirers"), 
            _getProgressIndicators = _classPrivateFieldLooseKey("getProgressIndicators"), _getEditors = _classPrivateFieldLooseKey("getEditors"), 
            _class = class Dashboard extends UIPlugin {
                constructor(uppy, _opts) {
                    var _this;
                    super(uppy, _opts);
                    _this = this;
                    this.removeTarget = plugin => {
                        const pluginState = this.getPluginState();
                        const newTargets = pluginState.targets.filter((target => target.id !== plugin.id));
                        this.setPluginState({
                            targets: newTargets
                        });
                    };
                    this.addTarget = plugin => {
                        const callerPluginId = plugin.id || plugin.constructor.name;
                        const callerPluginName = plugin.title || callerPluginId;
                        const callerPluginType = plugin.type;
                        if ("acquirer" !== callerPluginType && "progressindicator" !== callerPluginType && "editor" !== callerPluginType) {
                            const msg = "Dashboard: can only be targeted by plugins of types: acquirer, progressindicator, editor";
                            this.uppy.log(msg, "error");
                            return;
                        }
                        const target = {
                            id: callerPluginId,
                            name: callerPluginName,
                            type: callerPluginType
                        };
                        const state = this.getPluginState();
                        const newTargets = state.targets.slice();
                        newTargets.push(target);
                        this.setPluginState({
                            targets: newTargets
                        });
                        return this.el;
                    };
                    this.hideAllPanels = () => {
                        const state = this.getPluginState();
                        const update = {
                            activePickerPanel: false,
                            showAddFilesPanel: false,
                            activeOverlayType: null,
                            fileCardFor: null,
                            showFileEditor: false
                        };
                        if (state.activePickerPanel === update.activePickerPanel && state.showAddFilesPanel === update.showAddFilesPanel && state.showFileEditor === update.showFileEditor && state.activeOverlayType === update.activeOverlayType) return;
                        this.setPluginState(update);
                    };
                    this.showPanel = id => {
                        const {targets} = this.getPluginState();
                        const activePickerPanel = targets.filter((target => "acquirer" === target.type && target.id === id))[0];
                        this.setPluginState({
                            activePickerPanel,
                            activeOverlayType: "PickerPanel"
                        });
                    };
                    this.canEditFile = file => {
                        const {targets} = this.getPluginState();
                        const editors = _classPrivateFieldLooseBase(this, _getEditors)[_getEditors](targets);
                        return editors.some((target => this.uppy.getPlugin(target.id).canEditFile(file)));
                    };
                    this.openFileEditor = file => {
                        const {targets} = this.getPluginState();
                        const editors = _classPrivateFieldLooseBase(this, _getEditors)[_getEditors](targets);
                        this.setPluginState({
                            showFileEditor: true,
                            fileCardFor: file.id || null,
                            activeOverlayType: "FileEditor"
                        });
                        editors.forEach((editor => {
                            this.uppy.getPlugin(editor.id).selectFile(file);
                        }));
                    };
                    this.saveFileEditor = () => {
                        const {targets} = this.getPluginState();
                        const editors = _classPrivateFieldLooseBase(this, _getEditors)[_getEditors](targets);
                        editors.forEach((editor => {
                            this.uppy.getPlugin(editor.id).save();
                        }));
                        this.hideAllPanels();
                    };
                    this.openModal = () => {
                        const {promise, resolve} = createPromise();
                        this.savedScrollPosition = window.pageYOffset;
                        this.savedActiveElement = document.activeElement;
                        if (this.opts.disablePageScrollWhenModalOpen) document.body.classList.add("uppy-Dashboard-isFixed");
                        if (this.opts.animateOpenClose && this.getPluginState().isClosing) {
                            const handler = () => {
                                this.setPluginState({
                                    isHidden: false
                                });
                                this.el.removeEventListener("animationend", handler, false);
                                resolve();
                            };
                            this.el.addEventListener("animationend", handler, false);
                        } else {
                            this.setPluginState({
                                isHidden: false
                            });
                            resolve();
                        }
                        if (this.opts.browserBackButtonClose) this.updateBrowserHistory();
                        document.addEventListener("keydown", this.handleKeyDownInModal);
                        this.uppy.emit("dashboard:modal-open");
                        return promise;
                    };
                    this.closeModal = function(opts) {
                        if (void 0 === opts) opts = {};
                        const {manualClose = true} = opts;
                        const {isHidden, isClosing} = _this.getPluginState();
                        if (isHidden || isClosing) return;
                        const {promise, resolve} = createPromise();
                        if (_this.opts.disablePageScrollWhenModalOpen) document.body.classList.remove("uppy-Dashboard-isFixed");
                        if (_this.opts.animateOpenClose) {
                            _this.setPluginState({
                                isClosing: true
                            });
                            const handler = () => {
                                _this.setPluginState({
                                    isHidden: true,
                                    isClosing: false
                                });
                                _this.superFocus.cancel();
                                _this.savedActiveElement.focus();
                                _this.el.removeEventListener("animationend", handler, false);
                                resolve();
                            };
                            _this.el.addEventListener("animationend", handler, false);
                        } else {
                            _this.setPluginState({
                                isHidden: true
                            });
                            _this.superFocus.cancel();
                            _this.savedActiveElement.focus();
                            resolve();
                        }
                        document.removeEventListener("keydown", _this.handleKeyDownInModal);
                        if (manualClose) if (_this.opts.browserBackButtonClose) {
                            var _history$state;
                            if (null != (_history$state = history.state) && _history$state[_this.modalName]) history.back();
                        }
                        _this.uppy.emit("dashboard:modal-closed");
                        return promise;
                    };
                    this.isModalOpen = () => !this.getPluginState().isHidden || false;
                    this.requestCloseModal = () => {
                        if (this.opts.onRequestCloseModal) return this.opts.onRequestCloseModal();
                        return this.closeModal();
                    };
                    this.setDarkModeCapability = isDarkModeOn => {
                        const {capabilities} = this.uppy.getState();
                        this.uppy.setState({
                            capabilities: {
                                ...capabilities,
                                darkMode: isDarkModeOn
                            }
                        });
                    };
                    this.handleSystemDarkModeChange = event => {
                        const isDarkModeOnNow = event.matches;
                        this.uppy.log(`[Dashboard] Dark mode is ${isDarkModeOnNow ? "on" : "off"}`);
                        this.setDarkModeCapability(isDarkModeOnNow);
                    };
                    this.toggleFileCard = (show, fileID) => {
                        const file = this.uppy.getFile(fileID);
                        if (show) this.uppy.emit("dashboard:file-edit-start", file); else this.uppy.emit("dashboard:file-edit-complete", file);
                        this.setPluginState({
                            fileCardFor: show ? fileID : null,
                            activeOverlayType: show ? "FileCard" : null
                        });
                    };
                    this.toggleAddFilesPanel = show => {
                        this.setPluginState({
                            showAddFilesPanel: show,
                            activeOverlayType: show ? "AddFiles" : null
                        });
                    };
                    this.addFiles = files => {
                        const descriptors = files.map((file => ({
                            source: this.id,
                            name: file.name,
                            type: file.type,
                            data: file,
                            meta: {
                                relativePath: file.relativePath || null
                            }
                        })));
                        try {
                            this.uppy.addFiles(descriptors);
                        } catch (err) {
                            this.uppy.log(err);
                        }
                    };
                    this.startListeningToResize = () => {
                        this.resizeObserver = new ResizeObserver((entries => {
                            const uppyDashboardInnerEl = entries[0];
                            const {width, height} = uppyDashboardInnerEl.contentRect;
                            this.uppy.log(`[Dashboard] resized: ${width} / ${height}`, "debug");
                            this.setPluginState({
                                containerWidth: width,
                                containerHeight: height,
                                areInsidesReadyToBeVisible: true
                            });
                        }));
                        this.resizeObserver.observe(this.el.querySelector(".uppy-Dashboard-inner"));
                        this.makeDashboardInsidesVisibleAnywayTimeout = setTimeout((() => {
                            const pluginState = this.getPluginState();
                            const isModalAndClosed = !this.opts.inline && pluginState.isHidden;
                            if (!pluginState.areInsidesReadyToBeVisible && !isModalAndClosed) {
                                this.uppy.log("[Dashboard] resize event didn't fire on time: defaulted to mobile layout", "debug");
                                this.setPluginState({
                                    areInsidesReadyToBeVisible: true
                                });
                            }
                        }), 1e3);
                    };
                    this.stopListeningToResize = () => {
                        this.resizeObserver.disconnect();
                        clearTimeout(this.makeDashboardInsidesVisibleAnywayTimeout);
                    };
                    this.recordIfFocusedOnUppyRecently = event => {
                        if (this.el.contains(event.target)) this.ifFocusedOnUppyRecently = true; else {
                            this.ifFocusedOnUppyRecently = false;
                            this.superFocus.cancel();
                        }
                    };
                    this.disableAllFocusableElements = disable => {
                        const focusableNodes = toArray(this.el.querySelectorAll(FOCUSABLE_ELEMENTS));
                        if (disable) focusableNodes.forEach((node => {
                            const currentTabIndex = node.getAttribute("tabindex");
                            if (currentTabIndex) node.dataset.inertTabindex = currentTabIndex;
                            node.setAttribute("tabindex", "-1");
                        })); else focusableNodes.forEach((node => {
                            if ("inertTabindex" in node.dataset) node.setAttribute("tabindex", node.dataset.inertTabindex); else node.removeAttribute("tabindex");
                        }));
                        this.dashboardIsDisabled = disable;
                    };
                    this.updateBrowserHistory = () => {
                        var _history$state2;
                        if (!(null != (_history$state2 = history.state) && _history$state2[this.modalName])) history.pushState({
                            ...history.state,
                            [this.modalName]: true
                        }, "");
                        window.addEventListener("popstate", this.handlePopState, false);
                    };
                    this.handlePopState = event => {
                        var _event$state;
                        if (this.isModalOpen() && (!event.state || !event.state[this.modalName])) this.closeModal({
                            manualClose: false
                        });
                        if (!this.isModalOpen() && null != (_event$state = event.state) && _event$state[this.modalName]) history.back();
                    };
                    this.handleKeyDownInModal = event => {
                        if (event.keyCode === ESC_KEY) this.requestCloseModal(event);
                        if (event.keyCode === TAB_KEY) trapFocus.forModal(event, this.getPluginState().activeOverlayType, this.el);
                    };
                    this.handleClickOutside = () => {
                        if (this.opts.closeModalOnClickOutside) this.requestCloseModal();
                    };
                    this.handlePaste = event => {
                        this.uppy.iteratePlugins((plugin => {
                            if ("acquirer" === plugin.type) null == plugin.handleRootPaste ? void 0 : plugin.handleRootPaste(event);
                        }));
                        const files = toArray(event.clipboardData.files);
                        if (files.length > 0) {
                            this.uppy.log("[Dashboard] Files pasted");
                            this.addFiles(files);
                        }
                    };
                    this.handleInputChange = event => {
                        event.preventDefault();
                        const files = toArray(event.target.files);
                        if (files.length > 0) {
                            this.uppy.log("[Dashboard] Files selected through input");
                            this.addFiles(files);
                        }
                    };
                    this.handleDragOver = event => {
                        var _this$opts$onDragOver, _this$opts;
                        event.preventDefault();
                        event.stopPropagation();
                        const canSomePluginHandleRootDrop = () => {
                            let somePluginCanHandleRootDrop = true;
                            this.uppy.iteratePlugins((plugin => {
                                if (null != plugin.canHandleRootDrop && plugin.canHandleRootDrop(event)) somePluginCanHandleRootDrop = true;
                            }));
                            return somePluginCanHandleRootDrop;
                        };
                        const doesEventHaveFiles = () => {
                            const {types} = event.dataTransfer;
                            return types.some((type => "Files" === type));
                        };
                        const somePluginCanHandleRootDrop = canSomePluginHandleRootDrop(event);
                        const hasFiles = doesEventHaveFiles(event);
                        if (!somePluginCanHandleRootDrop && !hasFiles || this.opts.disabled || this.opts.disableLocalFiles && (hasFiles || !somePluginCanHandleRootDrop) || !this.uppy.getState().allowNewUpload) {
                            event.dataTransfer.dropEffect = "none";
                            clearTimeout(this.removeDragOverClassTimeout);
                            return;
                        }
                        event.dataTransfer.dropEffect = "copy";
                        clearTimeout(this.removeDragOverClassTimeout);
                        this.setPluginState({
                            isDraggingOver: true
                        });
                        null == (_this$opts$onDragOver = (_this$opts = this.opts).onDragOver) ? void 0 : _this$opts$onDragOver.call(_this$opts, event);
                    };
                    this.handleDragLeave = event => {
                        var _this$opts$onDragLeav, _this$opts2;
                        event.preventDefault();
                        event.stopPropagation();
                        clearTimeout(this.removeDragOverClassTimeout);
                        this.removeDragOverClassTimeout = setTimeout((() => {
                            this.setPluginState({
                                isDraggingOver: false
                            });
                        }), 50);
                        null == (_this$opts$onDragLeav = (_this$opts2 = this.opts).onDragLeave) ? void 0 : _this$opts$onDragLeav.call(_this$opts2, event);
                    };
                    this.handleDrop = async event => {
                        var _this$opts$onDrop, _this$opts3;
                        event.preventDefault();
                        event.stopPropagation();
                        clearTimeout(this.removeDragOverClassTimeout);
                        this.setPluginState({
                            isDraggingOver: false
                        });
                        this.uppy.iteratePlugins((plugin => {
                            if ("acquirer" === plugin.type) null == plugin.handleRootDrop ? void 0 : plugin.handleRootDrop(event);
                        }));
                        let executedDropErrorOnce = false;
                        const logDropError = error => {
                            this.uppy.log(error, "error");
                            if (!executedDropErrorOnce) {
                                this.uppy.info(error.message, "error");
                                executedDropErrorOnce = true;
                            }
                        };
                        const files = await getDroppedFiles(event.dataTransfer, {
                            logDropError
                        });
                        if (files.length > 0) {
                            this.uppy.log("[Dashboard] Files dropped");
                            this.addFiles(files);
                        }
                        null == (_this$opts$onDrop = (_this$opts3 = this.opts).onDrop) ? void 0 : _this$opts$onDrop.call(_this$opts3, event);
                    };
                    this.handleRequestThumbnail = file => {
                        if (!this.opts.waitForThumbnailsBeforeUpload) this.uppy.emit("thumbnail:request", file);
                    };
                    this.handleCancelThumbnail = file => {
                        if (!this.opts.waitForThumbnailsBeforeUpload) this.uppy.emit("thumbnail:cancel", file);
                    };
                    this.handleKeyDownInInline = event => {
                        if (event.keyCode === TAB_KEY) trapFocus.forInline(event, this.getPluginState().activeOverlayType, this.el);
                    };
                    this.handlePasteOnBody = event => {
                        const isFocusInOverlay = this.el.contains(document.activeElement);
                        if (isFocusInOverlay) this.handlePaste(event);
                    };
                    this.handleComplete = _ref => {
                        let {failed} = _ref;
                        if (this.opts.closeAfterFinish && 0 === failed.length) this.requestCloseModal();
                    };
                    this.handleCancelRestore = () => {
                        this.uppy.emit("restore-canceled");
                    };
                    Object.defineProperty(this, _openFileEditorWhenFilesAdded, {
                        writable: true,
                        value: files => {
                            const firstFile = files[0];
                            if (this.canEditFile(firstFile)) this.openFileEditor(firstFile);
                        }
                    });
                    this.initEvents = () => {
                        if (this.opts.trigger && !this.opts.inline) {
                            const showModalTrigger = findAllDOMElements(this.opts.trigger);
                            if (showModalTrigger) showModalTrigger.forEach((trigger => trigger.addEventListener("click", this.openModal))); else this.uppy.log("Dashboard modal trigger not found. Make sure `trigger` is set in Dashboard options, unless you are planning to call `dashboard.openModal()` method yourself", "warning");
                        }
                        this.startListeningToResize();
                        document.addEventListener("paste", this.handlePasteOnBody);
                        this.uppy.on("plugin-remove", this.removeTarget);
                        this.uppy.on("file-added", this.hideAllPanels);
                        this.uppy.on("dashboard:modal-closed", this.hideAllPanels);
                        this.uppy.on("file-editor:complete", this.hideAllPanels);
                        this.uppy.on("complete", this.handleComplete);
                        document.addEventListener("focus", this.recordIfFocusedOnUppyRecently, true);
                        document.addEventListener("click", this.recordIfFocusedOnUppyRecently, true);
                        if (this.opts.inline) this.el.addEventListener("keydown", this.handleKeyDownInInline);
                        if (this.opts.autoOpenFileEditor) this.uppy.on("files-added", _classPrivateFieldLooseBase(this, _openFileEditorWhenFilesAdded)[_openFileEditorWhenFilesAdded]);
                    };
                    this.removeEvents = () => {
                        const showModalTrigger = findAllDOMElements(this.opts.trigger);
                        if (!this.opts.inline && showModalTrigger) showModalTrigger.forEach((trigger => trigger.removeEventListener("click", this.openModal)));
                        this.stopListeningToResize();
                        document.removeEventListener("paste", this.handlePasteOnBody);
                        window.removeEventListener("popstate", this.handlePopState, false);
                        this.uppy.off("plugin-remove", this.removeTarget);
                        this.uppy.off("file-added", this.hideAllPanels);
                        this.uppy.off("dashboard:modal-closed", this.hideAllPanels);
                        this.uppy.off("file-editor:complete", this.hideAllPanels);
                        this.uppy.off("complete", this.handleComplete);
                        document.removeEventListener("focus", this.recordIfFocusedOnUppyRecently);
                        document.removeEventListener("click", this.recordIfFocusedOnUppyRecently);
                        if (this.opts.inline) this.el.removeEventListener("keydown", this.handleKeyDownInInline);
                        if (this.opts.autoOpenFileEditor) this.uppy.off("files-added", _classPrivateFieldLooseBase(this, _openFileEditorWhenFilesAdded)[_openFileEditorWhenFilesAdded]);
                    };
                    this.superFocusOnEachUpdate = () => {
                        const isFocusInUppy = this.el.contains(document.activeElement);
                        const isFocusNowhere = document.activeElement === document.body || null === document.activeElement;
                        const isInformerHidden = 0 === this.uppy.getState().info.length;
                        const isModal = !this.opts.inline;
                        if (isInformerHidden && (isModal || isFocusInUppy || isFocusNowhere && this.ifFocusedOnUppyRecently)) this.superFocus(this.el, this.getPluginState().activeOverlayType); else this.superFocus.cancel();
                    };
                    this.afterUpdate = () => {
                        if (this.opts.disabled && !this.dashboardIsDisabled) {
                            this.disableAllFocusableElements(true);
                            return;
                        }
                        if (!this.opts.disabled && this.dashboardIsDisabled) this.disableAllFocusableElements(false);
                        this.superFocusOnEachUpdate();
                    };
                    this.saveFileCard = (meta, fileID) => {
                        this.uppy.setFileMeta(fileID, meta);
                        this.toggleFileCard(false, fileID);
                    };
                    Object.defineProperty(this, _attachRenderFunctionToTarget, {
                        writable: true,
                        value: target => {
                            const plugin = this.uppy.getPlugin(target.id);
                            return {
                                ...target,
                                icon: plugin.icon || this.opts.defaultPickerIcon,
                                render: plugin.render
                            };
                        }
                    });
                    Object.defineProperty(this, _isTargetSupported, {
                        writable: true,
                        value: target => {
                            const plugin = this.uppy.getPlugin(target.id);
                            if ("function" !== typeof plugin.isSupported) return true;
                            return plugin.isSupported();
                        }
                    });
                    Object.defineProperty(this, _getAcquirers, {
                        writable: true,
                        value: memoize((targets => targets.filter((target => "acquirer" === target.type && _classPrivateFieldLooseBase(this, _isTargetSupported)[_isTargetSupported](target))).map(_classPrivateFieldLooseBase(this, _attachRenderFunctionToTarget)[_attachRenderFunctionToTarget])))
                    });
                    Object.defineProperty(this, _getProgressIndicators, {
                        writable: true,
                        value: memoize((targets => targets.filter((target => "progressindicator" === target.type)).map(_classPrivateFieldLooseBase(this, _attachRenderFunctionToTarget)[_attachRenderFunctionToTarget])))
                    });
                    Object.defineProperty(this, _getEditors, {
                        writable: true,
                        value: memoize((targets => targets.filter((target => "editor" === target.type)).map(_classPrivateFieldLooseBase(this, _attachRenderFunctionToTarget)[_attachRenderFunctionToTarget])))
                    });
                    this.render = state => {
                        const pluginState = this.getPluginState();
                        const {files, capabilities, allowNewUpload} = state;
                        const {newFiles, uploadStartedFiles, completeFiles, erroredFiles, inProgressFiles, inProgressNotPausedFiles, processingFiles, isUploadStarted, isAllComplete, isAllErrored, isAllPaused} = this.uppy.getObjectOfFilesPerState();
                        const acquirers = _classPrivateFieldLooseBase(this, _getAcquirers)[_getAcquirers](pluginState.targets);
                        const progressindicators = _classPrivateFieldLooseBase(this, _getProgressIndicators)[_getProgressIndicators](pluginState.targets);
                        const editors = _classPrivateFieldLooseBase(this, _getEditors)[_getEditors](pluginState.targets);
                        let theme;
                        if ("auto" === this.opts.theme) theme = capabilities.darkMode ? "dark" : "light"; else theme = this.opts.theme;
                        if ([ "files", "folders", "both" ].indexOf(this.opts.fileManagerSelectionType) < 0) {
                            this.opts.fileManagerSelectionType = "files";
                            console.warn(`Unsupported option for "fileManagerSelectionType". Using default of "${this.opts.fileManagerSelectionType}".`);
                        }
                        return DashboardUI({
                            state,
                            isHidden: pluginState.isHidden,
                            files,
                            newFiles,
                            uploadStartedFiles,
                            completeFiles,
                            erroredFiles,
                            inProgressFiles,
                            inProgressNotPausedFiles,
                            processingFiles,
                            isUploadStarted,
                            isAllComplete,
                            isAllErrored,
                            isAllPaused,
                            totalFileCount: Object.keys(files).length,
                            totalProgress: state.totalProgress,
                            allowNewUpload,
                            acquirers,
                            theme,
                            disabled: this.opts.disabled,
                            disableLocalFiles: this.opts.disableLocalFiles,
                            direction: this.opts.direction,
                            activePickerPanel: pluginState.activePickerPanel,
                            showFileEditor: pluginState.showFileEditor,
                            saveFileEditor: this.saveFileEditor,
                            disableAllFocusableElements: this.disableAllFocusableElements,
                            animateOpenClose: this.opts.animateOpenClose,
                            isClosing: pluginState.isClosing,
                            progressindicators,
                            editors,
                            autoProceed: this.uppy.opts.autoProceed,
                            id: this.id,
                            closeModal: this.requestCloseModal,
                            handleClickOutside: this.handleClickOutside,
                            handleInputChange: this.handleInputChange,
                            handlePaste: this.handlePaste,
                            inline: this.opts.inline,
                            showPanel: this.showPanel,
                            hideAllPanels: this.hideAllPanels,
                            i18n: this.i18n,
                            i18nArray: this.i18nArray,
                            uppy: this.uppy,
                            note: this.opts.note,
                            recoveredState: state.recoveredState,
                            metaFields: pluginState.metaFields,
                            resumableUploads: capabilities.resumableUploads || false,
                            individualCancellation: capabilities.individualCancellation,
                            isMobileDevice: capabilities.isMobileDevice,
                            fileCardFor: pluginState.fileCardFor,
                            toggleFileCard: this.toggleFileCard,
                            toggleAddFilesPanel: this.toggleAddFilesPanel,
                            showAddFilesPanel: pluginState.showAddFilesPanel,
                            saveFileCard: this.saveFileCard,
                            openFileEditor: this.openFileEditor,
                            canEditFile: this.canEditFile,
                            width: this.opts.width,
                            height: this.opts.height,
                            showLinkToFileUploadResult: this.opts.showLinkToFileUploadResult,
                            fileManagerSelectionType: this.opts.fileManagerSelectionType,
                            proudlyDisplayPoweredByUppy: this.opts.proudlyDisplayPoweredByUppy,
                            hideCancelButton: this.opts.hideCancelButton,
                            hideRetryButton: this.opts.hideRetryButton,
                            hidePauseResumeButton: this.opts.hidePauseResumeButton,
                            showRemoveButtonAfterComplete: this.opts.showRemoveButtonAfterComplete,
                            containerWidth: pluginState.containerWidth,
                            containerHeight: pluginState.containerHeight,
                            areInsidesReadyToBeVisible: pluginState.areInsidesReadyToBeVisible,
                            isTargetDOMEl: this.isTargetDOMEl,
                            parentElement: this.el,
                            allowedFileTypes: this.uppy.opts.restrictions.allowedFileTypes,
                            maxNumberOfFiles: this.uppy.opts.restrictions.maxNumberOfFiles,
                            requiredMetaFields: this.uppy.opts.restrictions.requiredMetaFields,
                            showSelectedFiles: this.opts.showSelectedFiles,
                            handleCancelRestore: this.handleCancelRestore,
                            handleRequestThumbnail: this.handleRequestThumbnail,
                            handleCancelThumbnail: this.handleCancelThumbnail,
                            isDraggingOver: pluginState.isDraggingOver,
                            handleDragOver: this.handleDragOver,
                            handleDragLeave: this.handleDragLeave,
                            handleDrop: this.handleDrop
                        });
                    };
                    this.discoverProviderPlugins = () => {
                        this.uppy.iteratePlugins((plugin => {
                            if (plugin && !plugin.target && plugin.opts && plugin.opts.target === this.constructor) this.addTarget(plugin);
                        }));
                    };
                    this.install = () => {
                        this.setPluginState({
                            isHidden: true,
                            fileCardFor: null,
                            activeOverlayType: null,
                            showAddFilesPanel: false,
                            activePickerPanel: false,
                            showFileEditor: false,
                            metaFields: this.opts.metaFields,
                            targets: [],
                            areInsidesReadyToBeVisible: false,
                            isDraggingOver: false
                        });
                        const {inline, closeAfterFinish} = this.opts;
                        if (inline && closeAfterFinish) throw new Error("[Dashboard] `closeAfterFinish: true` cannot be used on an inline Dashboard, because an inline Dashboard cannot be closed at all. Either set `inline: false`, or disable the `closeAfterFinish` option.");
                        const {allowMultipleUploads, allowMultipleUploadBatches} = this.uppy.opts;
                        if ((allowMultipleUploads || allowMultipleUploadBatches) && closeAfterFinish) this.uppy.log("[Dashboard] When using `closeAfterFinish`, we recommended setting the `allowMultipleUploadBatches` option to `false` in the Uppy constructor. See https://uppy.io/docs/uppy/#allowMultipleUploads-true", "warning");
                        const {target} = this.opts;
                        if (target) this.mount(target, this);
                        const plugins = this.opts.plugins || [];
                        plugins.forEach((pluginID => {
                            const plugin = this.uppy.getPlugin(pluginID);
                            if (plugin) plugin.mount(this, plugin);
                        }));
                        if (!this.opts.disableStatusBar) this.uppy.use(StatusBar, {
                            id: `${this.id}:StatusBar`,
                            target: this,
                            hideUploadButton: this.opts.hideUploadButton,
                            hideRetryButton: this.opts.hideRetryButton,
                            hidePauseResumeButton: this.opts.hidePauseResumeButton,
                            hideCancelButton: this.opts.hideCancelButton,
                            showProgressDetails: this.opts.showProgressDetails,
                            hideAfterFinish: this.opts.hideProgressAfterFinish,
                            locale: this.opts.locale,
                            doneButtonHandler: this.opts.doneButtonHandler
                        });
                        if (!this.opts.disableInformer) this.uppy.use(Informer, {
                            id: `${this.id}:Informer`,
                            target: this
                        });
                        if (!this.opts.disableThumbnailGenerator) this.uppy.use(ThumbnailGenerator, {
                            id: `${this.id}:ThumbnailGenerator`,
                            thumbnailWidth: this.opts.thumbnailWidth,
                            thumbnailHeight: this.opts.thumbnailHeight,
                            thumbnailType: this.opts.thumbnailType,
                            waitForThumbnailsBeforeUpload: this.opts.waitForThumbnailsBeforeUpload,
                            lazy: !this.opts.waitForThumbnailsBeforeUpload
                        });
                        this.darkModeMediaQuery = "undefined" !== typeof window && window.matchMedia ? window.matchMedia("(prefers-color-scheme: dark)") : null;
                        const isDarkModeOnFromTheStart = this.darkModeMediaQuery ? this.darkModeMediaQuery.matches : false;
                        this.uppy.log(`[Dashboard] Dark mode is ${isDarkModeOnFromTheStart ? "on" : "off"}`);
                        this.setDarkModeCapability(isDarkModeOnFromTheStart);
                        if ("auto" === this.opts.theme) this.darkModeMediaQuery.addListener(this.handleSystemDarkModeChange);
                        this.discoverProviderPlugins();
                        this.initEvents();
                    };
                    this.uninstall = () => {
                        if (!this.opts.disableInformer) {
                            const informer = this.uppy.getPlugin(`${this.id}:Informer`);
                            if (informer) this.uppy.removePlugin(informer);
                        }
                        if (!this.opts.disableStatusBar) {
                            const statusBar = this.uppy.getPlugin(`${this.id}:StatusBar`);
                            if (statusBar) this.uppy.removePlugin(statusBar);
                        }
                        if (!this.opts.disableThumbnailGenerator) {
                            const thumbnail = this.uppy.getPlugin(`${this.id}:ThumbnailGenerator`);
                            if (thumbnail) this.uppy.removePlugin(thumbnail);
                        }
                        const plugins = this.opts.plugins || [];
                        plugins.forEach((pluginID => {
                            const plugin = this.uppy.getPlugin(pluginID);
                            if (plugin) plugin.unmount();
                        }));
                        if ("auto" === this.opts.theme) this.darkModeMediaQuery.removeListener(this.handleSystemDarkModeChange);
                        this.unmount();
                        this.removeEvents();
                    };
                    this.id = this.opts.id || "Dashboard";
                    this.title = "Dashboard";
                    this.type = "orchestrator";
                    this.modalName = `uppy-Dashboard-${nanoid()}`;
                    this.defaultLocale = locale;
                    const defaultOptions = {
                        target: "body",
                        metaFields: [],
                        trigger: null,
                        inline: false,
                        width: 750,
                        height: 550,
                        thumbnailWidth: 280,
                        thumbnailType: "image/jpeg",
                        waitForThumbnailsBeforeUpload: false,
                        defaultPickerIcon,
                        showLinkToFileUploadResult: false,
                        showProgressDetails: false,
                        hideUploadButton: false,
                        hideCancelButton: false,
                        hideRetryButton: false,
                        hidePauseResumeButton: false,
                        hideProgressAfterFinish: false,
                        doneButtonHandler: () => {
                            this.uppy.reset();
                            this.requestCloseModal();
                        },
                        note: null,
                        closeModalOnClickOutside: false,
                        closeAfterFinish: false,
                        disableStatusBar: false,
                        disableInformer: false,
                        disableThumbnailGenerator: false,
                        disablePageScrollWhenModalOpen: true,
                        animateOpenClose: true,
                        fileManagerSelectionType: "files",
                        proudlyDisplayPoweredByUppy: true,
                        onRequestCloseModal: () => this.closeModal(),
                        showSelectedFiles: true,
                        showRemoveButtonAfterComplete: false,
                        browserBackButtonClose: false,
                        theme: "light",
                        autoOpenFileEditor: false,
                        disabled: false,
                        disableLocalFiles: false
                    };
                    this.opts = {
                        ...defaultOptions,
                        ..._opts
                    };
                    this.i18nInit();
                    this.superFocus = createSuperFocus();
                    this.ifFocusedOnUppyRecently = false;
                    this.makeDashboardInsidesVisibleAnywayTimeout = null;
                    this.removeDragOverClassTimeout = null;
                }
                onMount() {
                    const element = this.el;
                    const direction = getTextDirection(element);
                    if (!direction) element.dir = "ltr";
                }
            }), _class.VERSION = "2.1.4", _temp);
        },
        5233: module => {
            module.exports = {
                strings: {
                    closeModal: "Close Modal",
                    addMoreFiles: "Add more files",
                    addingMoreFiles: "Adding more files",
                    importFrom: "Import from %{name}",
                    dashboardWindowTitle: "Uppy Dashboard Window (Press escape to close)",
                    dashboardTitle: "Uppy Dashboard",
                    copyLinkToClipboardSuccess: "Link copied to clipboard.",
                    copyLinkToClipboardFallback: "Copy the URL below",
                    copyLink: "Copy link",
                    back: "Back",
                    removeFile: "Remove file",
                    editFile: "Edit file",
                    editing: "Editing %{file}",
                    finishEditingFile: "Finish editing file",
                    saveChanges: "Save changes",
                    myDevice: "My Device",
                    dropHint: "Drop your files here",
                    uploadComplete: "Upload complete",
                    uploadPaused: "Upload paused",
                    resumeUpload: "Resume upload",
                    pauseUpload: "Pause upload",
                    retryUpload: "Retry upload",
                    cancelUpload: "Cancel upload",
                    xFilesSelected: {
                        0: "%{smart_count} file selected",
                        1: "%{smart_count} files selected"
                    },
                    uploadingXFiles: {
                        0: "Uploading %{smart_count} file",
                        1: "Uploading %{smart_count} files"
                    },
                    processingXFiles: {
                        0: "Processing %{smart_count} file",
                        1: "Processing %{smart_count} files"
                    },
                    poweredBy: "Powered by %{uppy}",
                    addMore: "Add more",
                    editFileWithFilename: "Edit file %{file}",
                    save: "Save",
                    cancel: "Cancel",
                    dropPasteFiles: "Drop files here or %{browseFiles}",
                    dropPasteFolders: "Drop files here or %{browseFolders}",
                    dropPasteBoth: "Drop files here, %{browseFiles} or %{browseFolders}",
                    dropPasteImportFiles: "Drop files here, %{browseFiles} or import from:",
                    dropPasteImportFolders: "Drop files here, %{browseFolders} or import from:",
                    dropPasteImportBoth: "Drop files here, %{browseFiles}, %{browseFolders} or import from:",
                    importFiles: "Import files from:",
                    browseFiles: "browse files",
                    browseFolders: "browse folders",
                    recoveredXFiles: {
                        0: "We could not fully recover 1 file. Please re-select it and resume the upload.",
                        1: "We could not fully recover %{smart_count} files. Please re-select them and resume the upload."
                    },
                    recoveredAllFiles: "We restored all files. You can now resume the upload.",
                    sessionRestored: "Session restored",
                    reSelect: "Re-select",
                    missingRequiredMetaFields: {
                        0: "Missing required meta field: %{fields}.",
                        1: "Missing required meta fields: %{fields}."
                    }
                }
            };
        },
        818: module => {
            module.exports = function copyToClipboard(textToCopy, fallbackString) {
                fallbackString = fallbackString || "Copy the URL below";
                return new Promise((resolve => {
                    const textArea = document.createElement("textarea");
                    textArea.setAttribute("style", {
                        position: "fixed",
                        top: 0,
                        left: 0,
                        width: "2em",
                        height: "2em",
                        padding: 0,
                        border: "none",
                        outline: "none",
                        boxShadow: "none",
                        background: "transparent"
                    });
                    textArea.value = textToCopy;
                    document.body.appendChild(textArea);
                    textArea.select();
                    const magicCopyFailed = () => {
                        document.body.removeChild(textArea);
                        window.prompt(fallbackString, textToCopy);
                        resolve();
                    };
                    try {
                        const successful = document.execCommand("copy");
                        if (!successful) return magicCopyFailed("copy command unavailable");
                        document.body.removeChild(textArea);
                        return resolve();
                    } catch (err) {
                        document.body.removeChild(textArea);
                        return magicCopyFailed(err);
                    }
                }));
            };
        },
        6673: (module, __unused_webpack_exports, __webpack_require__) => {
            const debounce = __webpack_require__(1296);
            const FOCUSABLE_ELEMENTS = __webpack_require__(9045);
            const getActiveOverlayEl = __webpack_require__(6470);
            module.exports = function createSuperFocus() {
                let lastFocusWasOnSuperFocusableEl = false;
                const superFocus = (dashboardEl, activeOverlayType) => {
                    const overlayEl = getActiveOverlayEl(dashboardEl, activeOverlayType);
                    const isFocusInOverlay = overlayEl.contains(document.activeElement);
                    if (isFocusInOverlay && lastFocusWasOnSuperFocusableEl) return;
                    const superFocusableEl = overlayEl.querySelector("[data-uppy-super-focusable]");
                    if (isFocusInOverlay && !superFocusableEl) return;
                    if (superFocusableEl) {
                        superFocusableEl.focus({
                            preventScroll: true
                        });
                        lastFocusWasOnSuperFocusableEl = true;
                    } else {
                        const firstEl = overlayEl.querySelector(FOCUSABLE_ELEMENTS);
                        null == firstEl ? void 0 : firstEl.focus({
                            preventScroll: true
                        });
                        lastFocusWasOnSuperFocusableEl = false;
                    }
                };
                return debounce(superFocus, 260);
            };
        },
        6470: module => {
            module.exports = function getActiveOverlayEl(dashboardEl, activeOverlayType) {
                if (activeOverlayType) {
                    const overlayEl = dashboardEl.querySelector(`[data-uppy-paneltype="${activeOverlayType}"]`);
                    if (overlayEl) return overlayEl;
                }
                return dashboardEl;
            };
        },
        1882: (module, __unused_webpack_exports, __webpack_require__) => {
            const {h} = __webpack_require__(6400);
            function iconImage() {
                return h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    width: "25",
                    height: "25",
                    viewBox: "0 0 25 25"
                }, h("g", {
                    fill: "#686DE0",
                    fillRule: "evenodd"
                }, h("path", {
                    d: "M5 7v10h15V7H5zm0-1h15a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1z",
                    fillRule: "nonzero"
                }), h("path", {
                    d: "M6.35 17.172l4.994-5.026a.5.5 0 0 1 .707 0l2.16 2.16 3.505-3.505a.5.5 0 0 1 .707 0l2.336 2.31-.707.72-1.983-1.97-3.505 3.505a.5.5 0 0 1-.707 0l-2.16-2.159-3.938 3.939-1.409.026z",
                    fillRule: "nonzero"
                }), h("circle", {
                    cx: "7.5",
                    cy: "9.5",
                    r: "1.5"
                })));
            }
            function iconAudio() {
                return h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    className: "uppy-c-icon",
                    width: "25",
                    height: "25",
                    viewBox: "0 0 25 25"
                }, h("path", {
                    d: "M9.5 18.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V7.25a.5.5 0 0 1 .379-.485l9-2.25A.5.5 0 0 1 18.5 5v11.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V8.67l-8 2v7.97zm8-11v-2l-8 2v2l8-2zM7 19.64c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1zm9-2c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1z",
                    fill: "#049BCF",
                    fillRule: "nonzero"
                }));
            }
            function iconVideo() {
                return h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    className: "uppy-c-icon",
                    width: "25",
                    height: "25",
                    viewBox: "0 0 25 25"
                }, h("path", {
                    d: "M16 11.834l4.486-2.691A1 1 0 0 1 22 10v6a1 1 0 0 1-1.514.857L16 14.167V17a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2.834zM15 9H5v8h10V9zm1 4l5 3v-6l-5 3z",
                    fill: "#19AF67",
                    fillRule: "nonzero"
                }));
            }
            function iconPDF() {
                return h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    className: "uppy-c-icon",
                    width: "25",
                    height: "25",
                    viewBox: "0 0 25 25"
                }, h("path", {
                    d: "M9.766 8.295c-.691-1.843-.539-3.401.747-3.726 1.643-.414 2.505.938 2.39 3.299-.039.79-.194 1.662-.537 3.148.324.49.66.967 1.055 1.51.17.231.382.488.629.757 1.866-.128 3.653.114 4.918.655 1.487.635 2.192 1.685 1.614 2.84-.566 1.133-1.839 1.084-3.416.249-1.141-.604-2.457-1.634-3.51-2.707a13.467 13.467 0 0 0-2.238.426c-1.392 4.051-4.534 6.453-5.707 4.572-.986-1.58 1.38-4.206 4.914-5.375.097-.322.185-.656.264-1.001.08-.353.306-1.31.407-1.737-.678-1.059-1.2-2.031-1.53-2.91zm2.098 4.87c-.033.144-.068.287-.104.427l.033-.01-.012.038a14.065 14.065 0 0 1 1.02-.197l-.032-.033.052-.004a7.902 7.902 0 0 1-.208-.271c-.197-.27-.38-.526-.555-.775l-.006.028-.002-.003c-.076.323-.148.632-.186.8zm5.77 2.978c1.143.605 1.832.632 2.054.187.26-.519-.087-1.034-1.113-1.473-.911-.39-2.175-.608-3.55-.608.845.766 1.787 1.459 2.609 1.894zM6.559 18.789c.14.223.693.16 1.425-.413.827-.648 1.61-1.747 2.208-3.206-2.563 1.064-4.102 2.867-3.633 3.62zm5.345-10.97c.088-1.793-.351-2.48-1.146-2.28-.473.119-.564 1.05-.056 2.405.213.566.52 1.188.908 1.859.18-.858.268-1.453.294-1.984z",
                    fill: "#E2514A",
                    fillRule: "nonzero"
                }));
            }
            function iconArchive() {
                return h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    width: "25",
                    height: "25",
                    viewBox: "0 0 25 25"
                }, h("path", {
                    d: "M10.45 2.05h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V2.55a.5.5 0 0 1 .5-.5zm2.05 1.024h1.05a.5.5 0 0 1 .5.5V3.6a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5v-.001zM10.45 0h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 3.074h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 1.024h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm-2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-1.656 3.074l-.82 5.946c.52.302 1.174.458 1.976.458.803 0 1.455-.156 1.975-.458l-.82-5.946h-2.311zm0-1.025h2.312c.512 0 .946.378 1.015.885l.82 5.946c.056.412-.142.817-.501 1.026-.686.398-1.515.597-2.49.597-.974 0-1.804-.199-2.49-.597a1.025 1.025 0 0 1-.5-1.026l.819-5.946c.07-.507.503-.885 1.015-.885zm.545 6.6a.5.5 0 0 1-.397-.561l.143-.999a.5.5 0 0 1 .495-.429h.74a.5.5 0 0 1 .495.43l.143.998a.5.5 0 0 1-.397.561c-.404.08-.819.08-1.222 0z",
                    fill: "#00C469",
                    fillRule: "nonzero"
                }));
            }
            function iconFile() {
                return h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    className: "uppy-c-icon",
                    width: "25",
                    height: "25",
                    viewBox: "0 0 25 25"
                }, h("g", {
                    fill: "#A7AFB7",
                    fillRule: "nonzero"
                }, h("path", {
                    d: "M5.5 22a.5.5 0 0 1-.5-.5v-18a.5.5 0 0 1 .5-.5h10.719a.5.5 0 0 1 .367.16l3.281 3.556a.5.5 0 0 1 .133.339V21.5a.5.5 0 0 1-.5.5h-14zm.5-1h13V7.25L16 4H6v17z"
                }), h("path", {
                    d: "M15 4v3a1 1 0 0 0 1 1h3V7h-3V4h-1z"
                })));
            }
            function iconText() {
                return h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    className: "uppy-c-icon",
                    width: "25",
                    height: "25",
                    viewBox: "0 0 25 25"
                }, h("path", {
                    d: "M4.5 7h13a.5.5 0 1 1 0 1h-13a.5.5 0 0 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h10a.5.5 0 1 1 0 1h-10a.5.5 0 1 1 0-1z",
                    fill: "#5A5E69",
                    fillRule: "nonzero"
                }));
            }
            module.exports = function getIconByMime(fileType) {
                const defaultChoice = {
                    color: "#838999",
                    icon: iconFile()
                };
                if (!fileType) return defaultChoice;
                const fileTypeGeneral = fileType.split("/")[0];
                const fileTypeSpecific = fileType.split("/")[1];
                if ("text" === fileTypeGeneral) return {
                    color: "#5a5e69",
                    icon: iconText()
                };
                if ("image" === fileTypeGeneral) return {
                    color: "#686de0",
                    icon: iconImage()
                };
                if ("audio" === fileTypeGeneral) return {
                    color: "#068dbb",
                    icon: iconAudio()
                };
                if ("video" === fileTypeGeneral) return {
                    color: "#19af67",
                    icon: iconVideo()
                };
                if ("application" === fileTypeGeneral && "pdf" === fileTypeSpecific) return {
                    color: "#e25149",
                    icon: iconPDF()
                };
                const archiveTypes = [ "zip", "x-7z-compressed", "x-rar-compressed", "x-tar", "x-gzip", "x-apple-diskimage" ];
                if ("application" === fileTypeGeneral && -1 !== archiveTypes.indexOf(fileTypeSpecific)) return {
                    color: "#00C469",
                    icon: iconArchive()
                };
                return defaultChoice;
            };
        },
        8805: module => {
            function ignoreEvent(ev) {
                const {tagName} = ev.target;
                if ("INPUT" === tagName || "TEXTAREA" === tagName) {
                    ev.stopPropagation();
                    return;
                }
                ev.preventDefault();
                ev.stopPropagation();
            }
            module.exports = ignoreEvent;
        },
        3962: (module, __unused_webpack_exports, __webpack_require__) => {
            const toArray = __webpack_require__(6361);
            const FOCUSABLE_ELEMENTS = __webpack_require__(9045);
            const getActiveOverlayEl = __webpack_require__(6470);
            function focusOnFirstNode(event, nodes) {
                const node = nodes[0];
                if (node) {
                    node.focus();
                    event.preventDefault();
                }
            }
            function focusOnLastNode(event, nodes) {
                const node = nodes[nodes.length - 1];
                if (node) {
                    node.focus();
                    event.preventDefault();
                }
            }
            function isFocusInOverlay(activeOverlayEl) {
                return activeOverlayEl.contains(document.activeElement);
            }
            function trapFocus(event, activeOverlayType, dashboardEl) {
                const activeOverlayEl = getActiveOverlayEl(dashboardEl, activeOverlayType);
                const focusableNodes = toArray(activeOverlayEl.querySelectorAll(FOCUSABLE_ELEMENTS));
                const focusedItemIndex = focusableNodes.indexOf(document.activeElement);
                if (!isFocusInOverlay(activeOverlayEl)) focusOnFirstNode(event, focusableNodes); else if (event.shiftKey && 0 === focusedItemIndex) focusOnLastNode(event, focusableNodes); else if (!event.shiftKey && focusedItemIndex === focusableNodes.length - 1) focusOnFirstNode(event, focusableNodes);
            }
            module.exports = {
                forModal: (event, activeOverlayType, dashboardEl) => {
                    trapFocus(event, activeOverlayType, dashboardEl);
                },
                forInline: (event, activeOverlayType, dashboardEl) => {
                    if (null === activeOverlayType) ; else trapFocus(event, activeOverlayType, dashboardEl);
                }
            };
        },
        1623: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const {h, Component, createRef} = __webpack_require__(6400);
            const TRANSITION_MS = 300;
            module.exports = class FadeIn extends Component {
                constructor() {
                    super(...arguments);
                    this.ref = createRef();
                }
                componentWillEnter(callback) {
                    this.ref.current.style.opacity = "1";
                    this.ref.current.style.transform = "none";
                    setTimeout(callback, TRANSITION_MS);
                }
                componentWillLeave(callback) {
                    this.ref.current.style.opacity = "0";
                    this.ref.current.style.transform = "translateY(350%)";
                    setTimeout(callback, TRANSITION_MS);
                }
                render() {
                    const {children} = this.props;
                    return h("div", {
                        className: "uppy-Informer-animated",
                        ref: this.ref
                    }, children);
                }
            };
        },
        6455: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const {Component, cloneElement, h, toChildArray} = __webpack_require__(6400);
            function assign(obj, props) {
                return Object.assign(obj, props);
            }
            function getKey(vnode, fallback) {
                var _vnode$key;
                return null != (_vnode$key = null == vnode ? void 0 : vnode.key) ? _vnode$key : fallback;
            }
            function linkRef(component, name) {
                const cache = component._ptgLinkedRefs || (component._ptgLinkedRefs = {});
                return cache[name] || (cache[name] = c => {
                    component.refs[name] = c;
                });
            }
            function getChildMapping(children) {
                const out = {};
                for (let i = 0; i < children.length; i++) if (null != children[i]) {
                    const key = getKey(children[i], i.toString(36));
                    out[key] = children[i];
                }
                return out;
            }
            function mergeChildMappings(prev, next) {
                prev = prev || {};
                next = next || {};
                const getValueForKey = key => next.hasOwnProperty(key) ? next[key] : prev[key];
                const nextKeysPending = {};
                let pendingKeys = [];
                for (const prevKey in prev) if (next.hasOwnProperty(prevKey)) {
                    if (pendingKeys.length) {
                        nextKeysPending[prevKey] = pendingKeys;
                        pendingKeys = [];
                    }
                } else pendingKeys.push(prevKey);
                const childMapping = {};
                for (const nextKey in next) {
                    if (nextKeysPending.hasOwnProperty(nextKey)) for (let i = 0; i < nextKeysPending[nextKey].length; i++) {
                        const pendingNextKey = nextKeysPending[nextKey][i];
                        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
                    }
                    childMapping[nextKey] = getValueForKey(nextKey);
                }
                for (let i = 0; i < pendingKeys.length; i++) childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
                return childMapping;
            }
            const identity = i => i;
            class TransitionGroup extends Component {
                constructor(props, context) {
                    super(props, context);
                    this.refs = {};
                    this.state = {
                        children: getChildMapping(toChildArray(toChildArray(this.props.children)) || [])
                    };
                    this.performAppear = this.performAppear.bind(this);
                    this.performEnter = this.performEnter.bind(this);
                    this.performLeave = this.performLeave.bind(this);
                }
                componentWillMount() {
                    this.currentlyTransitioningKeys = {};
                    this.keysToAbortLeave = [];
                    this.keysToEnter = [];
                    this.keysToLeave = [];
                }
                componentDidMount() {
                    const initialChildMapping = this.state.children;
                    for (const key in initialChildMapping) if (initialChildMapping[key]) this.performAppear(key);
                }
                componentWillReceiveProps(nextProps) {
                    const nextChildMapping = getChildMapping(toChildArray(nextProps.children) || []);
                    const prevChildMapping = this.state.children;
                    this.setState((prevState => ({
                        children: mergeChildMappings(prevState.children, nextChildMapping)
                    })));
                    let key;
                    for (key in nextChildMapping) if (nextChildMapping.hasOwnProperty(key)) {
                        const hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);
                        if (nextChildMapping[key] && hasPrev && this.currentlyTransitioningKeys[key]) {
                            this.keysToEnter.push(key);
                            this.keysToAbortLeave.push(key);
                        } else if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) this.keysToEnter.push(key);
                    }
                    for (key in prevChildMapping) if (prevChildMapping.hasOwnProperty(key)) {
                        const hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);
                        if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) this.keysToLeave.push(key);
                    }
                }
                componentDidUpdate() {
                    const {keysToEnter} = this;
                    this.keysToEnter = [];
                    keysToEnter.forEach(this.performEnter);
                    const {keysToLeave} = this;
                    this.keysToLeave = [];
                    keysToLeave.forEach(this.performLeave);
                }
                _finishAbort(key) {
                    const idx = this.keysToAbortLeave.indexOf(key);
                    if (-1 !== idx) this.keysToAbortLeave.splice(idx, 1);
                }
                performAppear(key) {
                    this.currentlyTransitioningKeys[key] = true;
                    const component = this.refs[key];
                    if (component.componentWillAppear) component.componentWillAppear(this._handleDoneAppearing.bind(this, key)); else this._handleDoneAppearing(key);
                }
                _handleDoneAppearing(key) {
                    const component = this.refs[key];
                    if (component.componentDidAppear) component.componentDidAppear();
                    delete this.currentlyTransitioningKeys[key];
                    this._finishAbort(key);
                    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);
                    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) this.performLeave(key);
                }
                performEnter(key) {
                    this.currentlyTransitioningKeys[key] = true;
                    const component = this.refs[key];
                    if (component.componentWillEnter) component.componentWillEnter(this._handleDoneEntering.bind(this, key)); else this._handleDoneEntering(key);
                }
                _handleDoneEntering(key) {
                    const component = this.refs[key];
                    if (component.componentDidEnter) component.componentDidEnter();
                    delete this.currentlyTransitioningKeys[key];
                    this._finishAbort(key);
                    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);
                    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) this.performLeave(key);
                }
                performLeave(key) {
                    const idx = this.keysToAbortLeave.indexOf(key);
                    if (-1 !== idx) return;
                    this.currentlyTransitioningKeys[key] = true;
                    const component = this.refs[key];
                    if (component.componentWillLeave) component.componentWillLeave(this._handleDoneLeaving.bind(this, key)); else this._handleDoneLeaving(key);
                }
                _handleDoneLeaving(key) {
                    const idx = this.keysToAbortLeave.indexOf(key);
                    if (-1 !== idx) return;
                    const component = this.refs[key];
                    if (component.componentDidLeave) component.componentDidLeave();
                    delete this.currentlyTransitioningKeys[key];
                    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);
                    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) this.performEnter(key); else {
                        const children = assign({}, this.state.children);
                        delete children[key];
                        this.setState({
                            children
                        });
                    }
                }
                render(_ref, _ref2) {
                    let {childFactory, transitionLeave, transitionName, transitionAppear, transitionEnter, transitionLeaveTimeout, transitionEnterTimeout, transitionAppearTimeout, component, ...props} = _ref;
                    let {children} = _ref2;
                    const childrenToRender = [];
                    for (const key in children) if (children.hasOwnProperty(key)) {
                        const child = children[key];
                        if (child) {
                            const ref = linkRef(this, key), el = cloneElement(childFactory(child), {
                                ref,
                                key
                            });
                            childrenToRender.push(el);
                        }
                    }
                    return h(component, props, childrenToRender);
                }
            }
            TransitionGroup.defaultProps = {
                component: "span",
                childFactory: identity
            };
            module.exports = TransitionGroup;
        },
        873: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var _class, _temp;
            const {h} = __webpack_require__(6400);
            const {UIPlugin} = __webpack_require__(9429);
            const FadeIn = __webpack_require__(1623);
            const TransitionGroup = __webpack_require__(6455);
            module.exports = (_temp = _class = class Informer extends UIPlugin {
                constructor(uppy, opts) {
                    super(uppy, opts);
                    this.render = state => h("div", {
                        className: "uppy uppy-Informer"
                    }, h(TransitionGroup, null, state.info.map((info => h(FadeIn, {
                        key: info.message
                    }, h("p", {
                        role: "alert"
                    }, info.message, " ", info.details && h("span", {
                        "aria-label": info.details,
                        "data-microtip-position": "top-left",
                        "data-microtip-size": "medium",
                        role: "tooltip",
                        onClick: () => alert(`${info.message} \n\n ${info.details}`)
                    }, "?")))))));
                    this.type = "progressindicator";
                    this.id = this.opts.id || "Informer";
                    this.title = "Informer";
                    const defaultOptions = {};
                    this.opts = {
                        ...defaultOptions,
                        ...opts
                    };
                }
                install() {
                    const {target} = this.opts;
                    if (target) this.mount(target, this);
                }
            }, _class.VERSION = "2.0.5", _temp);
        },
        4811: module => {
            const ru_RU = {};
            ru_RU.strings = {
                addMoreFiles: "Добавить еще файлы",
                addingMoreFiles: "Добавление дополнительных файлов",
                allowAccessDescription: "Чтобы сделать фото или видео, пожалуйста, разрешите доступ к камере для этого сайта",
                allowAccessTitle: "Пожалуйста, разрешите доступ к вашей камере",
                authenticateWithTitle: "Пожалуйста, авторизуйтесь в %{pluginName}, чтобы выбрать файлы",
                authenticateWith: "Подключиться к %{pluginName}",
                back: "Назад",
                addMore: "Добавить еще",
                browse: "выберите",
                browseFiles: "выберите",
                cancel: "Отменить",
                cancelUpload: "Отменить загрузку",
                chooseFiles: "Выбрать файлы",
                closeModal: "Закрыть окно",
                companionError: "Не удалось подключиться к Companion",
                complete: "Готово",
                connectedToInternet: "Подключено к интернету",
                copyLink: "Скопировать ссылку",
                copyLinkToClipboardFallback: "Скопируйте ссылку",
                copyLinkToClipboardSuccess: "Ссылка скопирована в буфер обмена",
                creatingAssembly: "Подготовка загрузки...",
                creatingAssemblyFailed: "Transloadit: не удалось создать Assembly",
                dashboardTitle: "Загрузчик файлов",
                dashboardWindowTitle: "Окно загрузчика файлов (нажмите escape, чтобы закрыть)",
                dataUploadedOfTotal: "%{complete} из %{total}",
                done: "Готово",
                dropHereOr: "Перетащите файлы или %{browse}",
                dropHint: "Перетащите файлы сюда",
                dropPasteBoth: "Перетащите файлы, вставьте или %{browse}",
                dropPasteFiles: "Перетащите файлы, вставьте или %{browse}",
                dropPasteFolders: "Перетащите файлы, вставьте или %{browse}",
                dropPasteImportBoth: "Перетащите файлы, вставьте, %{browse} или импортируйте из:",
                dropPasteImportFiles: "Перетащите файлы, вставьте, %{browse} или импортируйте из:",
                dropPasteImportFolders: "Перетащите файлы, вставьте, %{browse} или импортируйте из:",
                editFile: "Редактировать файл",
                editing: "Редактируется %{file}",
                emptyFolderAdded: "Файлы не были добавлены — папка пуста",
                encoding: "Обработка...",
                enterCorrectUrl: "Неправильный адрес: пожалуйста, убедитесь что вы используете прямую ссылку на файл",
                enterUrlToImport: "Введите адрес, чтобы импортировать файл",
                exceedsSize: "Этот файл больше максимально разрешенного размера в %{size}",
                failedToFetch: "Companion не смог загрузить файл по ссылке, пожалуйста, убедитесь, что адрес верный",
                failedToUpload: "Ошибка загрузки %{file}",
                fileSource: "Источник файла: %{name}",
                filesUploadedOfTotal: {
                    0: "%{complete} из %{smart_count} файла загружено",
                    1: "%{complete} из %{smart_count} файлов загружено",
                    2: "%{complete} из %{smart_count} файлов загружено"
                },
                filter: "Фильтр",
                finishEditingFile: "Закончить редактирование файла",
                folderAdded: {
                    0: "Добавлен %{smart_count} файл из %{folder}",
                    1: "Добавлено %{smart_count} файла из %{folder}",
                    2: "Добавлено %{smart_count} файлов из %{folder}"
                },
                import: "Импортировать",
                importFrom: "Импортировать из %{name}",
                loading: "Загрузка...",
                logOut: "Выйти",
                myDevice: "Мое устройство",
                noFilesFound: "Здесь нет файлов или папок",
                noInternetConnection: "Нет подключения к интернету",
                pause: "Поставить на паузу",
                pauseUpload: "Поставить загрузку на паузу",
                paused: "На паузе",
                processingXFiles: {
                    0: "Обрабатывается %{smart_count} файл",
                    1: "Обрабатываются %{smart_count} файла",
                    2: "Обрабатываются %{smart_count} файлов"
                },
                poweredBy: "Работает на %{uppy}",
                removeFile: "Удалить файл",
                resetFilter: "Сбросить фильтр",
                resume: "Продолжить",
                resumeUpload: "Продолжить загрузку",
                retry: "Повторить попытку",
                retryUpload: "Повторить попытку загрузки",
                save: "Сохранить",
                saveChanges: "Сохранить",
                selectX: {
                    0: "Выбрать %{smart_count}",
                    1: "Выбрать %{smart_count}",
                    2: "Выбрать %{smart_count}"
                },
                smile: "Улыбнитесь!",
                startRecording: "Начать запись видео",
                stopRecording: "Закончить запись видео",
                takePicture: "Сделать фотографию",
                timedOut: "Загрузка остановилась на %{seconds} секунд, отмена",
                upload: "Загрузить",
                uploadComplete: "Загрузка завершена",
                uploadFailed: "Загрузка не удалась",
                uploadPaused: "Загрузка на паузе",
                uploadXFiles: {
                    0: "Загрузить %{smart_count} файл",
                    1: "Загрузить %{smart_count} файла",
                    2: "Загрузить %{smart_count} файлов"
                },
                uploadXNewFiles: {
                    0: "Загрузить +%{smart_count} файл",
                    1: "Загрузить +%{smart_count} файла",
                    2: "Загрузить +%{smart_count} файлов"
                },
                uploading: "Загрузка",
                uploadingXFiles: {
                    0: "Загружается %{smart_count} файл",
                    1: "Загружается %{smart_count} файла",
                    2: "Загружается %{smart_count} файлов"
                },
                xFilesSelected: {
                    0: "%{smart_count} файл выбран",
                    1: "%{smart_count} файла выбрано",
                    2: "%{smart_count} файлов выбрано"
                },
                xMoreFilesAdded: {
                    0: "%{smart_count} дополнительный файл добавлен",
                    1: "%{smart_count} дополнительных файла добавлено",
                    2: "%{smart_count} дополнительных файлов добавлено"
                },
                xTimeLeft: "осталось %{time}",
                youCanOnlyUploadFileTypes: "Вы можете загрузить только: %{types}",
                youCanOnlyUploadX: {
                    0: "Вы можете загрузить только %{smart_count} файл",
                    1: "Вы можете загрузить только %{smart_count} файла",
                    2: "Вы можете загрузить только %{smart_count} файлов"
                },
                youHaveToAtLeastSelectX: {
                    0: "Вы должны выбрать хотя бы %{smart_count} файл",
                    1: "Вы должны выбрать хотя бы %{smart_count} файла",
                    2: "Вы должны выбрать хотя бы %{smart_count} файлов"
                },
                selectFileNamed: "Выбрать файл %{name}",
                unselectFileNamed: "Отменить выбор файла %{name}",
                openFolderNamed: "Открыть папку %{name}"
            };
            ru_RU.pluralize = function pluralize(n) {
                if (n % 10 === 1 && n % 100 !== 11) return 0;
                if (n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20)) return 1;
                return 2;
            };
            if ("undefined" !== typeof window && "undefined" !== typeof window.Uppy) window.Uppy.locales.ru_RU = ru_RU;
            module.exports = ru_RU;
        },
        4049: (module, __unused_webpack_exports, __webpack_require__) => {
            const classNames = __webpack_require__(4184);
            const throttle = __webpack_require__(3096);
            const prettierBytes = __webpack_require__(5158);
            const prettyETA = __webpack_require__(1011);
            const {h} = __webpack_require__(6400);
            const statusBarStates = __webpack_require__(3242);
            const DOT = `·`;
            const renderDot = () => ` ${DOT} `;
            function UploadBtn(props) {
                const {newFiles, isUploadStarted, recoveredState, i18n, uploadState, isSomeGhost, startUpload} = props;
                const uploadBtnClassNames = classNames("uppy-u-reset", "uppy-c-btn", "uppy-StatusBar-actionBtn", "uppy-StatusBar-actionBtn--upload", {
                    "uppy-c-btn-primary": uploadState === statusBarStates.STATE_WAITING
                }, {
                    "uppy-StatusBar-actionBtn--disabled": isSomeGhost
                });
                const uploadBtnText = newFiles && isUploadStarted && !recoveredState ? i18n("uploadXNewFiles", {
                    smart_count: newFiles
                }) : i18n("uploadXFiles", {
                    smart_count: newFiles
                });
                return h("button", {
                    type: "button",
                    className: uploadBtnClassNames,
                    "aria-label": i18n("uploadXFiles", {
                        smart_count: newFiles
                    }),
                    onClick: startUpload,
                    disabled: isSomeGhost,
                    "data-uppy-super-focusable": true
                }, uploadBtnText);
            }
            function RetryBtn(props) {
                const {i18n, uppy} = props;
                return h("button", {
                    type: "button",
                    className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--retry",
                    "aria-label": i18n("retryUpload"),
                    onClick: () => uppy.retryAll(),
                    "data-uppy-super-focusable": true
                }, h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    className: "uppy-c-icon",
                    width: "8",
                    height: "10",
                    viewBox: "0 0 8 10"
                }, h("path", {
                    d: "M4 2.408a2.75 2.75 0 1 0 2.75 2.75.626.626 0 0 1 1.25.018v.023a4 4 0 1 1-4-4.041V.25a.25.25 0 0 1 .389-.208l2.299 1.533a.25.25 0 0 1 0 .416l-2.3 1.533A.25.25 0 0 1 4 3.316v-.908z"
                })), i18n("retry"));
            }
            function CancelBtn(props) {
                const {i18n, uppy} = props;
                return h("button", {
                    type: "button",
                    className: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
                    title: i18n("cancel"),
                    "aria-label": i18n("cancel"),
                    onClick: () => uppy.cancelAll(),
                    "data-cy": "cancel",
                    "data-uppy-super-focusable": true
                }, h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    className: "uppy-c-icon",
                    width: "16",
                    height: "16",
                    viewBox: "0 0 16 16"
                }, h("g", {
                    fill: "none",
                    fillRule: "evenodd"
                }, h("circle", {
                    fill: "#888",
                    cx: "8",
                    cy: "8",
                    r: "8"
                }), h("path", {
                    fill: "#FFF",
                    d: "M9.283 8l2.567 2.567-1.283 1.283L8 9.283 5.433 11.85 4.15 10.567 6.717 8 4.15 5.433 5.433 4.15 8 6.717l2.567-2.567 1.283 1.283z"
                }))));
            }
            function PauseResumeButton(props) {
                const {isAllPaused, i18n, isAllComplete, resumableUploads, uppy} = props;
                const title = isAllPaused ? i18n("resume") : i18n("pause");
                function togglePauseResume() {
                    if (isAllComplete) return null;
                    if (!resumableUploads) return uppy.cancelAll();
                    if (isAllPaused) return uppy.resumeAll();
                    return uppy.pauseAll();
                }
                return h("button", {
                    title,
                    "aria-label": title,
                    className: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
                    type: "button",
                    onClick: togglePauseResume,
                    "data-uppy-super-focusable": true
                }, h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    className: "uppy-c-icon",
                    width: "16",
                    height: "16",
                    viewBox: "0 0 16 16"
                }, h("g", {
                    fill: "none",
                    fillRule: "evenodd"
                }, h("circle", {
                    fill: "#888",
                    cx: "8",
                    cy: "8",
                    r: "8"
                }), h("path", {
                    fill: "#FFF",
                    d: isAllPaused ? "M6 4.25L11.5 8 6 11.75z" : "M5 4.5h2v7H5v-7zm4 0h2v7H9v-7z"
                }))));
            }
            function DoneBtn(props) {
                const {i18n, doneButtonHandler} = props;
                return h("button", {
                    type: "button",
                    className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--done",
                    onClick: doneButtonHandler,
                    "data-uppy-super-focusable": true
                }, i18n("done"));
            }
            function LoadingSpinner() {
                return h("svg", {
                    className: "uppy-StatusBar-spinner",
                    "aria-hidden": "true",
                    focusable: "false",
                    width: "14",
                    height: "14"
                }, h("path", {
                    d: "M13.983 6.547c-.12-2.509-1.64-4.893-3.939-5.936-2.48-1.127-5.488-.656-7.556 1.094C.524 3.367-.398 6.048.162 8.562c.556 2.495 2.46 4.52 4.94 5.183 2.932.784 5.61-.602 7.256-3.015-1.493 1.993-3.745 3.309-6.298 2.868-2.514-.434-4.578-2.349-5.153-4.84a6.226 6.226 0 0 1 2.98-6.778C6.34.586 9.74 1.1 11.373 3.493c.407.596.693 1.282.842 1.988.127.598.073 1.197.161 1.794.078.525.543 1.257 1.15.864.525-.341.49-1.05.456-1.592-.007-.15.02.3 0 0",
                    fillRule: "evenodd"
                }));
            }
            function ProgressBarProcessing(props) {
                const {progress} = props;
                const {value, mode, message} = progress;
                const roundedValue = Math.round(100 * value);
                const dot = `·`;
                return h("div", {
                    className: "uppy-StatusBar-content"
                }, h(LoadingSpinner, null), "determinate" === mode ? `${roundedValue}% ${dot} ` : "", message);
            }
            function ProgressDetails(props) {
                const {numUploads, complete, totalUploadedSize, totalSize, totalETA, i18n} = props;
                const ifShowFilesUploadedOfTotal = numUploads > 1;
                return h("div", {
                    className: "uppy-StatusBar-statusSecondary"
                }, ifShowFilesUploadedOfTotal && i18n("filesUploadedOfTotal", {
                    complete,
                    smart_count: numUploads
                }), h("span", {
                    className: "uppy-StatusBar-additionalInfo"
                }, ifShowFilesUploadedOfTotal && renderDot(), i18n("dataUploadedOfTotal", {
                    complete: prettierBytes(totalUploadedSize),
                    total: prettierBytes(totalSize)
                }), renderDot(), i18n("xTimeLeft", {
                    time: prettyETA(totalETA)
                })));
            }
            function FileUploadCount(props) {
                const {i18n, complete, numUploads} = props;
                return h("div", {
                    className: "uppy-StatusBar-statusSecondary"
                }, i18n("filesUploadedOfTotal", {
                    complete,
                    smart_count: numUploads
                }));
            }
            function UploadNewlyAddedFiles(props) {
                const {i18n, newFiles, startUpload} = props;
                const uploadBtnClassNames = classNames("uppy-u-reset", "uppy-c-btn", "uppy-StatusBar-actionBtn", "uppy-StatusBar-actionBtn--uploadNewlyAdded");
                return h("div", {
                    className: "uppy-StatusBar-statusSecondary"
                }, h("div", {
                    className: "uppy-StatusBar-statusSecondaryHint"
                }, i18n("xMoreFilesAdded", {
                    smart_count: newFiles
                })), h("button", {
                    type: "button",
                    className: uploadBtnClassNames,
                    "aria-label": i18n("uploadXFiles", {
                        smart_count: newFiles
                    }),
                    onClick: startUpload
                }, i18n("upload")));
            }
            const ThrottledProgressDetails = throttle(ProgressDetails, 500, {
                leading: true,
                trailing: true
            });
            function ProgressBarUploading(props) {
                const {i18n, supportsUploadProgress, totalProgress, showProgressDetails, isUploadStarted, isAllComplete, isAllPaused, newFiles, numUploads, complete, totalUploadedSize, totalSize, totalETA, startUpload} = props;
                const showUploadNewlyAddedFiles = newFiles && isUploadStarted;
                if (!isUploadStarted || isAllComplete) return null;
                const title = isAllPaused ? i18n("paused") : i18n("uploading");
                function renderProgressDetails() {
                    if (!isAllPaused && !showUploadNewlyAddedFiles && showProgressDetails) {
                        if (supportsUploadProgress) return h(ThrottledProgressDetails, {
                            numUploads,
                            complete,
                            totalUploadedSize,
                            totalSize,
                            totalETA,
                            i18n
                        });
                        return h(FileUploadCount, {
                            i18n,
                            complete,
                            numUploads
                        });
                    }
                    return null;
                }
                return h("div", {
                    className: "uppy-StatusBar-content",
                    "aria-label": title,
                    title
                }, !isAllPaused ? h(LoadingSpinner, null) : null, h("div", {
                    className: "uppy-StatusBar-status"
                }, h("div", {
                    className: "uppy-StatusBar-statusPrimary"
                }, supportsUploadProgress ? `${title}: ${totalProgress}%` : title), renderProgressDetails(), showUploadNewlyAddedFiles ? h(UploadNewlyAddedFiles, {
                    i18n,
                    newFiles,
                    startUpload
                }) : null));
            }
            function ProgressBarComplete(props) {
                const {i18n} = props;
                return h("div", {
                    className: "uppy-StatusBar-content",
                    role: "status",
                    title: i18n("complete")
                }, h("div", {
                    className: "uppy-StatusBar-status"
                }, h("div", {
                    className: "uppy-StatusBar-statusPrimary"
                }, h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    className: "uppy-StatusBar-statusIndicator uppy-c-icon",
                    width: "15",
                    height: "11",
                    viewBox: "0 0 15 11"
                }, h("path", {
                    d: "M.414 5.843L1.627 4.63l3.472 3.472L13.202 0l1.212 1.213L5.1 10.528z"
                })), i18n("complete"))));
            }
            function ProgressBarError(props) {
                const {error, i18n, complete, numUploads} = props;
                function displayErrorAlert() {
                    const errorMessage = `${i18n("uploadFailed")} \n\n ${error}`;
                    alert(errorMessage);
                }
                return h("div", {
                    className: "uppy-StatusBar-content",
                    title: i18n("uploadFailed")
                }, h("svg", {
                    "aria-hidden": "true",
                    focusable: "false",
                    className: "uppy-StatusBar-statusIndicator uppy-c-icon",
                    width: "11",
                    height: "11",
                    viewBox: "0 0 11 11"
                }, h("path", {
                    d: "M4.278 5.5L0 1.222 1.222 0 5.5 4.278 9.778 0 11 1.222 6.722 5.5 11 9.778 9.778 11 5.5 6.722 1.222 11 0 9.778z"
                })), h("div", {
                    className: "uppy-StatusBar-status"
                }, h("div", {
                    className: "uppy-StatusBar-statusPrimary"
                }, i18n("uploadFailed"), h("button", {
                    className: "uppy-u-reset uppy-StatusBar-details",
                    "aria-label": i18n("showErrorDetails"),
                    "data-microtip-position": "top-right",
                    "data-microtip-size": "medium",
                    onClick: displayErrorAlert,
                    type: "button"
                }, "?")), h(FileUploadCount, {
                    i18n,
                    complete,
                    numUploads
                })));
            }
            module.exports = {
                UploadBtn,
                RetryBtn,
                CancelBtn,
                PauseResumeButton,
                DoneBtn,
                LoadingSpinner,
                ProgressDetails,
                ProgressBarProcessing,
                ProgressBarError,
                ProgressBarUploading,
                ProgressBarComplete
            };
        },
        858: (module, __unused_webpack_exports, __webpack_require__) => {
            const {h} = __webpack_require__(6400);
            const classNames = __webpack_require__(4184);
            const statusBarStates = __webpack_require__(3242);
            const calculateProcessingProgress = __webpack_require__(1881);
            const {UploadBtn, RetryBtn, CancelBtn, PauseResumeButton, DoneBtn, ProgressBarProcessing, ProgressBarError, ProgressBarUploading, ProgressBarComplete} = __webpack_require__(4049);
            const {STATE_ERROR, STATE_WAITING, STATE_PREPROCESSING, STATE_UPLOADING, STATE_POSTPROCESSING, STATE_COMPLETE} = statusBarStates;
            module.exports = StatusBar;
            function StatusBar(props) {
                const {newFiles, allowNewUpload, isUploadInProgress, isAllPaused, resumableUploads, error, hideUploadButton, hidePauseResumeButton, hideCancelButton, hideRetryButton, recoveredState, uploadState, totalProgress, files, supportsUploadProgress, hideAfterFinish, isSomeGhost, isTargetDOMEl, doneButtonHandler, isUploadStarted, i18n, startUpload, uppy, isAllComplete, showProgressDetails, numUploads, complete, totalSize, totalETA, totalUploadedSize} = props;
                function getProgressValue() {
                    switch (uploadState) {
                      case STATE_POSTPROCESSING:
                      case STATE_PREPROCESSING:
                        {
                            const progress = calculateProcessingProgress(files);
                            if ("determinate" === progress.mode) return 100 * progress.value;
                            return totalProgress;
                        }

                      case STATE_ERROR:
                        return null;

                      case STATE_UPLOADING:
                        if (!supportsUploadProgress) return null;
                        return totalProgress;

                      default:
                        return totalProgress;
                    }
                }
                function getIsIndeterminate() {
                    switch (uploadState) {
                      case STATE_POSTPROCESSING:
                      case STATE_PREPROCESSING:
                        {
                            const {mode} = calculateProcessingProgress(files);
                            return "indeterminate" === mode;
                        }

                      case STATE_UPLOADING:
                        if (!supportsUploadProgress) return true;
                        return false;

                      default:
                        return false;
                    }
                }
                function getIsHidden() {
                    if (recoveredState) return false;
                    switch (uploadState) {
                      case STATE_WAITING:
                        return hideUploadButton || 0 === newFiles;

                      case STATE_COMPLETE:
                        return hideAfterFinish;

                      default:
                        return false;
                    }
                }
                const progressValue = getProgressValue();
                const isHidden = getIsHidden();
                const width = null != progressValue ? progressValue : 100;
                const showUploadBtn = !error && newFiles && !isUploadInProgress && !isAllPaused && allowNewUpload && !hideUploadButton;
                const showCancelBtn = !hideCancelButton && uploadState !== STATE_WAITING && uploadState !== STATE_COMPLETE;
                const showPauseResumeBtn = resumableUploads && !hidePauseResumeButton && uploadState === STATE_UPLOADING;
                const showRetryBtn = error && !isAllComplete && !hideRetryButton;
                const showDoneBtn = doneButtonHandler && uploadState === STATE_COMPLETE;
                const progressClassNames = classNames("uppy-StatusBar-progress", {
                    "is-indeterminate": getIsIndeterminate()
                });
                const statusBarClassNames = classNames({
                    "uppy-Root": isTargetDOMEl
                }, "uppy-StatusBar", `is-${uploadState}`, {
                    "has-ghosts": isSomeGhost
                });
                return h("div", {
                    className: statusBarClassNames,
                    "aria-hidden": isHidden
                }, h("div", {
                    className: progressClassNames,
                    style: {
                        width: `${width}%`
                    },
                    role: "progressbar",
                    "aria-label": `${width}%`,
                    "aria-valuetext": `${width}%`,
                    "aria-valuemin": "0",
                    "aria-valuemax": "100",
                    "aria-valuenow": progressValue
                }), (() => {
                    switch (uploadState) {
                      case STATE_PREPROCESSING:
                      case STATE_POSTPROCESSING:
                        return h(ProgressBarProcessing, {
                            progress: calculateProcessingProgress(files)
                        });

                      case STATE_COMPLETE:
                        return h(ProgressBarComplete, {
                            i18n
                        });

                      case STATE_ERROR:
                        return h(ProgressBarError, {
                            error,
                            i18n,
                            numUploads,
                            complete
                        });

                      case STATE_UPLOADING:
                        return h(ProgressBarUploading, {
                            i18n,
                            supportsUploadProgress,
                            totalProgress,
                            showProgressDetails,
                            isUploadStarted,
                            isAllComplete,
                            isAllPaused,
                            newFiles,
                            numUploads,
                            complete,
                            totalUploadedSize,
                            totalSize,
                            totalETA,
                            startUpload
                        });

                      default:
                        return null;
                    }
                })(), h("div", {
                    className: "uppy-StatusBar-actions"
                }, recoveredState || showUploadBtn ? h(UploadBtn, {
                    newFiles,
                    isUploadStarted,
                    recoveredState,
                    i18n,
                    isSomeGhost,
                    startUpload,
                    uploadState
                }) : null, showRetryBtn ? h(RetryBtn, {
                    i18n,
                    uppy
                }) : null, showPauseResumeBtn ? h(PauseResumeButton, {
                    isAllPaused,
                    i18n,
                    isAllComplete,
                    resumableUploads,
                    uppy
                }) : null, showCancelBtn ? h(CancelBtn, {
                    i18n,
                    uppy
                }) : null, showDoneBtn ? h(DoneBtn, {
                    i18n,
                    doneButtonHandler
                }) : null));
            }
        },
        3242: module => {
            module.exports = {
                STATE_ERROR: "error",
                STATE_WAITING: "waiting",
                STATE_PREPROCESSING: "preprocessing",
                STATE_UPLOADING: "uploading",
                STATE_POSTPROCESSING: "postprocessing",
                STATE_COMPLETE: "complete"
            };
        },
        1881: module => {
            module.exports = function calculateProcessingProgress(files) {
                const values = [];
                let mode;
                let message;
                for (const {progress} of Object.values(files)) {
                    const {preprocess, postprocess} = progress;
                    if (null == message && (preprocess || postprocess)) ({mode, message} = preprocess || postprocess);
                    if ("determinate" === (null == preprocess ? void 0 : preprocess.mode)) values.push(preprocess.value);
                    if ("determinate" === (null == postprocess ? void 0 : postprocess.mode)) values.push(postprocess.value);
                }
                const value = values.reduce(((total, progressValue) => total + progressValue / values.length), 0);
                return {
                    mode,
                    message,
                    value
                };
            };
        },
        3215: (module, __unused_webpack_exports, __webpack_require__) => {
            var _class, _temp;
            const {UIPlugin} = __webpack_require__(9429);
            const getSpeed = __webpack_require__(522);
            const getBytesRemaining = __webpack_require__(9599);
            const getTextDirection = __webpack_require__(8958);
            const statusBarStates = __webpack_require__(3242);
            const StatusBarUI = __webpack_require__(858);
            const locale = __webpack_require__(2658);
            module.exports = (_temp = _class = class StatusBar extends UIPlugin {
                constructor(uppy, opts) {
                    super(uppy, opts);
                    this.startUpload = () => {
                        const {recoveredState} = this.uppy.getState();
                        if (recoveredState) {
                            this.uppy.emit("restore-confirmed");
                            return;
                        }
                        return this.uppy.upload().catch((() => {}));
                    };
                    this.id = this.opts.id || "StatusBar";
                    this.title = "StatusBar";
                    this.type = "progressindicator";
                    this.defaultLocale = locale;
                    const defaultOptions = {
                        target: "body",
                        hideUploadButton: false,
                        hideRetryButton: false,
                        hidePauseResumeButton: false,
                        hideCancelButton: false,
                        showProgressDetails: false,
                        hideAfterFinish: true,
                        doneButtonHandler: null
                    };
                    this.opts = {
                        ...defaultOptions,
                        ...opts
                    };
                    this.i18nInit();
                    this.render = this.render.bind(this);
                    this.install = this.install.bind(this);
                }
                render(state) {
                    const {capabilities, files, allowNewUpload, totalProgress, error, recoveredState} = state;
                    const {newFiles, startedFiles, completeFiles, inProgressNotPausedFiles, isUploadStarted, isAllComplete, isAllErrored, isAllPaused, isUploadInProgress, isSomeGhost} = this.uppy.getObjectOfFilesPerState();
                    const newFilesOrRecovered = recoveredState ? Object.values(files) : newFiles;
                    const totalETA = getTotalETA(inProgressNotPausedFiles);
                    const resumableUploads = !!capabilities.resumableUploads;
                    const supportsUploadProgress = false !== capabilities.uploadProgress;
                    let totalSize = 0;
                    let totalUploadedSize = 0;
                    startedFiles.forEach((file => {
                        totalSize += file.progress.bytesTotal || 0;
                        totalUploadedSize += file.progress.bytesUploaded || 0;
                    }));
                    return StatusBarUI({
                        error,
                        uploadState: getUploadingState(error, isAllComplete, recoveredState, state.files || {}),
                        allowNewUpload,
                        totalProgress,
                        totalSize,
                        totalUploadedSize,
                        isAllComplete: false,
                        isAllPaused,
                        isAllErrored,
                        isUploadStarted,
                        isUploadInProgress,
                        isSomeGhost,
                        recoveredState,
                        complete: completeFiles.length,
                        newFiles: newFilesOrRecovered.length,
                        numUploads: startedFiles.length,
                        totalETA,
                        files,
                        i18n: this.i18n,
                        uppy: this.uppy,
                        startUpload: this.startUpload,
                        doneButtonHandler: this.opts.doneButtonHandler,
                        resumableUploads,
                        supportsUploadProgress,
                        showProgressDetails: this.opts.showProgressDetails,
                        hideUploadButton: this.opts.hideUploadButton,
                        hideRetryButton: this.opts.hideRetryButton,
                        hidePauseResumeButton: this.opts.hidePauseResumeButton,
                        hideCancelButton: this.opts.hideCancelButton,
                        hideAfterFinish: this.opts.hideAfterFinish,
                        isTargetDOMEl: this.isTargetDOMEl
                    });
                }
                onMount() {
                    const element = this.el;
                    const direction = getTextDirection(element);
                    if (!direction) element.dir = "ltr";
                }
                install() {
                    const {target} = this.opts;
                    if (target) this.mount(target, this);
                }
                uninstall() {
                    this.unmount();
                }
            }, _class.VERSION = "2.1.3", _temp);
            function getTotalSpeed(files) {
                let totalSpeed = 0;
                files.forEach((file => {
                    totalSpeed += getSpeed(file.progress);
                }));
                return totalSpeed;
            }
            function getTotalETA(files) {
                const totalSpeed = getTotalSpeed(files);
                if (0 === totalSpeed) return 0;
                const totalBytesRemaining = files.reduce(((total, file) => total + getBytesRemaining(file.progress)), 0);
                return Math.round(totalBytesRemaining / totalSpeed * 10) / 10;
            }
            function getUploadingState(error, isAllComplete, recoveredState, files) {
                if (error && !isAllComplete) return statusBarStates.STATE_ERROR;
                if (isAllComplete) return statusBarStates.STATE_COMPLETE;
                if (recoveredState) return statusBarStates.STATE_WAITING;
                let state = statusBarStates.STATE_WAITING;
                const fileIDs = Object.keys(files);
                for (let i = 0; i < fileIDs.length; i++) {
                    const {progress} = files[fileIDs[i]];
                    if (progress.uploadStarted && !progress.uploadComplete) return statusBarStates.STATE_UPLOADING;
                    if (progress.preprocess && state !== statusBarStates.STATE_UPLOADING) state = statusBarStates.STATE_PREPROCESSING;
                    if (progress.postprocess && state !== statusBarStates.STATE_UPLOADING && state !== statusBarStates.STATE_PREPROCESSING) state = statusBarStates.STATE_POSTPROCESSING;
                }
                return state;
            }
        },
        2658: module => {
            module.exports = {
                strings: {
                    uploading: "Uploading",
                    complete: "Complete",
                    uploadFailed: "Upload failed",
                    paused: "Paused",
                    retry: "Retry",
                    cancel: "Cancel",
                    pause: "Pause",
                    resume: "Resume",
                    done: "Done",
                    filesUploadedOfTotal: {
                        0: "%{complete} of %{smart_count} file uploaded",
                        1: "%{complete} of %{smart_count} files uploaded"
                    },
                    dataUploadedOfTotal: "%{complete} of %{total}",
                    xTimeLeft: "%{time} left",
                    uploadXFiles: {
                        0: "Upload %{smart_count} file",
                        1: "Upload %{smart_count} files"
                    },
                    uploadXNewFiles: {
                        0: "Upload +%{smart_count} file",
                        1: "Upload +%{smart_count} files"
                    },
                    upload: "Upload",
                    retryUpload: "Retry upload",
                    xMoreFilesAdded: {
                        0: "%{smart_count} more file added",
                        1: "%{smart_count} more files added"
                    },
                    showErrorDetails: "Show error details"
                }
            };
        },
        6273: module => {
            "use strict";
            function _classPrivateFieldLooseBase(receiver, privateKey) {
                if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) throw new TypeError("attempted to use private field on non-instance");
                return receiver;
            }
            var id = 0;
            function _classPrivateFieldLooseKey(name) {
                return "__private_" + id++ + "_" + name;
            }
            var _publish = _classPrivateFieldLooseKey("publish");
            class DefaultStore {
                constructor() {
                    Object.defineProperty(this, _publish, {
                        value: _publish2
                    });
                    this.state = {};
                    this.callbacks = [];
                }
                getState() {
                    return this.state;
                }
                setState(patch) {
                    const prevState = {
                        ...this.state
                    };
                    const nextState = {
                        ...this.state,
                        ...patch
                    };
                    this.state = nextState;
                    _classPrivateFieldLooseBase(this, _publish)[_publish](prevState, nextState, patch);
                }
                subscribe(listener) {
                    this.callbacks.push(listener);
                    return () => {
                        this.callbacks.splice(this.callbacks.indexOf(listener), 1);
                    };
                }
            }
            function _publish2() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                this.callbacks.forEach((listener => {
                    listener(...args);
                }));
            }
            DefaultStore.VERSION = "2.0.3";
            module.exports = function defaultStore() {
                return new DefaultStore;
            };
        },
        7753: (module, __unused_webpack_exports, __webpack_require__) => {
            var _class, _temp;
            const {UIPlugin} = __webpack_require__(9429);
            const dataURItoBlob = __webpack_require__(3517);
            const isObjectURL = __webpack_require__(6508);
            const isPreviewSupported = __webpack_require__(9373);
            const {rotation} = __webpack_require__(1443);
            const locale = __webpack_require__(3107);
            module.exports = (_temp = _class = class ThumbnailGenerator extends UIPlugin {
                constructor(uppy, opts) {
                    super(uppy, opts);
                    this.onFileAdded = file => {
                        if (!file.preview && file.data && isPreviewSupported(file.type) && !file.isRemote) this.addToQueue(file.id);
                    };
                    this.onCancelRequest = file => {
                        const index = this.queue.indexOf(file.id);
                        if (-1 !== index) this.queue.splice(index, 1);
                    };
                    this.onFileRemoved = file => {
                        const index = this.queue.indexOf(file.id);
                        if (-1 !== index) this.queue.splice(index, 1);
                        if (file.preview && isObjectURL(file.preview)) URL.revokeObjectURL(file.preview);
                    };
                    this.onRestored = () => {
                        const restoredFiles = this.uppy.getFiles().filter((file => file.isRestored));
                        restoredFiles.forEach((file => {
                            if (!file.preview || isObjectURL(file.preview)) this.addToQueue(file.id);
                        }));
                    };
                    this.onAllFilesRemoved = () => {
                        this.queue = [];
                    };
                    this.waitUntilAllProcessed = fileIDs => {
                        fileIDs.forEach((fileID => {
                            const file = this.uppy.getFile(fileID);
                            this.uppy.emit("preprocess-progress", file, {
                                mode: "indeterminate",
                                message: this.i18n("generatingThumbnails")
                            });
                        }));
                        const emitPreprocessCompleteForAll = () => {
                            fileIDs.forEach((fileID => {
                                const file = this.uppy.getFile(fileID);
                                this.uppy.emit("preprocess-complete", file);
                            }));
                        };
                        return new Promise((resolve => {
                            if (this.queueProcessing) this.uppy.once("thumbnail:all-generated", (() => {
                                emitPreprocessCompleteForAll();
                                resolve();
                            })); else {
                                emitPreprocessCompleteForAll();
                                resolve();
                            }
                        }));
                    };
                    this.type = "modifier";
                    this.id = this.opts.id || "ThumbnailGenerator";
                    this.title = "Thumbnail Generator";
                    this.queue = [];
                    this.queueProcessing = false;
                    this.defaultThumbnailDimension = 200;
                    this.thumbnailType = this.opts.thumbnailType || "image/jpeg";
                    this.defaultLocale = locale;
                    const defaultOptions = {
                        thumbnailWidth: null,
                        thumbnailHeight: null,
                        waitForThumbnailsBeforeUpload: false,
                        lazy: false
                    };
                    this.opts = {
                        ...defaultOptions,
                        ...opts
                    };
                    this.i18nInit();
                    if (this.opts.lazy && this.opts.waitForThumbnailsBeforeUpload) throw new Error("ThumbnailGenerator: The `lazy` and `waitForThumbnailsBeforeUpload` options are mutually exclusive. Please ensure at most one of them is set to `true`.");
                }
                createThumbnail(file, targetWidth, targetHeight) {
                    const originalUrl = URL.createObjectURL(file.data);
                    const onload = new Promise(((resolve, reject) => {
                        const image = new Image;
                        image.src = originalUrl;
                        image.addEventListener("load", (() => {
                            URL.revokeObjectURL(originalUrl);
                            resolve(image);
                        }));
                        image.addEventListener("error", (event => {
                            URL.revokeObjectURL(originalUrl);
                            reject(event.error || new Error("Could not create thumbnail"));
                        }));
                    }));
                    const orientationPromise = rotation(file.data).catch((() => 1));
                    return Promise.all([ onload, orientationPromise ]).then((_ref => {
                        let [image, orientation] = _ref;
                        const dimensions = this.getProportionalDimensions(image, targetWidth, targetHeight, orientation.deg);
                        const rotatedImage = this.rotateImage(image, orientation);
                        const resizedImage = this.resizeImage(rotatedImage, dimensions.width, dimensions.height);
                        return this.canvasToBlob(resizedImage, this.thumbnailType, 80);
                    })).then((blob => URL.createObjectURL(blob)));
                }
                getProportionalDimensions(img, width, height, rotation) {
                    let aspect = img.width / img.height;
                    if (90 === rotation || 270 === rotation) aspect = img.height / img.width;
                    if (null != width) return {
                        width,
                        height: Math.round(width / aspect)
                    };
                    if (null != height) return {
                        width: Math.round(height * aspect),
                        height
                    };
                    return {
                        width: this.defaultThumbnailDimension,
                        height: Math.round(this.defaultThumbnailDimension / aspect)
                    };
                }
                protect(image) {
                    const ratio = image.width / image.height;
                    const maxSquare = 5e6;
                    const maxSize = 4096;
                    let maxW = Math.floor(Math.sqrt(maxSquare * ratio));
                    let maxH = Math.floor(maxSquare / Math.sqrt(maxSquare * ratio));
                    if (maxW > maxSize) {
                        maxW = maxSize;
                        maxH = Math.round(maxW / ratio);
                    }
                    if (maxH > maxSize) {
                        maxH = maxSize;
                        maxW = Math.round(ratio * maxH);
                    }
                    if (image.width > maxW) {
                        const canvas = document.createElement("canvas");
                        canvas.width = maxW;
                        canvas.height = maxH;
                        canvas.getContext("2d").drawImage(image, 0, 0, maxW, maxH);
                        image = canvas;
                    }
                    return image;
                }
                resizeImage(image, targetWidth, targetHeight) {
                    image = this.protect(image);
                    let steps = Math.ceil(Math.log2(image.width / targetWidth));
                    if (steps < 1) steps = 1;
                    let sW = targetWidth * 2 ** (steps - 1);
                    let sH = targetHeight * 2 ** (steps - 1);
                    const x = 2;
                    while (steps--) {
                        const canvas = document.createElement("canvas");
                        canvas.width = sW;
                        canvas.height = sH;
                        canvas.getContext("2d").drawImage(image, 0, 0, sW, sH);
                        image = canvas;
                        sW = Math.round(sW / x);
                        sH = Math.round(sH / x);
                    }
                    return image;
                }
                rotateImage(image, translate) {
                    let w = image.width;
                    let h = image.height;
                    if (90 === translate.deg || 270 === translate.deg) {
                        w = image.height;
                        h = image.width;
                    }
                    const canvas = document.createElement("canvas");
                    canvas.width = w;
                    canvas.height = h;
                    const context = canvas.getContext("2d");
                    context.translate(w / 2, h / 2);
                    if (translate.canvas) {
                        context.rotate(translate.rad);
                        context.scale(translate.scaleX, translate.scaleY);
                    }
                    context.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);
                    return canvas;
                }
                canvasToBlob(canvas, type, quality) {
                    try {
                        canvas.getContext("2d").getImageData(0, 0, 1, 1);
                    } catch (err) {
                        if (18 === err.code) return Promise.reject(new Error("cannot read image, probably an svg with external resources"));
                    }
                    if (canvas.toBlob) return new Promise((resolve => {
                        canvas.toBlob(resolve, type, quality);
                    })).then((blob => {
                        if (null === blob) throw new Error("cannot read image, probably an svg with external resources");
                        return blob;
                    }));
                    return Promise.resolve().then((() => dataURItoBlob(canvas.toDataURL(type, quality), {}))).then((blob => {
                        if (null === blob) throw new Error("could not extract blob, probably an old browser");
                        return blob;
                    }));
                }
                setPreviewURL(fileID, preview) {
                    this.uppy.setFileState(fileID, {
                        preview
                    });
                }
                addToQueue(item) {
                    this.queue.push(item);
                    if (false === this.queueProcessing) this.processQueue();
                }
                processQueue() {
                    this.queueProcessing = true;
                    if (this.queue.length > 0) {
                        const current = this.uppy.getFile(this.queue.shift());
                        if (!current) {
                            this.uppy.log("[ThumbnailGenerator] file was removed before a thumbnail could be generated, but not removed from the queue. This is probably a bug", "error");
                            return;
                        }
                        return this.requestThumbnail(current).catch((() => {})).then((() => this.processQueue()));
                    }
                    this.queueProcessing = false;
                    this.uppy.log("[ThumbnailGenerator] Emptied thumbnail queue");
                    this.uppy.emit("thumbnail:all-generated");
                }
                requestThumbnail(file) {
                    if (isPreviewSupported(file.type) && !file.isRemote) return this.createThumbnail(file, this.opts.thumbnailWidth, this.opts.thumbnailHeight).then((preview => {
                        this.setPreviewURL(file.id, preview);
                        this.uppy.log(`[ThumbnailGenerator] Generated thumbnail for ${file.id}`);
                        this.uppy.emit("thumbnail:generated", this.uppy.getFile(file.id), preview);
                    })).catch((err => {
                        this.uppy.log(`[ThumbnailGenerator] Failed thumbnail for ${file.id}:`, "warning");
                        this.uppy.log(err, "warning");
                        this.uppy.emit("thumbnail:error", this.uppy.getFile(file.id), err);
                    }));
                    return Promise.resolve();
                }
                install() {
                    this.uppy.on("file-removed", this.onFileRemoved);
                    this.uppy.on("cancel-all", this.onAllFilesRemoved);
                    if (this.opts.lazy) {
                        this.uppy.on("thumbnail:request", this.onFileAdded);
                        this.uppy.on("thumbnail:cancel", this.onCancelRequest);
                    } else {
                        this.uppy.on("file-added", this.onFileAdded);
                        this.uppy.on("restored", this.onRestored);
                    }
                    if (this.opts.waitForThumbnailsBeforeUpload) this.uppy.addPreProcessor(this.waitUntilAllProcessed);
                }
                uninstall() {
                    this.uppy.off("file-removed", this.onFileRemoved);
                    this.uppy.off("cancel-all", this.onAllFilesRemoved);
                    if (this.opts.lazy) {
                        this.uppy.off("thumbnail:request", this.onFileAdded);
                        this.uppy.off("thumbnail:cancel", this.onCancelRequest);
                    } else {
                        this.uppy.off("file-added", this.onFileAdded);
                        this.uppy.off("restored", this.onRestored);
                    }
                    if (this.opts.waitForThumbnailsBeforeUpload) this.uppy.removePreProcessor(this.waitUntilAllProcessed);
                }
            }, _class.VERSION = "2.1.1", _temp);
        },
        3107: module => {
            module.exports = {
                strings: {
                    generatingThumbnails: "Generating thumbnails..."
                }
            };
        },
        4029: (module, __unused_webpack_exports, __webpack_require__) => {
            const tus = __webpack_require__(7956);
            function isCordova() {
                return "undefined" !== typeof window && ("undefined" !== typeof window.PhoneGap || "undefined" !== typeof window.Cordova || "undefined" !== typeof window.cordova);
            }
            function isReactNative() {
                return "undefined" !== typeof navigator && "string" === typeof navigator.product && "reactnative" === navigator.product.toLowerCase();
            }
            module.exports = function getFingerprint(uppyFileObj) {
                return (file, options) => {
                    if (isCordova() || isReactNative()) return tus.defaultOptions.fingerprint(file, options);
                    const uppyFingerprint = [ "tus", uppyFileObj.id, options.endpoint ].join("-");
                    return Promise.resolve(uppyFingerprint);
                };
            };
        },
        5753: (module, __unused_webpack_exports, __webpack_require__) => {
            var _class, _retryDelayIterator, _temp;
            function _classPrivateFieldLooseBase(receiver, privateKey) {
                if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) throw new TypeError("attempted to use private field on non-instance");
                return receiver;
            }
            var id = 0;
            function _classPrivateFieldLooseKey(name) {
                return "__private_" + id++ + "_" + name;
            }
            const BasePlugin = __webpack_require__(8937);
            const tus = __webpack_require__(7956);
            const {Provider, RequestClient, Socket} = __webpack_require__(6385);
            const emitSocketProgress = __webpack_require__(7351);
            const getSocketHost = __webpack_require__(5313);
            const settle = __webpack_require__(2966);
            const EventTracker = __webpack_require__(8429);
            const NetworkError = __webpack_require__(6311);
            const isNetworkError = __webpack_require__(883);
            const {RateLimitedQueue} = __webpack_require__(8618);
            const hasProperty = __webpack_require__(4114);
            const getFingerprint = __webpack_require__(4029);
            const tusDefaultOptions = {
                endpoint: "",
                uploadUrl: null,
                metadata: {},
                uploadSize: null,
                onProgress: null,
                onChunkComplete: null,
                onSuccess: null,
                onError: null,
                overridePatchMethod: false,
                headers: {},
                addRequestId: false,
                chunkSize: 1 / 0,
                retryDelays: [ 100, 1e3, 3e3, 5e3 ],
                parallelUploads: 1,
                removeFingerprintOnSuccess: false,
                uploadLengthDeferred: false,
                uploadDataDuringCreation: false
            };
            module.exports = (_temp = (_retryDelayIterator = _classPrivateFieldLooseKey("retryDelayIterator"), 
            _class = class Tus extends BasePlugin {
                constructor(uppy, opts) {
                    var _this$opts$retryDelay;
                    super(uppy, opts);
                    Object.defineProperty(this, _retryDelayIterator, {
                        writable: true,
                        value: void 0
                    });
                    this.type = "uploader";
                    this.id = this.opts.id || "Tus";
                    this.title = "Tus";
                    const defaultOptions = {
                        useFastRemoteRetry: true,
                        limit: 20,
                        retryDelays: tusDefaultOptions.retryDelays,
                        withCredentials: false
                    };
                    this.opts = {
                        ...defaultOptions,
                        ...opts
                    };
                    if ("autoRetry" in opts) throw new Error("The `autoRetry` option was deprecated and has been removed.");
                    this.requests = new RateLimitedQueue(this.opts.limit);
                    _classPrivateFieldLooseBase(this, _retryDelayIterator)[_retryDelayIterator] = null == (_this$opts$retryDelay = this.opts.retryDelays) ? void 0 : _this$opts$retryDelay.values();
                    this.uploaders = Object.create(null);
                    this.uploaderEvents = Object.create(null);
                    this.uploaderSockets = Object.create(null);
                    this.handleResetProgress = this.handleResetProgress.bind(this);
                    this.handleUpload = this.handleUpload.bind(this);
                }
                handleResetProgress() {
                    const files = {
                        ...this.uppy.getState().files
                    };
                    Object.keys(files).forEach((fileID => {
                        if (files[fileID].tus && files[fileID].tus.uploadUrl) {
                            const tusState = {
                                ...files[fileID].tus
                            };
                            delete tusState.uploadUrl;
                            files[fileID] = {
                                ...files[fileID],
                                tus: tusState
                            };
                        }
                    }));
                    this.uppy.setState({
                        files
                    });
                }
                resetUploaderReferences(fileID, opts) {
                    if (void 0 === opts) opts = {};
                    if (this.uploaders[fileID]) {
                        const uploader = this.uploaders[fileID];
                        uploader.abort();
                        if (opts.abort) uploader.abort(true);
                        this.uploaders[fileID] = null;
                    }
                    if (this.uploaderEvents[fileID]) {
                        this.uploaderEvents[fileID].remove();
                        this.uploaderEvents[fileID] = null;
                    }
                    if (this.uploaderSockets[fileID]) {
                        this.uploaderSockets[fileID].close();
                        this.uploaderSockets[fileID] = null;
                    }
                }
                upload(file) {
                    this.resetUploaderReferences(file.id);
                    return new Promise(((resolve, reject) => {
                        let queuedRequest;
                        let qRequest;
                        this.uppy.emit("upload-started", file);
                        const opts = {
                            ...this.opts,
                            ...file.tus || {}
                        };
                        if ("function" === typeof opts.headers) opts.headers = opts.headers(file);
                        const uploadOptions = {
                            ...tusDefaultOptions,
                            ...opts
                        };
                        uploadOptions.fingerprint = getFingerprint(file);
                        uploadOptions.onBeforeRequest = req => {
                            const xhr = req.getUnderlyingObject();
                            xhr.withCredentials = !!opts.withCredentials;
                            if ("function" === typeof opts.onBeforeRequest) opts.onBeforeRequest(req);
                            if (hasProperty(queuedRequest, "shouldBeRequeued")) {
                                if (!queuedRequest.shouldBeRequeued) return Promise.reject();
                                let done;
                                const p = new Promise((res => {
                                    done = res;
                                }));
                                queuedRequest = this.requests.run((() => {
                                    if (file.isPaused) queuedRequest.abort();
                                    done();
                                    return () => {};
                                }));
                                return p;
                            }
                            return;
                        };
                        uploadOptions.onError = err => {
                            this.uppy.log(err);
                            const xhr = err.originalRequest ? err.originalRequest.getUnderlyingObject() : null;
                            if (isNetworkError(xhr)) err = new NetworkError(err, xhr);
                            this.resetUploaderReferences(file.id);
                            queuedRequest.abort();
                            this.uppy.emit("upload-error", file, err);
                            reject(err);
                        };
                        uploadOptions.onProgress = (bytesUploaded, bytesTotal) => {
                            this.onReceiveUploadUrl(file, upload.url);
                            this.uppy.emit("upload-progress", file, {
                                uploader: this,
                                bytesUploaded,
                                bytesTotal
                            });
                        };
                        uploadOptions.onSuccess = () => {
                            const uploadResp = {
                                uploadURL: upload.url
                            };
                            this.resetUploaderReferences(file.id);
                            queuedRequest.done();
                            this.uppy.emit("upload-success", file, uploadResp);
                            if (upload.url) this.uppy.log(`Download ${upload.file.name} from ${upload.url}`);
                            resolve(upload);
                        };
                        uploadOptions.onShouldRetry = err => {
                            var _err$originalResponse;
                            const status = null == err ? void 0 : null == (_err$originalResponse = err.originalResponse) ? void 0 : _err$originalResponse.getStatus();
                            if (429 === status) {
                                if (!this.requests.isPaused) {
                                    var _classPrivateFieldLoo;
                                    const next = null == (_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _retryDelayIterator)[_retryDelayIterator]) ? void 0 : _classPrivateFieldLoo.next();
                                    if (null == next || next.done) return false;
                                    this.requests.rateLimit(next.value);
                                }
                            } else if (status > 400 && status < 500 && 409 !== status) return false; else if ("undefined" !== typeof navigator && false === navigator.onLine) if (!this.requests.isPaused) {
                                this.requests.pause();
                                window.addEventListener("online", (() => {
                                    this.requests.resume();
                                }), {
                                    once: true
                                });
                            }
                            queuedRequest.abort();
                            queuedRequest = {
                                shouldBeRequeued: true,
                                abort() {
                                    this.shouldBeRequeued = false;
                                },
                                done() {
                                    throw new Error("Cannot mark a queued request as done: this indicates a bug");
                                },
                                fn() {
                                    throw new Error("Cannot run a queued request: this indicates a bug");
                                }
                            };
                            return true;
                        };
                        const copyProp = (obj, srcProp, destProp) => {
                            if (hasProperty(obj, srcProp) && !hasProperty(obj, destProp)) obj[destProp] = obj[srcProp];
                        };
                        const meta = {};
                        const metaFields = Array.isArray(opts.metaFields) ? opts.metaFields : Object.keys(file.meta);
                        metaFields.forEach((item => {
                            meta[item] = file.meta[item];
                        }));
                        copyProp(meta, "type", "filetype");
                        copyProp(meta, "name", "filename");
                        uploadOptions.metadata = meta;
                        const upload = new tus.Upload(file.data, uploadOptions);
                        this.uploaders[file.id] = upload;
                        this.uploaderEvents[file.id] = new EventTracker(this.uppy);
                        qRequest = () => {
                            if (!file.isPaused) upload.start();
                            return () => {};
                        };
                        upload.findPreviousUploads().then((previousUploads => {
                            const previousUpload = previousUploads[0];
                            if (previousUpload) {
                                this.uppy.log(`[Tus] Resuming upload of ${file.id} started at ${previousUpload.creationTime}`);
                                upload.resumeFromPreviousUpload(previousUpload);
                            }
                        }));
                        queuedRequest = this.requests.run(qRequest);
                        this.onFileRemove(file.id, (targetFileID => {
                            queuedRequest.abort();
                            this.resetUploaderReferences(file.id, {
                                abort: !!upload.url
                            });
                            resolve(`upload ${targetFileID} was removed`);
                        }));
                        this.onPause(file.id, (isPaused => {
                            queuedRequest.abort();
                            if (isPaused) upload.abort(); else queuedRequest = this.requests.run(qRequest);
                        }));
                        this.onPauseAll(file.id, (() => {
                            queuedRequest.abort();
                            upload.abort();
                        }));
                        this.onCancelAll(file.id, (() => {
                            queuedRequest.abort();
                            this.resetUploaderReferences(file.id, {
                                abort: !!upload.url
                            });
                            resolve(`upload ${file.id} was canceled`);
                        }));
                        this.onResumeAll(file.id, (() => {
                            queuedRequest.abort();
                            if (file.error) upload.abort();
                            queuedRequest = this.requests.run(qRequest);
                        }));
                    })).catch((err => {
                        this.uppy.emit("upload-error", file, err);
                        throw err;
                    }));
                }
                uploadRemote(file) {
                    this.resetUploaderReferences(file.id);
                    const opts = {
                        ...this.opts
                    };
                    if (file.tus) Object.assign(opts, file.tus);
                    this.uppy.emit("upload-started", file);
                    this.uppy.log(file.remote.url);
                    if (file.serverToken) return this.connectToServerSocket(file);
                    return new Promise(((resolve, reject) => {
                        const Client = file.remote.providerOptions.provider ? Provider : RequestClient;
                        const client = new Client(this.uppy, file.remote.providerOptions);
                        client.post(file.remote.url, {
                            ...file.remote.body,
                            endpoint: opts.endpoint,
                            uploadUrl: opts.uploadUrl,
                            protocol: "tus",
                            size: file.data.size,
                            headers: opts.headers,
                            metadata: file.meta
                        }).then((res => {
                            this.uppy.setFileState(file.id, {
                                serverToken: res.token
                            });
                            file = this.uppy.getFile(file.id);
                            return this.connectToServerSocket(file);
                        })).then((() => {
                            resolve();
                        })).catch((err => {
                            this.uppy.emit("upload-error", file, err);
                            reject(err);
                        }));
                    }));
                }
                connectToServerSocket(file) {
                    return new Promise(((resolve, reject) => {
                        const token = file.serverToken;
                        const host = getSocketHost(file.remote.companionUrl);
                        const socket = new Socket({
                            target: `${host}/api/${token}`,
                            autoOpen: false
                        });
                        this.uploaderSockets[file.id] = socket;
                        this.uploaderEvents[file.id] = new EventTracker(this.uppy);
                        let queuedRequest;
                        this.onFileRemove(file.id, (() => {
                            queuedRequest.abort();
                            socket.send("cancel", {});
                            this.resetUploaderReferences(file.id);
                            resolve(`upload ${file.id} was removed`);
                        }));
                        this.onPause(file.id, (isPaused => {
                            if (isPaused) {
                                queuedRequest.abort();
                                socket.send("pause", {});
                            } else {
                                queuedRequest.abort();
                                queuedRequest = this.requests.run((() => {
                                    socket.send("resume", {});
                                    return () => {};
                                }));
                            }
                        }));
                        this.onPauseAll(file.id, (() => {
                            queuedRequest.abort();
                            socket.send("pause", {});
                        }));
                        this.onCancelAll(file.id, (() => {
                            queuedRequest.abort();
                            socket.send("cancel", {});
                            this.resetUploaderReferences(file.id);
                            resolve(`upload ${file.id} was canceled`);
                        }));
                        this.onResumeAll(file.id, (() => {
                            queuedRequest.abort();
                            if (file.error) socket.send("pause", {});
                            queuedRequest = this.requests.run((() => {
                                socket.send("resume", {});
                                return () => {};
                            }));
                        }));
                        this.onRetry(file.id, (() => {
                            if (socket.isOpen) {
                                socket.send("pause", {});
                                socket.send("resume", {});
                            }
                        }));
                        this.onRetryAll(file.id, (() => {
                            if (socket.isOpen) {
                                socket.send("pause", {});
                                socket.send("resume", {});
                            }
                        }));
                        socket.on("progress", (progressData => emitSocketProgress(this, progressData, file)));
                        socket.on("error", (errData => {
                            const {message} = errData.error;
                            const error = Object.assign(new Error(message), {
                                cause: errData.error
                            });
                            if (!this.opts.useFastRemoteRetry) {
                                this.resetUploaderReferences(file.id);
                                this.uppy.setFileState(file.id, {
                                    serverToken: null
                                });
                            } else socket.close();
                            this.uppy.emit("upload-error", file, error);
                            queuedRequest.done();
                            reject(error);
                        }));
                        socket.on("success", (data => {
                            const uploadResp = {
                                uploadURL: data.url
                            };
                            this.uppy.emit("upload-success", file, uploadResp);
                            this.resetUploaderReferences(file.id);
                            queuedRequest.done();
                            resolve();
                        }));
                        queuedRequest = this.requests.run((() => {
                            socket.open();
                            if (file.isPaused) socket.send("pause", {});
                            return () => {};
                        }));
                    }));
                }
                onReceiveUploadUrl(file, uploadURL) {
                    const currentFile = this.uppy.getFile(file.id);
                    if (!currentFile) return;
                    if (!currentFile.tus || currentFile.tus.uploadUrl !== uploadURL) {
                        this.uppy.log("[Tus] Storing upload url");
                        this.uppy.setFileState(currentFile.id, {
                            tus: {
                                ...currentFile.tus,
                                uploadUrl: uploadURL
                            }
                        });
                    }
                }
                onFileRemove(fileID, cb) {
                    this.uploaderEvents[fileID].on("file-removed", (file => {
                        if (fileID === file.id) cb(file.id);
                    }));
                }
                onPause(fileID, cb) {
                    this.uploaderEvents[fileID].on("upload-pause", ((targetFileID, isPaused) => {
                        if (fileID === targetFileID) cb(isPaused);
                    }));
                }
                onRetry(fileID, cb) {
                    this.uploaderEvents[fileID].on("upload-retry", (targetFileID => {
                        if (fileID === targetFileID) cb();
                    }));
                }
                onRetryAll(fileID, cb) {
                    this.uploaderEvents[fileID].on("retry-all", (() => {
                        if (!this.uppy.getFile(fileID)) return;
                        cb();
                    }));
                }
                onPauseAll(fileID, cb) {
                    this.uploaderEvents[fileID].on("pause-all", (() => {
                        if (!this.uppy.getFile(fileID)) return;
                        cb();
                    }));
                }
                onCancelAll(fileID, cb) {
                    this.uploaderEvents[fileID].on("cancel-all", (() => {
                        if (!this.uppy.getFile(fileID)) return;
                        cb();
                    }));
                }
                onResumeAll(fileID, cb) {
                    this.uploaderEvents[fileID].on("resume-all", (() => {
                        if (!this.uppy.getFile(fileID)) return;
                        cb();
                    }));
                }
                uploadFiles(files) {
                    const promises = files.map(((file, i) => {
                        const current = i + 1;
                        const total = files.length;
                        if ("error" in file && file.error) return Promise.reject(new Error(file.error));
                        if (file.isRemote) {
                            if (!file.progress.uploadStarted || !file.isRestored) this.uppy.emit("upload-started", file);
                            return this.uploadRemote(file, current, total);
                        }
                        if (!file.progress.uploadStarted || !file.isRestored) this.uppy.emit("upload-started", file);
                        return this.upload(file, current, total);
                    }));
                    return settle(promises);
                }
                handleUpload(fileIDs) {
                    if (0 === fileIDs.length) {
                        this.uppy.log("[Tus] No files to upload");
                        return Promise.resolve();
                    }
                    if (0 === this.opts.limit) this.uppy.log("[Tus] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/tus/#limit-0", "warning");
                    this.uppy.log("[Tus] Uploading...");
                    const filesToUpload = fileIDs.map((fileID => this.uppy.getFile(fileID)));
                    return this.uploadFiles(filesToUpload).then((() => null));
                }
                install() {
                    this.uppy.setState({
                        capabilities: {
                            ...this.uppy.getState().capabilities,
                            resumableUploads: true
                        }
                    });
                    this.uppy.addUploader(this.handleUpload);
                    this.uppy.on("reset-progress", this.handleResetProgress);
                }
                uninstall() {
                    this.uppy.setState({
                        capabilities: {
                            ...this.uppy.getState().capabilities,
                            resumableUploads: false
                        }
                    });
                    this.uppy.removeUploader(this.handleUpload);
                }
            }), _class.VERSION = "2.2.2", _temp);
        },
        5570: (module, __unused_webpack_exports, __webpack_require__) => {
            const hasProperty = __webpack_require__(4114);
            class ErrorWithCause extends Error {
                constructor(message, options) {
                    if (void 0 === options) options = {};
                    super(message);
                    this.cause = options.cause;
                    if (this.cause && hasProperty(this.cause, "isNetworkError")) this.isNetworkError = this.cause.isNetworkError;
                }
            }
            module.exports = ErrorWithCause;
        },
        8429: module => {
            var _emitter, _events;
            function _classPrivateFieldLooseBase(receiver, privateKey) {
                if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) throw new TypeError("attempted to use private field on non-instance");
                return receiver;
            }
            var id = 0;
            function _classPrivateFieldLooseKey(name) {
                return "__private_" + id++ + "_" + name;
            }
            module.exports = (_emitter = _classPrivateFieldLooseKey("emitter"), _events = _classPrivateFieldLooseKey("events"), 
            class EventTracker {
                constructor(emitter) {
                    Object.defineProperty(this, _emitter, {
                        writable: true,
                        value: void 0
                    });
                    Object.defineProperty(this, _events, {
                        writable: true,
                        value: []
                    });
                    _classPrivateFieldLooseBase(this, _emitter)[_emitter] = emitter;
                }
                on(event, fn) {
                    _classPrivateFieldLooseBase(this, _events)[_events].push([ event, fn ]);
                    return _classPrivateFieldLooseBase(this, _emitter)[_emitter].on(event, fn);
                }
                remove() {
                    for (const [event, fn] of _classPrivateFieldLooseBase(this, _events)[_events].splice(0)) _classPrivateFieldLooseBase(this, _emitter)[_emitter].off(event, fn);
                }
            });
        },
        9045: module => {
            module.exports = [ 'a[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'area[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', "input:not([disabled]):not([inert]):not([aria-hidden])", "select:not([disabled]):not([inert]):not([aria-hidden])", "textarea:not([disabled]):not([inert]):not([aria-hidden])", "button:not([disabled]):not([inert]):not([aria-hidden])", 'iframe:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'object:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'embed:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[contenteditable]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[tabindex]:not([tabindex^="-"]):not([inert]):not([aria-hidden])' ];
        },
        6311: module => {
            class NetworkError extends Error {
                constructor(error, xhr) {
                    if (void 0 === xhr) xhr = null;
                    super(`This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.`);
                    this.cause = error;
                    this.isNetworkError = true;
                    this.request = xhr;
                }
            }
            module.exports = NetworkError;
        },
        8618: module => {
            function _classPrivateFieldLooseBase(receiver, privateKey) {
                if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) throw new TypeError("attempted to use private field on non-instance");
                return receiver;
            }
            var id = 0;
            function _classPrivateFieldLooseKey(name) {
                return "__private_" + id++ + "_" + name;
            }
            function createCancelError() {
                return new Error("Cancelled");
            }
            var _activeRequests = _classPrivateFieldLooseKey("activeRequests");
            var _queuedHandlers = _classPrivateFieldLooseKey("queuedHandlers");
            var _paused = _classPrivateFieldLooseKey("paused");
            var _pauseTimer = _classPrivateFieldLooseKey("pauseTimer");
            var _downLimit = _classPrivateFieldLooseKey("downLimit");
            var _upperLimit = _classPrivateFieldLooseKey("upperLimit");
            var _rateLimitingTimer = _classPrivateFieldLooseKey("rateLimitingTimer");
            var _call = _classPrivateFieldLooseKey("call");
            var _queueNext = _classPrivateFieldLooseKey("queueNext");
            var _next = _classPrivateFieldLooseKey("next");
            var _queue = _classPrivateFieldLooseKey("queue");
            var _dequeue = _classPrivateFieldLooseKey("dequeue");
            var _resume = _classPrivateFieldLooseKey("resume");
            var _increaseLimit = _classPrivateFieldLooseKey("increaseLimit");
            class RateLimitedQueue {
                constructor(limit) {
                    Object.defineProperty(this, _dequeue, {
                        value: _dequeue2
                    });
                    Object.defineProperty(this, _queue, {
                        value: _queue2
                    });
                    Object.defineProperty(this, _next, {
                        value: _next2
                    });
                    Object.defineProperty(this, _queueNext, {
                        value: _queueNext2
                    });
                    Object.defineProperty(this, _call, {
                        value: _call2
                    });
                    Object.defineProperty(this, _activeRequests, {
                        writable: true,
                        value: 0
                    });
                    Object.defineProperty(this, _queuedHandlers, {
                        writable: true,
                        value: []
                    });
                    Object.defineProperty(this, _paused, {
                        writable: true,
                        value: false
                    });
                    Object.defineProperty(this, _pauseTimer, {
                        writable: true,
                        value: void 0
                    });
                    Object.defineProperty(this, _downLimit, {
                        writable: true,
                        value: 1
                    });
                    Object.defineProperty(this, _upperLimit, {
                        writable: true,
                        value: void 0
                    });
                    Object.defineProperty(this, _rateLimitingTimer, {
                        writable: true,
                        value: void 0
                    });
                    Object.defineProperty(this, _resume, {
                        writable: true,
                        value: () => this.resume()
                    });
                    Object.defineProperty(this, _increaseLimit, {
                        writable: true,
                        value: () => {
                            if (_classPrivateFieldLooseBase(this, _paused)[_paused]) {
                                _classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase(this, _increaseLimit)[_increaseLimit], 0);
                                return;
                            }
                            _classPrivateFieldLooseBase(this, _downLimit)[_downLimit] = this.limit;
                            this.limit = Math.ceil((_classPrivateFieldLooseBase(this, _upperLimit)[_upperLimit] + _classPrivateFieldLooseBase(this, _downLimit)[_downLimit]) / 2);
                            for (let i = _classPrivateFieldLooseBase(this, _downLimit)[_downLimit]; i <= this.limit; i++) _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();
                            if (_classPrivateFieldLooseBase(this, _upperLimit)[_upperLimit] - _classPrivateFieldLooseBase(this, _downLimit)[_downLimit] > 3) _classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase(this, _increaseLimit)[_increaseLimit], 2e3); else _classPrivateFieldLooseBase(this, _downLimit)[_downLimit] = Math.floor(_classPrivateFieldLooseBase(this, _downLimit)[_downLimit] / 2);
                        }
                    });
                    if ("number" !== typeof limit || 0 === limit) this.limit = 1 / 0; else this.limit = limit;
                }
                run(fn, queueOptions) {
                    if (!_classPrivateFieldLooseBase(this, _paused)[_paused] && _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] < this.limit) return _classPrivateFieldLooseBase(this, _call)[_call](fn);
                    return _classPrivateFieldLooseBase(this, _queue)[_queue](fn, queueOptions);
                }
                wrapPromiseFunction(fn, queueOptions) {
                    var _this = this;
                    return function() {
                        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                        let queuedRequest;
                        const outerPromise = new Promise(((resolve, reject) => {
                            queuedRequest = _this.run((() => {
                                let cancelError;
                                let innerPromise;
                                try {
                                    innerPromise = Promise.resolve(fn(...args));
                                } catch (err) {
                                    innerPromise = Promise.reject(err);
                                }
                                innerPromise.then((result => {
                                    if (cancelError) reject(cancelError); else {
                                        queuedRequest.done();
                                        resolve(result);
                                    }
                                }), (err => {
                                    if (cancelError) reject(cancelError); else {
                                        queuedRequest.done();
                                        reject(err);
                                    }
                                }));
                                return () => {
                                    cancelError = createCancelError();
                                };
                            }), queueOptions);
                        }));
                        outerPromise.abort = () => {
                            queuedRequest.abort();
                        };
                        return outerPromise;
                    };
                }
                resume() {
                    _classPrivateFieldLooseBase(this, _paused)[_paused] = false;
                    clearTimeout(_classPrivateFieldLooseBase(this, _pauseTimer)[_pauseTimer]);
                    for (let i = 0; i < this.limit; i++) _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();
                }
                pause(duration) {
                    if (void 0 === duration) duration = null;
                    _classPrivateFieldLooseBase(this, _paused)[_paused] = true;
                    clearTimeout(_classPrivateFieldLooseBase(this, _pauseTimer)[_pauseTimer]);
                    if (null != duration) _classPrivateFieldLooseBase(this, _pauseTimer)[_pauseTimer] = setTimeout(_classPrivateFieldLooseBase(this, _resume)[_resume], duration);
                }
                rateLimit(duration) {
                    clearTimeout(_classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer]);
                    this.pause(duration);
                    if (this.limit > 1 && Number.isFinite(this.limit)) {
                        _classPrivateFieldLooseBase(this, _upperLimit)[_upperLimit] = this.limit - 1;
                        this.limit = _classPrivateFieldLooseBase(this, _downLimit)[_downLimit];
                        _classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase(this, _increaseLimit)[_increaseLimit], duration);
                    }
                }
                get isPaused() {
                    return _classPrivateFieldLooseBase(this, _paused)[_paused];
                }
            }
            function _call2(fn) {
                _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] += 1;
                let done = false;
                let cancelActive;
                try {
                    cancelActive = fn();
                } catch (err) {
                    _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;
                    throw err;
                }
                return {
                    abort: () => {
                        if (done) return;
                        done = true;
                        _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;
                        cancelActive();
                        _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();
                    },
                    done: () => {
                        if (done) return;
                        done = true;
                        _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;
                        _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();
                    }
                };
            }
            function _queueNext2() {
                queueMicrotask((() => _classPrivateFieldLooseBase(this, _next)[_next]()));
            }
            function _next2() {
                if (_classPrivateFieldLooseBase(this, _paused)[_paused] || _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] >= this.limit) return;
                if (0 === _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].length) return;
                const next = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].shift();
                const handler = _classPrivateFieldLooseBase(this, _call)[_call](next.fn);
                next.abort = handler.abort;
                next.done = handler.done;
            }
            function _queue2(fn, options) {
                if (void 0 === options) options = {};
                const handler = {
                    fn,
                    priority: options.priority || 0,
                    abort: () => {
                        _classPrivateFieldLooseBase(this, _dequeue)[_dequeue](handler);
                    },
                    done: () => {
                        throw new Error("Cannot mark a queued request as done: this indicates a bug");
                    }
                };
                const index = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].findIndex((other => handler.priority > other.priority));
                if (-1 === index) _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].push(handler); else _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].splice(index, 0, handler);
                return handler;
            }
            function _dequeue2(handler) {
                const index = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].indexOf(handler);
                if (-1 !== index) _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].splice(index, 1);
            }
            module.exports = {
                RateLimitedQueue,
                internalRateLimitedQueue: Symbol("__queue")
            };
        },
        3363: (module, __unused_webpack_exports, __webpack_require__) => {
            var _apply;
            function _classPrivateFieldLooseBase(receiver, privateKey) {
                if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) throw new TypeError("attempted to use private field on non-instance");
                return receiver;
            }
            var id = 0;
            function _classPrivateFieldLooseKey(name) {
                return "__private_" + id++ + "_" + name;
            }
            const has = __webpack_require__(4114);
            function insertReplacement(source, rx, replacement) {
                const newParts = [];
                source.forEach((chunk => {
                    if ("string" !== typeof chunk) return newParts.push(chunk);
                    return rx[Symbol.split](chunk).forEach(((raw, i, list) => {
                        if ("" !== raw) newParts.push(raw);
                        if (i < list.length - 1) newParts.push(replacement);
                    }));
                }));
                return newParts;
            }
            /**
 * Takes a string with placeholder variables like `%{smart_count} file selected`
 * and replaces it with values from options `{smart_count: 5}`
 *
 * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE
 * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299
 *
 * @param {string} phrase that needs interpolation, with placeholders
 * @param {object} options with values that will be used to replace placeholders
 * @returns {any[]} interpolated
 */            function interpolate(phrase, options) {
                const dollarRegex = /\$/g;
                const dollarBillsYall = "$$$$";
                let interpolated = [ phrase ];
                if (null == options) return interpolated;
                for (const arg of Object.keys(options)) if ("_" !== arg) {
                    let replacement = options[arg];
                    if ("string" === typeof replacement) replacement = dollarRegex[Symbol.replace](replacement, dollarBillsYall);
                    interpolated = insertReplacement(interpolated, new RegExp(`%\\{${arg}\\}`, "g"), replacement);
                }
                return interpolated;
            }
            module.exports = (_apply = _classPrivateFieldLooseKey("apply"), class Translator {
                constructor(locales) {
                    Object.defineProperty(this, _apply, {
                        value: _apply2
                    });
                    this.locale = {
                        strings: {},
                        pluralize(n) {
                            if (1 === n) return 0;
                            return 1;
                        }
                    };
                    if (Array.isArray(locales)) locales.forEach(_classPrivateFieldLooseBase(this, _apply)[_apply], this); else _classPrivateFieldLooseBase(this, _apply)[_apply](locales);
                }
                translate(key, options) {
                    return this.translateArray(key, options).join("");
                }
                translateArray(key, options) {
                    if (!has(this.locale.strings, key)) throw new Error(`missing string: ${key}`);
                    const string = this.locale.strings[key];
                    const hasPluralForms = "object" === typeof string;
                    if (hasPluralForms) {
                        if (options && "undefined" !== typeof options.smart_count) {
                            const plural = this.locale.pluralize(options.smart_count);
                            return interpolate(string[plural], options);
                        }
                        throw new Error("Attempted to use a string with plural forms, but no value was given for %{smart_count}");
                    }
                    return interpolate(string, options);
                }
            });
            function _apply2(locale) {
                if (!(null != locale && locale.strings)) return;
                const prevLocale = this.locale;
                this.locale = {
                    ...prevLocale,
                    strings: {
                        ...prevLocale.strings,
                        ...locale.strings
                    }
                };
                this.locale.pluralize = locale.pluralize || prevLocale.pluralize;
            }
        },
        3517: module => {
            const DATA_URL_PATTERN = /^data:([^/]+\/[^,;]+(?:[^,]*?))(;base64)?,([\s\S]*)$/;
            module.exports = function dataURItoBlob(dataURI, opts, toFile) {
                var _ref, _opts$mimeType;
                const dataURIData = DATA_URL_PATTERN.exec(dataURI);
                const mimeType = null != (_ref = null != (_opts$mimeType = opts.mimeType) ? _opts$mimeType : null == dataURIData ? void 0 : dataURIData[1]) ? _ref : "plain/text";
                let data;
                if (null != dataURIData[2]) {
                    const binary = atob(decodeURIComponent(dataURIData[3]));
                    const bytes = new Uint8Array(binary.length);
                    for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
                    data = [ bytes ];
                } else data = [ decodeURIComponent(dataURIData[3]) ];
                if (toFile) return new File(data, opts.name || "", {
                    type: mimeType
                });
                return new Blob(data, {
                    type: mimeType
                });
            };
        },
        7351: (module, __unused_webpack_exports, __webpack_require__) => {
            const throttle = __webpack_require__(3096);
            function emitSocketProgress(uploader, progressData, file) {
                const {progress, bytesUploaded, bytesTotal} = progressData;
                if (progress) {
                    uploader.uppy.log(`Upload progress: ${progress}`);
                    uploader.uppy.emit("upload-progress", file, {
                        uploader,
                        bytesUploaded,
                        bytesTotal
                    });
                }
            }
            module.exports = throttle(emitSocketProgress, 300, {
                leading: true,
                trailing: true
            });
        },
        6865: (module, __unused_webpack_exports, __webpack_require__) => {
            const NetworkError = __webpack_require__(6311);
            module.exports = function fetchWithNetworkError() {
                return fetch(...arguments).catch((err => {
                    if ("AbortError" === err.name) throw err; else throw new NetworkError(err);
                }));
            };
        },
        1147: (module, __unused_webpack_exports, __webpack_require__) => {
            const isDOMElement = __webpack_require__(5031);
            module.exports = function findAllDOMElements(element) {
                if ("string" === typeof element) {
                    const elements = document.querySelectorAll(element);
                    return 0 === elements.length ? null : Array.from(elements);
                }
                if ("object" === typeof element && isDOMElement(element)) return [ element ];
                return null;
            };
        },
        2729: (module, __unused_webpack_exports, __webpack_require__) => {
            const isDOMElement = __webpack_require__(5031);
            module.exports = function findDOMElement(element, context) {
                if (void 0 === context) context = document;
                if ("string" === typeof element) return context.querySelector(element);
                if (isDOMElement(element)) return element;
                return null;
            };
        },
        8619: module => {
            function encodeCharacter(character) {
                return character.charCodeAt(0).toString(32);
            }
            function encodeFilename(name) {
                let suffix = "";
                return name.replace(/[^A-Z0-9]/gi, (character => {
                    suffix += `-${encodeCharacter(character)}`;
                    return "/";
                })) + suffix;
            }
            module.exports = function generateFileID(file) {
                let id = "uppy";
                if ("string" === typeof file.name) id += `-${encodeFilename(file.name.toLowerCase())}`;
                if (void 0 !== file.type) id += `-${file.type}`;
                if (file.meta && "string" === typeof file.meta.relativePath) id += `-${encodeFilename(file.meta.relativePath.toLowerCase())}`;
                if (void 0 !== file.data.size) id += `-${file.data.size}`;
                if (void 0 !== file.data.lastModified) id += `-${file.data.lastModified}`;
                return id;
            };
        },
        9599: module => {
            module.exports = function getBytesRemaining(fileProgress) {
                return fileProgress.bytesTotal - fileProgress.bytesUploaded;
            };
        },
        4031: (module, __unused_webpack_exports, __webpack_require__) => {
            const webkitGetAsEntryApi = __webpack_require__(9324);
            const fallbackApi = __webpack_require__(180);
            module.exports = function getDroppedFiles(dataTransfer, _temp) {
                var _dataTransfer$items;
                let {logDropError = () => {}} = void 0 === _temp ? {} : _temp;
                if (null != (_dataTransfer$items = dataTransfer.items) && _dataTransfer$items[0] && "webkitGetAsEntry" in dataTransfer.items[0]) return webkitGetAsEntryApi(dataTransfer, logDropError);
                return fallbackApi(dataTransfer);
            };
        },
        180: (module, __unused_webpack_exports, __webpack_require__) => {
            const toArray = __webpack_require__(6361);
            module.exports = function fallbackApi(dataTransfer) {
                const files = toArray(dataTransfer.files);
                return Promise.resolve(files);
            };
        },
        9083: module => {
            module.exports = function getFilesAndDirectoriesFromDirectory(directoryReader, oldEntries, logDropError, _ref) {
                let {onSuccess} = _ref;
                directoryReader.readEntries((entries => {
                    const newEntries = [ ...oldEntries, ...entries ];
                    if (entries.length) setTimeout((() => {
                        getFilesAndDirectoriesFromDirectory(directoryReader, newEntries, logDropError, {
                            onSuccess
                        });
                    }), 0); else onSuccess(newEntries);
                }), (error => {
                    logDropError(error);
                    onSuccess(oldEntries);
                }));
            };
        },
        2871: module => {
            module.exports = function getRelativePath(fileEntry) {
                if (!fileEntry.fullPath || fileEntry.fullPath === `/${fileEntry.name}`) return null;
                return fileEntry.fullPath;
            };
        },
        9324: (module, __unused_webpack_exports, __webpack_require__) => {
            const toArray = __webpack_require__(6361);
            const getRelativePath = __webpack_require__(2871);
            const getFilesAndDirectoriesFromDirectory = __webpack_require__(9083);
            module.exports = function webkitGetAsEntryApi(dataTransfer, logDropError) {
                const files = [];
                const rootPromises = [];
                const createPromiseToAddFileOrParseDirectory = entry => new Promise((resolve => {
                    if (entry.isFile) entry.file((file => {
                        file.relativePath = getRelativePath(entry);
                        files.push(file);
                        resolve();
                    }), (error => {
                        logDropError(error);
                        resolve();
                    })); else if (entry.isDirectory) {
                        const directoryReader = entry.createReader();
                        getFilesAndDirectoriesFromDirectory(directoryReader, [], logDropError, {
                            onSuccess: entries => resolve(Promise.all(entries.map(createPromiseToAddFileOrParseDirectory)))
                        });
                    }
                }));
                toArray(dataTransfer.items).forEach((item => {
                    const entry = item.webkitGetAsEntry();
                    if (entry) rootPromises.push(createPromiseToAddFileOrParseDirectory(entry));
                }));
                return Promise.all(rootPromises).then((() => files));
            };
        },
        8744: module => {
            module.exports = function getFileNameAndExtension(fullFileName) {
                const lastDot = fullFileName.lastIndexOf(".");
                if (-1 === lastDot || lastDot === fullFileName.length - 1) return {
                    name: fullFileName,
                    extension: void 0
                };
                return {
                    name: fullFileName.slice(0, lastDot),
                    extension: fullFileName.slice(lastDot + 1)
                };
            };
        },
        9404: (module, __unused_webpack_exports, __webpack_require__) => {
            const getFileNameAndExtension = __webpack_require__(8744);
            const mimeTypes = __webpack_require__(5624);
            module.exports = function getFileType(file) {
                var _getFileNameAndExtens;
                if (file.type) return file.type;
                const fileExtension = file.name ? null == (_getFileNameAndExtens = getFileNameAndExtension(file.name).extension) ? void 0 : _getFileNameAndExtens.toLowerCase() : null;
                if (fileExtension && fileExtension in mimeTypes) return mimeTypes[fileExtension];
                return "application/octet-stream";
            };
        },
        5313: module => {
            module.exports = function getSocketHost(url) {
                const regex = /^(?:https?:\/\/|\/\/)?(?:[^@\n]+@)?(?:www\.)?([^\n]+)/i;
                const host = regex.exec(url)[1];
                const socketProtocol = /^http:\/\//i.test(url) ? "ws" : "wss";
                return `${socketProtocol}://${host}`;
            };
        },
        522: module => {
            module.exports = function getSpeed(fileProgress) {
                if (!fileProgress.bytesUploaded) return 0;
                const timeElapsed = Date.now() - fileProgress.uploadStarted;
                const uploadSpeed = fileProgress.bytesUploaded / (timeElapsed / 1e3);
                return uploadSpeed;
            };
        },
        8958: module => {
            function getTextDirection(element) {
                var _element;
                while (element && !element.dir) element = element.parentNode;
                return null == (_element = element) ? void 0 : _element.dir;
            }
            module.exports = getTextDirection;
        },
        6770: module => {
            function pad(number) {
                return number < 10 ? `0${number}` : number.toString();
            }
            module.exports = function getTimeStamp() {
                const date = new Date;
                const hours = pad(date.getHours());
                const minutes = pad(date.getMinutes());
                const seconds = pad(date.getSeconds());
                return `${hours}:${minutes}:${seconds}`;
            };
        },
        4114: module => {
            module.exports = function has(object, key) {
                return Object.prototype.hasOwnProperty.call(object, key);
            };
        },
        5031: module => {
            module.exports = function isDOMElement(obj) {
                return (null == obj ? void 0 : obj.nodeType) === Node.ELEMENT_NODE;
            };
        },
        3754: module => {
            module.exports = function isDragDropSupported() {
                const div = document.body;
                if (!("draggable" in div) || !("ondragstart" in div && "ondrop" in div)) return false;
                if (!("FormData" in window)) return false;
                if (!("FileReader" in window)) return false;
                return true;
            };
        },
        883: module => {
            function isNetworkError(xhr) {
                if (!xhr) return false;
                return 0 !== xhr.readyState && 4 !== xhr.readyState || 0 === xhr.status;
            }
            module.exports = isNetworkError;
        },
        6508: module => {
            module.exports = function isObjectURL(url) {
                return url.startsWith("blob:");
            };
        },
        9373: module => {
            module.exports = function isPreviewSupported(fileType) {
                if (!fileType) return false;
                return /^[^/]+\/(jpe?g|gif|png|svg|svg\+xml|bmp|webp|avif)$/.test(fileType);
            };
        },
        5624: module => {
            module.exports = {
                md: "text/markdown",
                markdown: "text/markdown",
                mp4: "video/mp4",
                mp3: "audio/mp3",
                svg: "image/svg+xml",
                jpg: "image/jpeg",
                png: "image/png",
                gif: "image/gif",
                heic: "image/heic",
                heif: "image/heif",
                yaml: "text/yaml",
                yml: "text/yaml",
                csv: "text/csv",
                tsv: "text/tab-separated-values",
                tab: "text/tab-separated-values",
                avi: "video/x-msvideo",
                mks: "video/x-matroska",
                mkv: "video/x-matroska",
                mov: "video/quicktime",
                doc: "application/msword",
                docm: "application/vnd.ms-word.document.macroenabled.12",
                docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                dot: "application/msword",
                dotm: "application/vnd.ms-word.template.macroenabled.12",
                dotx: "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
                xla: "application/vnd.ms-excel",
                xlam: "application/vnd.ms-excel.addin.macroenabled.12",
                xlc: "application/vnd.ms-excel",
                xlf: "application/x-xliff+xml",
                xlm: "application/vnd.ms-excel",
                xls: "application/vnd.ms-excel",
                xlsb: "application/vnd.ms-excel.sheet.binary.macroenabled.12",
                xlsm: "application/vnd.ms-excel.sheet.macroenabled.12",
                xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                xlt: "application/vnd.ms-excel",
                xltm: "application/vnd.ms-excel.template.macroenabled.12",
                xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
                xlw: "application/vnd.ms-excel",
                txt: "text/plain",
                text: "text/plain",
                conf: "text/plain",
                log: "text/plain",
                pdf: "application/pdf",
                zip: "application/zip",
                "7z": "application/x-7z-compressed",
                rar: "application/x-rar-compressed",
                tar: "application/x-tar",
                gz: "application/gzip",
                dmg: "application/x-apple-diskimage"
            };
        },
        1011: (module, __unused_webpack_exports, __webpack_require__) => {
            const secondsToTime = __webpack_require__(8920);
            module.exports = function prettyETA(seconds) {
                const time = secondsToTime(seconds);
                const hoursStr = 0 === time.hours ? "" : `${time.hours}h`;
                const minutesStr = 0 === time.minutes ? "" : `${0 === time.hours ? time.minutes : ` ${time.minutes.toString(10).padStart(2, "0")}`}m`;
                const secondsStr = 0 !== time.hours ? "" : `${0 === time.minutes ? time.seconds : ` ${time.seconds.toString(10).padStart(2, "0")}`}s`;
                return `${hoursStr}${minutesStr}${secondsStr}`;
            };
        },
        8920: module => {
            module.exports = function secondsToTime(rawSeconds) {
                const hours = Math.floor(rawSeconds / 3600) % 24;
                const minutes = Math.floor(rawSeconds / 60) % 60;
                const seconds = Math.floor(rawSeconds % 60);
                return {
                    hours,
                    minutes,
                    seconds
                };
            };
        },
        2966: module => {
            module.exports = function settle(promises) {
                const resolutions = [];
                const rejections = [];
                function resolved(value) {
                    resolutions.push(value);
                }
                function rejected(error) {
                    rejections.push(error);
                }
                const wait = Promise.all(promises.map((promise => promise.then(resolved, rejected))));
                return wait.then((() => ({
                    successful: resolutions,
                    failed: rejections
                })));
            };
        },
        6361: module => {
            module.exports = Array.from;
        },
        469: module => {
            const separator = "...";
            module.exports = function truncateString(string, maxLength) {
                if (0 === maxLength) return "";
                if (string.length <= maxLength) return string;
                if (maxLength <= separator.length + 1) return `${string.slice(0, maxLength - 1)}…`;
                const charsToShow = maxLength - separator.length;
                const frontChars = Math.ceil(charsToShow / 2);
                const backChars = Math.floor(charsToShow / 2);
                return string.slice(0, frontChars) + separator + string.slice(-backChars);
            };
        },
        4184: (module, exports) => {
            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            /*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/            (function() {
                "use strict";
                var hasOwn = {}.hasOwnProperty;
                function classNames() {
                    var classes = [];
                    for (var i = 0; i < arguments.length; i++) {
                        var arg = arguments[i];
                        if (!arg) continue;
                        var argType = typeof arg;
                        if ("string" === argType || "number" === argType) classes.push(arg); else if (Array.isArray(arg)) {
                            if (arg.length) {
                                var inner = classNames.apply(null, arg);
                                if (inner) classes.push(inner);
                            }
                        } else if ("object" === argType) if (arg.toString === Object.prototype.toString) {
                            for (var key in arg) if (hasOwn.call(arg, key) && arg[key]) classes.push(key);
                        } else classes.push(arg.toString());
                    }
                    return classes.join(" ");
                }
                if (true && module.exports) {
                    classNames.default = classNames;
                    module.exports = classNames;
                } else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return classNames;
                }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            })();
        },
        1443: function(__unused_webpack_module, exports, __webpack_require__) {
            !function(e, t) {
                true ? t(exports) : 0;
            }(0, (function(e) {
                "use strict";
                function t(e, t, s) {
                    return t in e ? Object.defineProperty(e, t, {
                        value: s,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = s, e;
                }
                var s = "undefined" != typeof self ? self : __webpack_require__.g;
                const i = "undefined" != typeof navigator, n = i && "undefined" == typeof HTMLImageElement, r = !("undefined" == typeof __webpack_require__.g || "undefined" == typeof process || !process.versions || !process.versions.node), a = s.Buffer, h = !!a, f = e => void 0 !== e;
                function l(e) {
                    return void 0 === e || (e instanceof Map ? 0 === e.size : 0 === Object.values(e).filter(f).length);
                }
                function o(e) {
                    let t = new Error(e);
                    throw delete t.stack, t;
                }
                function u(e) {
                    let t = function(e) {
                        let t = 0;
                        return e.ifd0.enabled && (t += 1024), e.exif.enabled && (t += 2048), e.makerNote && (t += 2048), 
                        e.userComment && (t += 1024), e.gps.enabled && (t += 512), e.interop.enabled && (t += 100), 
                        e.ifd1.enabled && (t += 1024), t + 2048;
                    }(e);
                    return e.jfif.enabled && (t += 50), e.xmp.enabled && (t += 2e4), e.iptc.enabled && (t += 14e3), 
                    e.icc.enabled && (t += 6e3), t;
                }
                const d = e => String.fromCharCode.apply(null, e), c = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8") : void 0;
                class p {
                    static from(e, t) {
                        return e instanceof this && e.le === t ? e : new p(e, void 0, void 0, t);
                    }
                    constructor(e, t = 0, s, i) {
                        if ("boolean" == typeof i && (this.le = i), Array.isArray(e) && (e = new Uint8Array(e)), 
                        0 === e) this.byteOffset = 0, this.byteLength = 0; else if (e instanceof ArrayBuffer) {
                            void 0 === s && (s = e.byteLength - t);
                            let i = new DataView(e, t, s);
                            this._swapDataView(i);
                        } else if (e instanceof Uint8Array || e instanceof DataView || e instanceof p) {
                            void 0 === s && (s = e.byteLength - t), (t += e.byteOffset) + s > e.byteOffset + e.byteLength && o("Creating view outside of available memory in ArrayBuffer");
                            let i = new DataView(e.buffer, t, s);
                            this._swapDataView(i);
                        } else if ("number" == typeof e) {
                            let t = new DataView(new ArrayBuffer(e));
                            this._swapDataView(t);
                        } else o("Invalid input argument for BufferView: " + e);
                    }
                    _swapArrayBuffer(e) {
                        this._swapDataView(new DataView(e));
                    }
                    _swapBuffer(e) {
                        this._swapDataView(new DataView(e.buffer, e.byteOffset, e.byteLength));
                    }
                    _swapDataView(e) {
                        this.dataView = e, this.buffer = e.buffer, this.byteOffset = e.byteOffset, this.byteLength = e.byteLength;
                    }
                    _lengthToEnd(e) {
                        return this.byteLength - e;
                    }
                    set(e, t, s = p) {
                        return e instanceof DataView || e instanceof p ? e = new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e instanceof ArrayBuffer && (e = new Uint8Array(e)), 
                        e instanceof Uint8Array || o("BufferView.set(): Invalid data argument."), this.toUint8().set(e, t), 
                        new s(this, t, e.byteLength);
                    }
                    subarray(e, t) {
                        return t = t || this._lengthToEnd(e), new p(this, e, t);
                    }
                    toUint8() {
                        return new Uint8Array(this.buffer, this.byteOffset, this.byteLength);
                    }
                    getUint8Array(e, t) {
                        return new Uint8Array(this.buffer, this.byteOffset + e, t);
                    }
                    getString(e = 0, t = this.byteLength) {
                        let s = this.getUint8Array(e, t);
                        return i = s, c ? c.decode(i) : h ? Buffer.from(i).toString("utf8") : decodeURIComponent(escape(d(i)));
                        var i;
                    }
                    getLatin1String(e = 0, t = this.byteLength) {
                        let s = this.getUint8Array(e, t);
                        return d(s);
                    }
                    getUnicodeString(e = 0, t = this.byteLength) {
                        const s = [];
                        for (let i = 0; i < t && e + i < this.byteLength; i += 2) s.push(this.getUint16(e + i));
                        return d(s);
                    }
                    getInt8(e) {
                        return this.dataView.getInt8(e);
                    }
                    getUint8(e) {
                        return this.dataView.getUint8(e);
                    }
                    getInt16(e, t = this.le) {
                        return this.dataView.getInt16(e, t);
                    }
                    getInt32(e, t = this.le) {
                        return this.dataView.getInt32(e, t);
                    }
                    getUint16(e, t = this.le) {
                        return this.dataView.getUint16(e, t);
                    }
                    getUint32(e, t = this.le) {
                        return this.dataView.getUint32(e, t);
                    }
                    getFloat32(e, t = this.le) {
                        return this.dataView.getFloat32(e, t);
                    }
                    getFloat64(e, t = this.le) {
                        return this.dataView.getFloat64(e, t);
                    }
                    getFloat(e, t = this.le) {
                        return this.dataView.getFloat32(e, t);
                    }
                    getDouble(e, t = this.le) {
                        return this.dataView.getFloat64(e, t);
                    }
                    getUintBytes(e, t, s) {
                        switch (t) {
                          case 1:
                            return this.getUint8(e, s);

                          case 2:
                            return this.getUint16(e, s);

                          case 4:
                            return this.getUint32(e, s);

                          case 8:
                            return this.getUint64 && this.getUint64(e, s);
                        }
                    }
                    getUint(e, t, s) {
                        switch (t) {
                          case 8:
                            return this.getUint8(e, s);

                          case 16:
                            return this.getUint16(e, s);

                          case 32:
                            return this.getUint32(e, s);

                          case 64:
                            return this.getUint64 && this.getUint64(e, s);
                        }
                    }
                    toString(e) {
                        return this.dataView.toString(e, this.constructor.name);
                    }
                    ensureChunk() {}
                }
                function g(e, t) {
                    o(`${e} '${t}' was not loaded, try using full build of exifr.`);
                }
                class m extends Map {
                    constructor(e) {
                        super(), this.kind = e;
                    }
                    get(e, t) {
                        return this.has(e) || g(this.kind, e), t && (e in t || function(e, t) {
                            o(`Unknown ${e} '${t}'.`);
                        }(this.kind, e), t[e].enabled || g(this.kind, e)), super.get(e);
                    }
                    keyList() {
                        return Array.from(this.keys());
                    }
                }
                var y = new m("file parser"), b = new m("segment parser"), w = new m("file reader");
                let k = s.fetch;
                const O = "Invalid input argument";
                function v(e, t) {
                    return (s = e).startsWith("data:") || s.length > 1e4 ? A(e, t, "base64") : r && e.includes("://") ? S(e, t, "url", U) : r ? A(e, t, "fs") : i ? S(e, t, "url", U) : void o(O);
                    var s;
                }
                async function S(e, t, s, i) {
                    return w.has(s) ? A(e, t, s) : i ? async function(e, t) {
                        let s = await t(e);
                        return new p(s);
                    }(e, i) : void o(`Parser ${s} is not loaded`);
                }
                async function A(e, t, s) {
                    let i = new (w.get(s))(e, t);
                    return await i.read(), i;
                }
                const U = e => k(e).then((e => e.arrayBuffer())), x = e => new Promise(((t, s) => {
                    let i = new FileReader;
                    i.onloadend = () => t(i.result || new ArrayBuffer), i.onerror = s, i.readAsArrayBuffer(e);
                }));
                class C extends Map {
                    get tagKeys() {
                        return this.allKeys || (this.allKeys = Array.from(this.keys())), this.allKeys;
                    }
                    get tagValues() {
                        return this.allValues || (this.allValues = Array.from(this.values())), this.allValues;
                    }
                }
                function B(e, t, s) {
                    let i = new C;
                    for (let [e, t] of s) i.set(e, t);
                    if (Array.isArray(t)) for (let s of t) e.set(s, i); else e.set(t, i);
                    return i;
                }
                function V(e, t, s) {
                    let i, n = e.get(t);
                    for (i of s) n.set(i[0], i[1]);
                }
                const I = new Map, L = new Map, T = new Map, P = 37500, z = 37510, F = 33723, j = 34675, E = 34665, _ = 34853, D = 40965, M = [ "chunked", "firstChunkSize", "firstChunkSizeNode", "firstChunkSizeBrowser", "chunkSize", "chunkLimit" ], N = [ "jfif", "xmp", "icc", "iptc", "ihdr" ], R = [ "tiff", ...N ], $ = [ "ifd0", "ifd1", "exif", "gps", "interop" ], K = [ ...R, ...$ ], W = [ "makerNote", "userComment" ], X = [ "translateKeys", "translateValues", "reviveValues", "multiSegment" ], H = [ ...X, "sanitize", "mergeOutput", "silentErrors" ];
                class Y {
                    get translate() {
                        return this.translateKeys || this.translateValues || this.reviveValues;
                    }
                }
                class G extends Y {
                    get needed() {
                        return this.enabled || this.deps.size > 0;
                    }
                    constructor(e, s, i, n) {
                        if (super(), t(this, "enabled", !1), t(this, "skip", new Set), t(this, "pick", new Set), 
                        t(this, "deps", new Set), t(this, "translateKeys", !1), t(this, "translateValues", !1), 
                        t(this, "reviveValues", !1), this.key = e, this.enabled = s, this.parse = this.enabled, 
                        this.applyInheritables(n), this.canBeFiltered = $.includes(e), this.canBeFiltered && (this.dict = I.get(e)), 
                        void 0 !== i) if (Array.isArray(i)) this.parse = this.enabled = !0, this.canBeFiltered && i.length > 0 && this.translateTagSet(i, this.pick); else if ("object" == typeof i) {
                            if (this.enabled = !0, this.parse = !1 !== i.parse, this.canBeFiltered) {
                                let {pick: e, skip: t} = i;
                                e && e.length > 0 && this.translateTagSet(e, this.pick), t && t.length > 0 && this.translateTagSet(t, this.skip);
                            }
                            this.applyInheritables(i);
                        } else !0 === i || !1 === i ? this.parse = this.enabled = i : o(`Invalid options argument: ${i}`);
                    }
                    applyInheritables(e) {
                        let t, s;
                        for (t of X) s = e[t], void 0 !== s && (this[t] = s);
                    }
                    translateTagSet(e, t) {
                        if (this.dict) {
                            let s, i, {tagKeys: n, tagValues: r} = this.dict;
                            for (s of e) "string" == typeof s ? (i = r.indexOf(s), -1 === i && (i = n.indexOf(Number(s))), 
                            -1 !== i && t.add(Number(n[i]))) : t.add(s);
                        } else for (let s of e) t.add(s);
                    }
                    finalizeFilters() {
                        !this.enabled && this.deps.size > 0 ? (this.enabled = !0, te(this.pick, this.deps)) : this.enabled && this.pick.size > 0 && te(this.pick, this.deps);
                    }
                }
                var J = {
                    jfif: !1,
                    tiff: !0,
                    xmp: !1,
                    icc: !1,
                    iptc: !1,
                    ifd0: !0,
                    ifd1: !1,
                    exif: !0,
                    gps: !0,
                    interop: !1,
                    ihdr: void 0,
                    makerNote: !1,
                    userComment: !1,
                    multiSegment: !1,
                    skip: [],
                    pick: [],
                    translateKeys: !0,
                    translateValues: !0,
                    reviveValues: !0,
                    sanitize: !0,
                    mergeOutput: !0,
                    silentErrors: !0,
                    chunked: !0,
                    firstChunkSize: void 0,
                    firstChunkSizeNode: 512,
                    firstChunkSizeBrowser: 65536,
                    chunkSize: 65536,
                    chunkLimit: 5
                }, q = new Map;
                class Q extends Y {
                    static useCached(e) {
                        let t = q.get(e);
                        return void 0 !== t || (t = new this(e), q.set(e, t)), t;
                    }
                    constructor(e) {
                        super(), !0 === e ? this.setupFromTrue() : void 0 === e ? this.setupFromUndefined() : Array.isArray(e) ? this.setupFromArray(e) : "object" == typeof e ? this.setupFromObject(e) : o(`Invalid options argument ${e}`), 
                        void 0 === this.firstChunkSize && (this.firstChunkSize = i ? this.firstChunkSizeBrowser : this.firstChunkSizeNode), 
                        this.mergeOutput && (this.ifd1.enabled = !1), this.filterNestedSegmentTags(), this.traverseTiffDependencyTree(), 
                        this.checkLoadedPlugins();
                    }
                    setupFromUndefined() {
                        let e;
                        for (e of M) this[e] = J[e];
                        for (e of H) this[e] = J[e];
                        for (e of W) this[e] = J[e];
                        for (e of K) this[e] = new G(e, J[e], void 0, this);
                    }
                    setupFromTrue() {
                        let e;
                        for (e of M) this[e] = J[e];
                        for (e of H) this[e] = J[e];
                        for (e of W) this[e] = !0;
                        for (e of K) this[e] = new G(e, !0, void 0, this);
                    }
                    setupFromArray(e) {
                        let t;
                        for (t of M) this[t] = J[t];
                        for (t of H) this[t] = J[t];
                        for (t of W) this[t] = J[t];
                        for (t of K) this[t] = new G(t, !1, void 0, this);
                        this.setupGlobalFilters(e, void 0, $);
                    }
                    setupFromObject(e) {
                        let t;
                        for (t of ($.ifd0 = $.ifd0 || $.image, $.ifd1 = $.ifd1 || $.thumbnail, Object.assign(this, e), 
                        M)) this[t] = ee(e[t], J[t]);
                        for (t of H) this[t] = ee(e[t], J[t]);
                        for (t of W) this[t] = ee(e[t], J[t]);
                        for (t of R) this[t] = new G(t, J[t], e[t], this);
                        for (t of $) this[t] = new G(t, J[t], e[t], this.tiff);
                        this.setupGlobalFilters(e.pick, e.skip, $, K), !0 === e.tiff ? this.batchEnableWithBool($, !0) : !1 === e.tiff ? this.batchEnableWithUserValue($, e) : Array.isArray(e.tiff) ? this.setupGlobalFilters(e.tiff, void 0, $) : "object" == typeof e.tiff && this.setupGlobalFilters(e.tiff.pick, e.tiff.skip, $);
                    }
                    batchEnableWithBool(e, t) {
                        for (let s of e) this[s].enabled = t;
                    }
                    batchEnableWithUserValue(e, t) {
                        for (let s of e) {
                            let e = t[s];
                            this[s].enabled = !1 !== e && void 0 !== e;
                        }
                    }
                    setupGlobalFilters(e, t, s, i = s) {
                        if (e && e.length) {
                            for (let e of i) this[e].enabled = !1;
                            let t = Z(e, s);
                            for (let [e, s] of t) te(this[e].pick, s), this[e].enabled = !0;
                        } else if (t && t.length) {
                            let e = Z(t, s);
                            for (let [t, s] of e) te(this[t].skip, s);
                        }
                    }
                    filterNestedSegmentTags() {
                        let {ifd0: e, exif: t, xmp: s, iptc: i, icc: n} = this;
                        this.makerNote ? t.deps.add(P) : t.skip.add(P), this.userComment ? t.deps.add(z) : t.skip.add(z), 
                        s.enabled || e.skip.add(700), i.enabled || e.skip.add(F), n.enabled || e.skip.add(j);
                    }
                    traverseTiffDependencyTree() {
                        let {ifd0: e, exif: t, gps: s, interop: i} = this;
                        i.needed && (t.deps.add(D), e.deps.add(D)), t.needed && e.deps.add(E), s.needed && e.deps.add(_), 
                        this.tiff.enabled = $.some((e => !0 === this[e].enabled)) || this.makerNote || this.userComment;
                        for (let e of $) this[e].finalizeFilters();
                    }
                    get onlyTiff() {
                        return !N.map((e => this[e].enabled)).some((e => !0 === e)) && this.tiff.enabled;
                    }
                    checkLoadedPlugins() {
                        for (let e of R) this[e].enabled && !b.has(e) && g("segment parser", e);
                    }
                }
                function Z(e, t) {
                    let s, i, n, r, a = [];
                    for (n of t) {
                        for (r of (s = I.get(n), i = [], s)) (e.includes(r[0]) || e.includes(r[1])) && i.push(r[0]);
                        i.length && a.push([ n, i ]);
                    }
                    return a;
                }
                function ee(e, t) {
                    return void 0 !== e ? e : void 0 !== t ? t : void 0;
                }
                function te(e, t) {
                    for (let s of t) e.add(s);
                }
                t(Q, "default", J);
                class se {
                    constructor(e) {
                        t(this, "parsers", {}), t(this, "output", {}), t(this, "errors", []), t(this, "pushToErrors", (e => this.errors.push(e))), 
                        this.options = Q.useCached(e);
                    }
                    async read(e) {
                        this.file = await function(e, t) {
                            return "string" == typeof e ? v(e, t) : i && !n && e instanceof HTMLImageElement ? v(e.src, t) : e instanceof Uint8Array || e instanceof ArrayBuffer || e instanceof DataView ? new p(e) : i && e instanceof Blob ? S(e, t, "blob", x) : void o(O);
                        }(e, this.options);
                    }
                    setup() {
                        if (this.fileParser) return;
                        let {file: e} = this, t = e.getUint16(0);
                        for (let [s, i] of y) if (i.canHandle(e, t)) return this.fileParser = new i(this.options, this.file, this.parsers), 
                        e[s] = !0;
                        this.file.close && this.file.close(), o("Unknown file format");
                    }
                    async parse() {
                        let {output: e, errors: t} = this;
                        return this.setup(), this.options.silentErrors ? (await this.executeParsers().catch(this.pushToErrors), 
                        t.push(...this.fileParser.errors)) : await this.executeParsers(), this.file.close && this.file.close(), 
                        this.options.silentErrors && t.length > 0 && (e.errors = t), l(s = e) ? void 0 : s;
                        var s;
                    }
                    async executeParsers() {
                        let {output: e} = this;
                        await this.fileParser.parse();
                        let t = Object.values(this.parsers).map((async t => {
                            let s = await t.parse();
                            t.assignToOutput(e, s);
                        }));
                        this.options.silentErrors && (t = t.map((e => e.catch(this.pushToErrors)))), await Promise.all(t);
                    }
                    async extractThumbnail() {
                        this.setup();
                        let {options: e, file: t} = this, s = b.get("tiff", e);
                        var i;
                        if (t.tiff ? i = {
                            start: 0,
                            type: "tiff"
                        } : t.jpeg && (i = await this.fileParser.getOrFindSegment("tiff")), void 0 === i) return;
                        let n = await this.fileParser.ensureSegmentChunk(i), r = this.parsers.tiff = new s(n, e, t), a = await r.extractThumbnail();
                        return t.close && t.close(), a;
                    }
                }
                async function ie(e, t) {
                    let s = new se(t);
                    return await s.read(e), s.parse();
                }
                var ne = Object.freeze({
                    __proto__: null,
                    parse: ie,
                    Exifr: se,
                    fileParsers: y,
                    segmentParsers: b,
                    fileReaders: w,
                    tagKeys: I,
                    tagValues: L,
                    tagRevivers: T,
                    createDictionary: B,
                    extendDictionary: V,
                    fetchUrlAsArrayBuffer: U,
                    readBlobAsArrayBuffer: x,
                    chunkedProps: M,
                    otherSegments: N,
                    segments: R,
                    tiffBlocks: $,
                    segmentsAndBlocks: K,
                    tiffExtractables: W,
                    inheritables: X,
                    allFormatters: H,
                    Options: Q
                });
                class re {
                    static findPosition(e, t) {
                        let s = e.getUint16(t + 2) + 2, i = "function" == typeof this.headerLength ? this.headerLength(e, t, s) : this.headerLength, n = t + i, r = s - i;
                        return {
                            offset: t,
                            length: s,
                            headerLength: i,
                            start: n,
                            size: r,
                            end: n + r
                        };
                    }
                    static parse(e, t = {}) {
                        return new this(e, new Q({
                            [this.type]: t
                        }), e).parse();
                    }
                    normalizeInput(e) {
                        return e instanceof p ? e : new p(e);
                    }
                    constructor(e, s = {}, i) {
                        t(this, "errors", []), t(this, "raw", new Map), t(this, "handleError", (e => {
                            if (!this.options.silentErrors) throw e;
                            this.errors.push(e.message);
                        })), this.chunk = this.normalizeInput(e), this.file = i, this.type = this.constructor.type, 
                        this.globalOptions = this.options = s, this.localOptions = s[this.type], this.canTranslate = this.localOptions && this.localOptions.translate;
                    }
                    translate() {
                        this.canTranslate && (this.translated = this.translateBlock(this.raw, this.type));
                    }
                    get output() {
                        return this.translated ? this.translated : this.raw ? Object.fromEntries(this.raw) : void 0;
                    }
                    translateBlock(e, t) {
                        let s = T.get(t), i = L.get(t), n = I.get(t), r = this.options[t], a = r.reviveValues && !!s, h = r.translateValues && !!i, f = r.translateKeys && !!n, l = {};
                        for (let [t, r] of e) a && s.has(t) ? r = s.get(t)(r) : h && i.has(t) && (r = this.translateValue(r, i.get(t))), 
                        f && n.has(t) && (t = n.get(t) || t), l[t] = r;
                        return l;
                    }
                    translateValue(e, t) {
                        return t[e] || t.DEFAULT || e;
                    }
                    assignToOutput(e, t) {
                        this.assignObjectToOutput(e, this.constructor.type, t);
                    }
                    assignObjectToOutput(e, t, s) {
                        if (this.globalOptions.mergeOutput) return Object.assign(e, s);
                        e[t] ? Object.assign(e[t], s) : e[t] = s;
                    }
                }
                t(re, "headerLength", 4), t(re, "type", void 0), t(re, "multiSegment", !1), t(re, "canHandle", (() => !1));
                function ae(e) {
                    return 192 === e || 194 === e || 196 === e || 219 === e || 221 === e || 218 === e || 254 === e;
                }
                function he(e) {
                    return e >= 224 && e <= 239;
                }
                function fe(e, t, s) {
                    for (let [i, n] of b) if (n.canHandle(e, t, s)) return i;
                }
                class le extends class {
                    constructor(e, s, i) {
                        t(this, "errors", []), t(this, "ensureSegmentChunk", (async e => {
                            let t = e.start, s = e.size || 65536;
                            if (this.file.chunked) if (this.file.available(t, s)) e.chunk = this.file.subarray(t, s); else try {
                                e.chunk = await this.file.readChunk(t, s);
                            } catch (t) {
                                o(`Couldn't read segment: ${JSON.stringify(e)}. ${t.message}`);
                            } else this.file.byteLength > t + s ? e.chunk = this.file.subarray(t, s) : void 0 === e.size ? e.chunk = this.file.subarray(t) : o("Segment unreachable: " + JSON.stringify(e));
                            return e.chunk;
                        })), this.extendOptions && this.extendOptions(e), this.options = e, this.file = s, 
                        this.parsers = i;
                    }
                    injectSegment(e, t) {
                        this.options[e].enabled && this.createParser(e, t);
                    }
                    createParser(e, t) {
                        let s = new (b.get(e))(t, this.options, this.file);
                        return this.parsers[e] = s;
                    }
                    createParsers(e) {
                        for (let t of e) {
                            let {type: e, chunk: s} = t, i = this.options[e];
                            if (i && i.enabled) {
                                let t = this.parsers[e];
                                t && t.append || t || this.createParser(e, s);
                            }
                        }
                    }
                    async readSegments(e) {
                        let t = e.map(this.ensureSegmentChunk);
                        await Promise.all(t);
                    }
                } {
                    constructor(...e) {
                        super(...e), t(this, "appSegments", []), t(this, "jpegSegments", []), t(this, "unknownSegments", []);
                    }
                    static canHandle(e, t) {
                        return 65496 === t;
                    }
                    async parse() {
                        await this.findAppSegments(), await this.readSegments(this.appSegments), this.mergeMultiSegments(), 
                        this.createParsers(this.mergedAppSegments || this.appSegments);
                    }
                    setupSegmentFinderArgs(e) {
                        !0 === e ? (this.findAll = !0, this.wanted = new Set(b.keyList())) : (e = void 0 === e ? b.keyList().filter((e => this.options[e].enabled)) : e.filter((e => this.options[e].enabled && b.has(e))), 
                        this.findAll = !1, this.remaining = new Set(e), this.wanted = new Set(e)), this.unfinishedMultiSegment = !1;
                    }
                    async findAppSegments(e = 0, t) {
                        this.setupSegmentFinderArgs(t);
                        let {file: s, findAll: i, wanted: n, remaining: r} = this;
                        if (!i && this.file.chunked && (i = Array.from(n).some((e => {
                            let t = b.get(e), s = this.options[e];
                            return t.multiSegment && s.multiSegment;
                        })), i && await this.file.readWhole()), e = this.findAppSegmentsInRange(e, s.byteLength), 
                        !this.options.onlyTiff && s.chunked) {
                            let t = !1;
                            for (;r.size > 0 && !t && (s.canReadNextChunk || this.unfinishedMultiSegment); ) {
                                let {nextChunkOffset: i} = s, n = this.appSegments.some((e => !this.file.available(e.offset || e.start, e.length || e.size)));
                                if (t = e > i && !n ? !await s.readNextChunk(e) : !await s.readNextChunk(i), void 0 === (e = this.findAppSegmentsInRange(e, s.byteLength))) return;
                            }
                        }
                    }
                    findAppSegmentsInRange(e, t) {
                        t -= 2;
                        let s, i, n, r, a, h, {file: f, findAll: l, wanted: o, remaining: u, options: d} = this;
                        for (;e < t; e++) if (255 === f.getUint8(e)) if (s = f.getUint8(e + 1), he(s)) {
                            if (i = f.getUint16(e + 2), n = fe(f, e, i), n && o.has(n) && (r = b.get(n), a = r.findPosition(f, e), 
                            h = d[n], a.type = n, this.appSegments.push(a), !l && (r.multiSegment && h.multiSegment ? (this.unfinishedMultiSegment = a.chunkNumber < a.chunkCount, 
                            this.unfinishedMultiSegment || u.delete(n)) : u.delete(n), 0 === u.size))) break;
                            d.recordUnknownSegments && (a = re.findPosition(f, e), a.marker = s, this.unknownSegments.push(a)), 
                            e += i + 1;
                        } else if (ae(s)) {
                            if (i = f.getUint16(e + 2), 218 === s && !1 !== d.stopAfterSos) return;
                            d.recordJpegSegments && this.jpegSegments.push({
                                offset: e,
                                length: i,
                                marker: s
                            }), e += i + 1;
                        }
                        return e;
                    }
                    mergeMultiSegments() {
                        if (!this.appSegments.some((e => e.multiSegment))) return;
                        let e = function(e, t) {
                            let s, i, n, r = new Map;
                            for (let a = 0; a < e.length; a++) s = e[a], i = s[t], r.has(i) ? n = r.get(i) : r.set(i, n = []), 
                            n.push(s);
                            return Array.from(r);
                        }(this.appSegments, "type");
                        this.mergedAppSegments = e.map((([e, t]) => {
                            let s = b.get(e, this.options);
                            if (s.handleMultiSegments) return {
                                type: e,
                                chunk: s.handleMultiSegments(t)
                            };
                            return t[0];
                        }));
                    }
                    getSegment(e) {
                        return this.appSegments.find((t => t.type === e));
                    }
                    async getOrFindSegment(e) {
                        let t = this.getSegment(e);
                        return void 0 === t && (await this.findAppSegments(0, [ e ]), t = this.getSegment(e)), 
                        t;
                    }
                }
                t(le, "type", "jpeg"), y.set("jpeg", le);
                const oe = [ void 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, 4 ];
                class ue extends re {
                    parseHeader() {
                        var e = this.chunk.getUint16();
                        18761 === e ? this.le = !0 : 19789 === e && (this.le = !1), this.chunk.le = this.le, 
                        this.headerParsed = !0;
                    }
                    parseTags(e, t, s = new Map) {
                        let {pick: i, skip: n} = this.options[t];
                        i = new Set(i);
                        let r = i.size > 0, a = 0 === n.size, h = this.chunk.getUint16(e);
                        e += 2;
                        for (let f = 0; f < h; f++) {
                            let h = this.chunk.getUint16(e);
                            if (r) {
                                if (i.has(h) && (s.set(h, this.parseTag(e, h, t)), i.delete(h), 0 === i.size)) break;
                            } else !a && n.has(h) || s.set(h, this.parseTag(e, h, t));
                            e += 12;
                        }
                        return s;
                    }
                    parseTag(e, t, s) {
                        let {chunk: i} = this, n = i.getUint16(e + 2), r = i.getUint32(e + 4), a = oe[n];
                        if (a * r <= 4 ? e += 8 : e = i.getUint32(e + 8), (n < 1 || n > 13) && o(`Invalid TIFF value type. block: ${s.toUpperCase()}, tag: ${t.toString(16)}, type: ${n}, offset ${e}`), 
                        e > i.byteLength && o(`Invalid TIFF value offset. block: ${s.toUpperCase()}, tag: ${t.toString(16)}, type: ${n}, offset ${e} is outside of chunk size ${i.byteLength}`), 
                        1 === n) return i.getUint8Array(e, r);
                        if (2 === n) return "" === (h = function(e) {
                            for (;e.endsWith("\0"); ) e = e.slice(0, -1);
                            return e;
                        }(h = i.getString(e, r)).trim()) ? void 0 : h;
                        var h;
                        if (7 === n) return i.getUint8Array(e, r);
                        if (1 === r) return this.parseTagValue(n, e);
                        {
                            let t = new (function(e) {
                                switch (e) {
                                  case 1:
                                    return Uint8Array;

                                  case 3:
                                    return Uint16Array;

                                  case 4:
                                    return Uint32Array;

                                  case 5:
                                    return Array;

                                  case 6:
                                    return Int8Array;

                                  case 8:
                                    return Int16Array;

                                  case 9:
                                    return Int32Array;

                                  case 10:
                                    return Array;

                                  case 11:
                                    return Float32Array;

                                  case 12:
                                    return Float64Array;

                                  default:
                                    return Array;
                                }
                            }(n))(r), s = a;
                            for (let i = 0; i < r; i++) t[i] = this.parseTagValue(n, e), e += s;
                            return t;
                        }
                    }
                    parseTagValue(e, t) {
                        let {chunk: s} = this;
                        switch (e) {
                          case 1:
                            return s.getUint8(t);

                          case 3:
                            return s.getUint16(t);

                          case 4:
                            return s.getUint32(t);

                          case 5:
                            return s.getUint32(t) / s.getUint32(t + 4);

                          case 6:
                            return s.getInt8(t);

                          case 8:
                            return s.getInt16(t);

                          case 9:
                            return s.getInt32(t);

                          case 10:
                            return s.getInt32(t) / s.getInt32(t + 4);

                          case 11:
                            return s.getFloat(t);

                          case 12:
                            return s.getDouble(t);

                          case 13:
                            return s.getUint32(t);

                          default:
                            o(`Invalid tiff type ${e}`);
                        }
                    }
                }
                class de extends ue {
                    static canHandle(e, t) {
                        return 225 === e.getUint8(t + 1) && 1165519206 === e.getUint32(t + 4) && 0 === e.getUint16(t + 8);
                    }
                    async parse() {
                        this.parseHeader();
                        let {options: e} = this;
                        return e.ifd0.enabled && await this.parseIfd0Block(), e.exif.enabled && await this.safeParse("parseExifBlock"), 
                        e.gps.enabled && await this.safeParse("parseGpsBlock"), e.interop.enabled && await this.safeParse("parseInteropBlock"), 
                        e.ifd1.enabled && await this.safeParse("parseThumbnailBlock"), this.createOutput();
                    }
                    safeParse(e) {
                        let t = this[e]();
                        return void 0 !== t.catch && (t = t.catch(this.handleError)), t;
                    }
                    findIfd0Offset() {
                        void 0 === this.ifd0Offset && (this.ifd0Offset = this.chunk.getUint32(4));
                    }
                    findIfd1Offset() {
                        if (void 0 === this.ifd1Offset) {
                            this.findIfd0Offset();
                            let e = this.chunk.getUint16(this.ifd0Offset), t = this.ifd0Offset + 2 + 12 * e;
                            this.ifd1Offset = this.chunk.getUint32(t);
                        }
                    }
                    parseBlock(e, t) {
                        let s = new Map;
                        return this[t] = s, this.parseTags(e, t, s), s;
                    }
                    async parseIfd0Block() {
                        if (this.ifd0) return;
                        let {file: e} = this;
                        this.findIfd0Offset(), this.ifd0Offset < 8 && o("Malformed EXIF data"), !e.chunked && this.ifd0Offset > e.byteLength && o(`IFD0 offset points to outside of file.\nthis.ifd0Offset: ${this.ifd0Offset}, file.byteLength: ${e.byteLength}`), 
                        e.tiff && await e.ensureChunk(this.ifd0Offset, u(this.options));
                        let t = this.parseBlock(this.ifd0Offset, "ifd0");
                        return 0 !== t.size ? (this.exifOffset = t.get(E), this.interopOffset = t.get(D), 
                        this.gpsOffset = t.get(_), this.xmp = t.get(700), this.iptc = t.get(F), this.icc = t.get(j), 
                        this.options.sanitize && (t.delete(E), t.delete(D), t.delete(_), t.delete(700), 
                        t.delete(F), t.delete(j)), t) : void 0;
                    }
                    async parseExifBlock() {
                        if (this.exif) return;
                        if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.exifOffset) return;
                        this.file.tiff && await this.file.ensureChunk(this.exifOffset, u(this.options));
                        let e = this.parseBlock(this.exifOffset, "exif");
                        return this.interopOffset || (this.interopOffset = e.get(D)), this.makerNote = e.get(P), 
                        this.userComment = e.get(z), this.options.sanitize && (e.delete(D), e.delete(P), 
                        e.delete(z)), this.unpack(e, 41728), this.unpack(e, 41729), e;
                    }
                    unpack(e, t) {
                        let s = e.get(t);
                        s && 1 === s.length && e.set(t, s[0]);
                    }
                    async parseGpsBlock() {
                        if (this.gps) return;
                        if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.gpsOffset) return;
                        let e = this.parseBlock(this.gpsOffset, "gps");
                        return e && e.has(2) && e.has(4) && (e.set("latitude", ce(...e.get(2), e.get(1))), 
                        e.set("longitude", ce(...e.get(4), e.get(3)))), e;
                    }
                    async parseInteropBlock() {
                        if (!this.interop && (this.ifd0 || await this.parseIfd0Block(), void 0 !== this.interopOffset || this.exif || await this.parseExifBlock(), 
                        void 0 !== this.interopOffset)) return this.parseBlock(this.interopOffset, "interop");
                    }
                    async parseThumbnailBlock(e = !1) {
                        if (!this.ifd1 && !this.ifd1Parsed && (!this.options.mergeOutput || e)) return this.findIfd1Offset(), 
                        this.ifd1Offset > 0 && (this.parseBlock(this.ifd1Offset, "ifd1"), this.ifd1Parsed = !0), 
                        this.ifd1;
                    }
                    async extractThumbnail() {
                        if (this.headerParsed || this.parseHeader(), this.ifd1Parsed || await this.parseThumbnailBlock(!0), 
                        void 0 === this.ifd1) return;
                        let e = this.ifd1.get(513), t = this.ifd1.get(514);
                        return this.chunk.getUint8Array(e, t);
                    }
                    get image() {
                        return this.ifd0;
                    }
                    get thumbnail() {
                        return this.ifd1;
                    }
                    createOutput() {
                        let e, t, s, i = {};
                        for (t of $) if (e = this[t], !l(e)) if (s = this.canTranslate ? this.translateBlock(e, t) : Object.fromEntries(e), 
                        this.options.mergeOutput) {
                            if ("ifd1" === t) continue;
                            Object.assign(i, s);
                        } else i[t] = s;
                        return this.makerNote && (i.makerNote = this.makerNote), this.userComment && (i.userComment = this.userComment), 
                        i;
                    }
                    assignToOutput(e, t) {
                        if (this.globalOptions.mergeOutput) Object.assign(e, t); else for (let [s, i] of Object.entries(t)) this.assignObjectToOutput(e, s, i);
                    }
                }
                function ce(e, t, s, i) {
                    var n = e + t / 60 + s / 3600;
                    return "S" !== i && "W" !== i || (n *= -1), n;
                }
                t(de, "type", "tiff"), t(de, "headerLength", 10), b.set("tiff", de);
                var pe = Object.freeze({
                    __proto__: null,
                    default: ne,
                    Exifr: se,
                    fileParsers: y,
                    segmentParsers: b,
                    fileReaders: w,
                    tagKeys: I,
                    tagValues: L,
                    tagRevivers: T,
                    createDictionary: B,
                    extendDictionary: V,
                    fetchUrlAsArrayBuffer: U,
                    readBlobAsArrayBuffer: x,
                    chunkedProps: M,
                    otherSegments: N,
                    segments: R,
                    tiffBlocks: $,
                    segmentsAndBlocks: K,
                    tiffExtractables: W,
                    inheritables: X,
                    allFormatters: H,
                    Options: Q,
                    parse: ie
                });
                const ge = {
                    ifd0: !1,
                    ifd1: !1,
                    exif: !1,
                    gps: !1,
                    interop: !1,
                    sanitize: !1,
                    reviveValues: !0,
                    translateKeys: !1,
                    translateValues: !1,
                    mergeOutput: !1
                }, me = Object.assign({}, ge, {
                    firstChunkSize: 4e4,
                    gps: [ 1, 2, 3, 4 ]
                });
                const ye = Object.assign({}, ge, {
                    tiff: !1,
                    ifd1: !0,
                    mergeOutput: !1
                });
                const be = Object.assign({}, ge, {
                    firstChunkSize: 4e4,
                    ifd0: [ 274 ]
                });
                async function we(e) {
                    let t = new se(be);
                    await t.read(e);
                    let s = await t.parse();
                    if (s && s.ifd0) return s.ifd0[274];
                }
                const ke = Object.freeze({
                    1: {
                        dimensionSwapped: !1,
                        scaleX: 1,
                        scaleY: 1,
                        deg: 0,
                        rad: 0
                    },
                    2: {
                        dimensionSwapped: !1,
                        scaleX: -1,
                        scaleY: 1,
                        deg: 0,
                        rad: 0
                    },
                    3: {
                        dimensionSwapped: !1,
                        scaleX: 1,
                        scaleY: 1,
                        deg: 180,
                        rad: 180 * Math.PI / 180
                    },
                    4: {
                        dimensionSwapped: !1,
                        scaleX: -1,
                        scaleY: 1,
                        deg: 180,
                        rad: 180 * Math.PI / 180
                    },
                    5: {
                        dimensionSwapped: !0,
                        scaleX: 1,
                        scaleY: -1,
                        deg: 90,
                        rad: 90 * Math.PI / 180
                    },
                    6: {
                        dimensionSwapped: !0,
                        scaleX: 1,
                        scaleY: 1,
                        deg: 90,
                        rad: 90 * Math.PI / 180
                    },
                    7: {
                        dimensionSwapped: !0,
                        scaleX: 1,
                        scaleY: -1,
                        deg: 270,
                        rad: 270 * Math.PI / 180
                    },
                    8: {
                        dimensionSwapped: !0,
                        scaleX: 1,
                        scaleY: 1,
                        deg: 270,
                        rad: 270 * Math.PI / 180
                    }
                });
                if (e.rotateCanvas = !0, e.rotateCss = !0, "object" == typeof navigator) {
                    let t = navigator.userAgent;
                    if (t.includes("iPad") || t.includes("iPhone")) {
                        let s = t.match(/OS (\d+)_(\d+)/);
                        if (s) {
                            let [, t, i] = s, n = Number(t) + .1 * Number(i);
                            e.rotateCanvas = n < 13.4, e.rotateCss = !1;
                        }
                    } else if (t.includes("OS X 10")) {
                        let [, s] = t.match(/OS X 10[_.](\d+)/);
                        e.rotateCanvas = e.rotateCss = Number(s) < 15;
                    }
                    if (t.includes("Chrome/")) {
                        let [, s] = t.match(/Chrome\/(\d+)/);
                        e.rotateCanvas = e.rotateCss = Number(s) < 81;
                    } else if (t.includes("Firefox/")) {
                        let [, s] = t.match(/Firefox\/(\d+)/);
                        e.rotateCanvas = e.rotateCss = Number(s) < 77;
                    }
                }
                class Oe extends p {
                    constructor(...e) {
                        super(...e), t(this, "ranges", new ve), 0 !== this.byteLength && this.ranges.add(0, this.byteLength);
                    }
                    _tryExtend(e, t, s) {
                        if (0 === e && 0 === this.byteLength && s) {
                            let e = new DataView(s.buffer || s, s.byteOffset, s.byteLength);
                            this._swapDataView(e);
                        } else {
                            let s = e + t;
                            if (s > this.byteLength) {
                                let {dataView: e} = this._extend(s);
                                this._swapDataView(e);
                            }
                        }
                    }
                    _extend(e) {
                        let t;
                        t = h ? a.allocUnsafe(e) : new Uint8Array(e);
                        let s = new DataView(t.buffer, t.byteOffset, t.byteLength);
                        return t.set(new Uint8Array(this.buffer, this.byteOffset, this.byteLength), 0), 
                        {
                            uintView: t,
                            dataView: s
                        };
                    }
                    subarray(e, t, s = !1) {
                        return t = t || this._lengthToEnd(e), s && this._tryExtend(e, t), this.ranges.add(e, t), 
                        super.subarray(e, t);
                    }
                    set(e, t, s = !1) {
                        s && this._tryExtend(t, e.byteLength, e);
                        let i = super.set(e, t);
                        return this.ranges.add(t, i.byteLength), i;
                    }
                    async ensureChunk(e, t) {
                        this.chunked && (this.ranges.available(e, t) || await this.readChunk(e, t));
                    }
                    available(e, t) {
                        return this.ranges.available(e, t);
                    }
                }
                class ve {
                    constructor() {
                        t(this, "list", []);
                    }
                    get length() {
                        return this.list.length;
                    }
                    add(e, t, s = 0) {
                        let i = e + t, n = this.list.filter((t => Se(e, t.offset, i) || Se(e, t.end, i)));
                        if (n.length > 0) {
                            e = Math.min(e, ...n.map((e => e.offset))), i = Math.max(i, ...n.map((e => e.end))), 
                            t = i - e;
                            let s = n.shift();
                            s.offset = e, s.length = t, s.end = i, this.list = this.list.filter((e => !n.includes(e)));
                        } else this.list.push({
                            offset: e,
                            length: t,
                            end: i
                        });
                    }
                    available(e, t) {
                        let s = e + t;
                        return this.list.some((t => t.offset <= e && s <= t.end));
                    }
                }
                function Se(e, t, s) {
                    return e <= t && t <= s;
                }
                class Ae extends Oe {
                    constructor(e, s) {
                        super(0), t(this, "chunksRead", 0), this.input = e, this.options = s;
                    }
                    async readWhole() {
                        this.chunked = !1, await this.readChunk(this.nextChunkOffset);
                    }
                    async readChunked() {
                        this.chunked = !0, await this.readChunk(0, this.options.firstChunkSize);
                    }
                    async readNextChunk(e = this.nextChunkOffset) {
                        if (this.fullyRead) return this.chunksRead++, !1;
                        let t = this.options.chunkSize, s = await this.readChunk(e, t);
                        return !!s && s.byteLength === t;
                    }
                    async readChunk(e, t) {
                        if (this.chunksRead++, 0 !== (t = this.safeWrapAddress(e, t))) return this._readChunk(e, t);
                    }
                    safeWrapAddress(e, t) {
                        return void 0 !== this.size && e + t > this.size ? Math.max(0, this.size - e) : t;
                    }
                    get nextChunkOffset() {
                        if (0 !== this.ranges.list.length) return this.ranges.list[0].length;
                    }
                    get canReadNextChunk() {
                        return this.chunksRead < this.options.chunkLimit;
                    }
                    get fullyRead() {
                        return void 0 !== this.size && this.nextChunkOffset === this.size;
                    }
                    read() {
                        return this.options.chunked ? this.readChunked() : this.readWhole();
                    }
                    close() {}
                }
                w.set("blob", class extends Ae {
                    async readWhole() {
                        this.chunked = !1;
                        let e = await x(this.input);
                        this._swapArrayBuffer(e);
                    }
                    readChunked() {
                        return this.chunked = !0, this.size = this.input.size, super.readChunked();
                    }
                    async _readChunk(e, t) {
                        let s = t ? e + t : void 0, i = this.input.slice(e, s), n = await x(i);
                        return this.set(n, e, !0);
                    }
                }), e.Exifr = se, e.Options = Q, e.allFormatters = H, e.chunkedProps = M, e.createDictionary = B, 
                e.default = pe, e.extendDictionary = V, e.fetchUrlAsArrayBuffer = U, e.fileParsers = y, 
                e.fileReaders = w, e.gps = async function(e) {
                    let t = new se(me);
                    await t.read(e);
                    let s = await t.parse();
                    if (s && s.gps) {
                        let {latitude: e, longitude: t} = s.gps;
                        return {
                            latitude: e,
                            longitude: t
                        };
                    }
                }, e.gpsOnlyOptions = me, e.inheritables = X, e.orientation = we, e.orientationOnlyOptions = be, 
                e.otherSegments = N, e.parse = ie, e.readBlobAsArrayBuffer = x, e.rotation = async function(t) {
                    let s = await we(t);
                    return Object.assign({
                        canvas: e.rotateCanvas,
                        css: e.rotateCss
                    }, ke[s]);
                }, e.rotations = ke, e.segmentParsers = b, e.segments = R, e.segmentsAndBlocks = K, 
                e.tagKeys = I, e.tagRevivers = T, e.tagValues = L, e.thumbnail = async function(e) {
                    let t = new se(ye);
                    await t.read(e);
                    let s = await t.extractThumbnail();
                    return s && h ? a.from(s) : s;
                }, e.thumbnailOnlyOptions = ye, e.thumbnailUrl = async function(e) {
                    let t = await this.thumbnail(e);
                    if (void 0 !== t) {
                        let e = new Blob([ t ]);
                        return URL.createObjectURL(e);
                    }
                }, e.tiffBlocks = $, e.tiffExtractables = W, Object.defineProperty(e, "__esModule", {
                    value: !0
                });
            }));
        },
        1895: () => {
            "use strict";
            if ("function" !== typeof Object.assign) Object.assign = function(target) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
                if (!target) throw TypeError("Cannot convert undefined or null to object");
                var _loop_1 = function(source) {
                    if (source) Object.keys(source).forEach((function(key) {
                        return target[key] = source[key];
                    }));
                };
                for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
                    var source = args_1[_a];
                    _loop_1(source);
                }
                return target;
            };
        },
        8809: function(__unused_webpack_module, exports) {
            (function(global, factory) {
                true ? factory(exports) : 0;
            })(0, (function(exports) {
                "use strict";
                var fp = "undefined" !== typeof window && void 0 !== window.flatpickr ? window.flatpickr : {
                    l10ns: {}
                };
                var Russian = {
                    weekdays: {
                        shorthand: [ "Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб" ],
                        longhand: [ "Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота" ]
                    },
                    months: {
                        shorthand: [ "Янв", "Фев", "Март", "Апр", "Май", "Июнь", "Июль", "Авг", "Сен", "Окт", "Ноя", "Дек" ],
                        longhand: [ "Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь" ]
                    },
                    firstDayOfWeek: 1,
                    ordinal: function() {
                        return "";
                    },
                    rangeSeparator: " — ",
                    weekAbbreviation: "Нед.",
                    scrollTitle: "Прокрутите для увеличения",
                    toggleTitle: "Нажмите для переключения",
                    amPM: [ "ДП", "ПП" ],
                    yearAriaLabel: "Год",
                    time_24hr: true
                };
                fp.l10ns.ru = Russian;
                var ru = fp.l10ns;
                exports.Russian = Russian;
                exports.default = ru;
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
            }));
        },
        3550: function(module) {
            (function(global, factory) {
                true ? module.exports = factory() : 0;
            })(0, (function() {
                "use strict";
                /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */                function __spreadArrays() {
                    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
                    var r = Array(s), k = 0;
                    for (i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, 
                    k++) r[k] = a[j];
                    return r;
                }
                function rangePlugin(config) {
                    if (void 0 === config) config = {};
                    return function(fp) {
                        var secondInput, _secondInputFocused, _prevDates, dateFormat = "";
                        var createSecondInput = function() {
                            if (config.input) {
                                secondInput = config.input instanceof Element ? config.input : window.document.querySelector(config.input);
                                if (!secondInput) {
                                    fp.config.errorHandler(new Error("Invalid input element specified"));
                                    return;
                                }
                                if (fp.config.wrap) secondInput = secondInput.querySelector("[data-input]");
                            } else {
                                secondInput = fp._input.cloneNode();
                                secondInput.removeAttribute("id");
                                secondInput._flatpickr = void 0;
                            }
                            if (secondInput.value) {
                                var parsedDate = fp.parseDate(secondInput.value);
                                if (parsedDate) fp.selectedDates.push(parsedDate);
                            }
                            secondInput.setAttribute("data-fp-omit", "");
                            if (fp.config.clickOpens) {
                                fp._bind(secondInput, [ "focus", "click" ], (function() {
                                    if (fp.selectedDates[1]) {
                                        fp.latestSelectedDateObj = fp.selectedDates[1];
                                        fp._setHoursFromDate(fp.selectedDates[1]);
                                        fp.jumpToDate(fp.selectedDates[1]);
                                    }
                                    _secondInputFocused = true;
                                    fp.isOpen = false;
                                    fp.open(void 0, "left" === config.position ? fp._input : secondInput);
                                }));
                                fp._bind(fp._input, [ "focus", "click" ], (function(e) {
                                    e.preventDefault();
                                    fp.isOpen = false;
                                    fp.open();
                                }));
                            }
                            if (fp.config.allowInput) fp._bind(secondInput, "keydown", (function(e) {
                                if ("Enter" === e.key) {
                                    fp.setDate([ fp.selectedDates[0], secondInput.value ], true, dateFormat);
                                    secondInput.click();
                                }
                            }));
                            if (!config.input) fp._input.parentNode && fp._input.parentNode.insertBefore(secondInput, fp._input.nextSibling);
                        };
                        var plugin = {
                            onParseConfig: function() {
                                fp.config.mode = "range";
                                dateFormat = fp.config.altInput ? fp.config.altFormat : fp.config.dateFormat;
                            },
                            onReady: function() {
                                createSecondInput();
                                fp.config.ignoredFocusElements.push(secondInput);
                                if (fp.config.allowInput) {
                                    fp._input.removeAttribute("readonly");
                                    secondInput.removeAttribute("readonly");
                                } else secondInput.setAttribute("readonly", "readonly");
                                fp._bind(fp._input, "focus", (function() {
                                    fp.latestSelectedDateObj = fp.selectedDates[0];
                                    fp._setHoursFromDate(fp.selectedDates[0]);
                                    _secondInputFocused = false;
                                    fp.jumpToDate(fp.selectedDates[0]);
                                }));
                                if (fp.config.allowInput) fp._bind(fp._input, "keydown", (function(e) {
                                    if ("Enter" === e.key) fp.setDate([ fp._input.value, fp.selectedDates[1] ], true, dateFormat);
                                }));
                                fp.setDate(fp.selectedDates, false);
                                plugin.onValueUpdate(fp.selectedDates);
                                fp.loadedPlugins.push("range");
                            },
                            onPreCalendarPosition: function() {
                                if (_secondInputFocused) {
                                    fp._positionElement = secondInput;
                                    setTimeout((function() {
                                        fp._positionElement = fp._input;
                                    }), 0);
                                }
                            },
                            onChange: function() {
                                if (!fp.selectedDates.length) setTimeout((function() {
                                    if (fp.selectedDates.length) return;
                                    secondInput.value = "";
                                    _prevDates = [];
                                }), 10);
                                if (_secondInputFocused) setTimeout((function() {
                                    secondInput.focus();
                                }), 0);
                            },
                            onDestroy: function() {
                                if (!config.input) secondInput.parentNode && secondInput.parentNode.removeChild(secondInput);
                            },
                            onValueUpdate: function(selDates) {
                                var _a, _b, _c;
                                if (!secondInput) return;
                                _prevDates = !_prevDates || selDates.length >= _prevDates.length ? __spreadArrays(selDates) : _prevDates;
                                if (_prevDates.length > selDates.length) {
                                    var newSelectedDate = selDates[0];
                                    var newDates = _secondInputFocused ? [ _prevDates[0], newSelectedDate ] : [ newSelectedDate, _prevDates[1] ];
                                    if (newDates[0].getTime() > newDates[1].getTime()) if (_secondInputFocused) newDates[0] = newDates[1]; else newDates[1] = newDates[0];
                                    fp.setDate(newDates, false);
                                    _prevDates = __spreadArrays(newDates);
                                }
                                _a = fp.selectedDates.map((function(d) {
                                    return fp.formatDate(d, dateFormat);
                                })), _b = _a[0], fp._input.value = void 0 === _b ? "" : _b, _c = _a[1], secondInput.value = void 0 === _c ? "" : _c;
                            }
                        };
                        return plugin;
                    };
                }
                return rangePlugin;
            }));
        },
        125: module => {
            /*!
 * dist/inputmask.min
 * https://github.com/RobinHerbots/Inputmask
 * Copyright (c) 2010 - 2021 Robin Herbots
 * Licensed under the MIT license
 * Version: 5.0.7
 */
            !function(e, t) {
                if (true) module.exports = t(); else ;
            }(self, (function() {
                return function() {
                    "use strict";
                    var e = {
                        8741: function(e, t) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0;
                            var i = !("undefined" == typeof window || !window.document || !window.document.createElement);
                            t.default = i;
                        },
                        3976: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0;
                            var a, n = (a = i(5581)) && a.__esModule ? a : {
                                default: a
                            };
                            var r = {
                                _maxTestPos: 500,
                                placeholder: "_",
                                optionalmarker: [ "[", "]" ],
                                quantifiermarker: [ "{", "}" ],
                                groupmarker: [ "(", ")" ],
                                alternatormarker: "|",
                                escapeChar: "\\",
                                mask: null,
                                regex: null,
                                oncomplete: function() {},
                                onincomplete: function() {},
                                oncleared: function() {},
                                repeat: 0,
                                greedy: !1,
                                autoUnmask: !1,
                                removeMaskOnSubmit: !1,
                                clearMaskOnLostFocus: !0,
                                insertMode: !0,
                                insertModeVisual: !0,
                                clearIncomplete: !1,
                                alias: null,
                                onKeyDown: function() {},
                                onBeforeMask: null,
                                onBeforePaste: function(e, t) {
                                    return "function" == typeof t.onBeforeMask ? t.onBeforeMask.call(this, e, t) : e;
                                },
                                onBeforeWrite: null,
                                onUnMask: null,
                                showMaskOnFocus: !0,
                                showMaskOnHover: !0,
                                onKeyValidation: function() {},
                                skipOptionalPartCharacter: " ",
                                numericInput: !1,
                                rightAlign: !1,
                                undoOnEscape: !0,
                                radixPoint: "",
                                _radixDance: !1,
                                groupSeparator: "",
                                keepStatic: null,
                                positionCaretOnTab: !0,
                                tabThrough: !1,
                                supportsInputType: [ "text", "tel", "url", "password", "search" ],
                                ignorables: [ n.default.BACKSPACE, n.default.TAB, n.default["PAUSE/BREAK"], n.default.ESCAPE, n.default.PAGE_UP, n.default.PAGE_DOWN, n.default.END, n.default.HOME, n.default.LEFT, n.default.UP, n.default.RIGHT, n.default.DOWN, n.default.INSERT, n.default.DELETE, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229 ],
                                isComplete: null,
                                preValidation: null,
                                postValidation: null,
                                staticDefinitionSymbol: void 0,
                                jitMasking: !1,
                                nullable: !0,
                                inputEventOnly: !1,
                                noValuePatching: !1,
                                positionCaretOnClick: "lvp",
                                casing: null,
                                inputmode: "text",
                                importDataAttributes: !0,
                                shiftPositions: !0,
                                usePrototypeDefinitions: !0,
                                validationEventTimeOut: 3e3,
                                substitutes: {}
                            };
                            t.default = r;
                        },
                        7392: function(e, t) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0;
                            t.default = {
                                9: {
                                    validator: "[0-9０-９]",
                                    definitionSymbol: "*"
                                },
                                a: {
                                    validator: "[A-Za-zА-яЁёÀ-ÿµ]",
                                    definitionSymbol: "*"
                                },
                                "*": {
                                    validator: "[0-9０-９A-Za-zА-яЁёÀ-ÿµ]"
                                }
                            };
                        },
                        253: function(e, t) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = function(e, t, i) {
                                if (void 0 === i) return e.__data ? e.__data[t] : null;
                                e.__data = e.__data || {}, e.__data[t] = i;
                            };
                        },
                        3776: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.Event = void 0, t.off = function(e, t) {
                                var i, a;
                                function n(e, t, n) {
                                    if (e in i == !0) if (a.removeEventListener ? a.removeEventListener(e, n, !1) : a.detachEvent && a.detachEvent("on" + e, n), 
                                    "global" === t) for (var r in i[e]) i[e][r].splice(i[e][r].indexOf(n), 1); else i[e][t].splice(i[e][t].indexOf(n), 1);
                                }
                                function r(e, a) {
                                    var n, r, o = [];
                                    if (e.length > 0) if (void 0 === t) for (n = 0, r = i[e][a].length; n < r; n++) o.push({
                                        ev: e,
                                        namespace: a && a.length > 0 ? a : "global",
                                        handler: i[e][a][n]
                                    }); else o.push({
                                        ev: e,
                                        namespace: a && a.length > 0 ? a : "global",
                                        handler: t
                                    }); else if (a.length > 0) for (var l in i) for (var s in i[l]) if (s === a) if (void 0 === t) for (n = 0, 
                                    r = i[l][s].length; n < r; n++) o.push({
                                        ev: l,
                                        namespace: s,
                                        handler: i[l][s][n]
                                    }); else o.push({
                                        ev: l,
                                        namespace: s,
                                        handler: t
                                    });
                                    return o;
                                }
                                if (u(this[0]) && e) {
                                    i = this[0].eventRegistry, a = this[0];
                                    for (var o = e.split(" "), l = 0; l < o.length; l++) for (var s = o[l].split("."), c = r(s[0], s[1]), f = 0, d = c.length; f < d; f++) n(c[f].ev, c[f].namespace, c[f].handler);
                                }
                                return this;
                            }, t.on = function(e, t) {
                                function i(e, i) {
                                    n.addEventListener ? n.addEventListener(e, t, !1) : n.attachEvent && n.attachEvent("on" + e, t), 
                                    a[e] = a[e] || {}, a[e][i] = a[e][i] || [], a[e][i].push(t);
                                }
                                if (u(this[0])) for (var a = this[0].eventRegistry, n = this[0], r = e.split(" "), o = 0; o < r.length; o++) {
                                    var l = r[o].split("."), s = l[0], c = l[1] || "global";
                                    i(s, c);
                                }
                                return this;
                            }, t.trigger = function(e) {
                                if (u(this[0])) for (var t = this[0].eventRegistry, i = this[0], a = "string" == typeof e ? e.split(" ") : [ e.type ], r = 0; r < a.length; r++) {
                                    var l = a[r].split("."), s = l[0], c = l[1] || "global";
                                    if (void 0 !== document && "global" === c) {
                                        var f, d, p = {
                                            bubbles: !0,
                                            cancelable: !0,
                                            detail: arguments[1]
                                        };
                                        if (document.createEvent) {
                                            try {
                                                if ("input" === s) p.inputType = "insertText", f = new InputEvent(s, p); else f = new CustomEvent(s, p);
                                            } catch (e) {
                                                (f = document.createEvent("CustomEvent")).initCustomEvent(s, p.bubbles, p.cancelable, p.detail);
                                            }
                                            e.type && (0, n.default)(f, e), i.dispatchEvent(f);
                                        } else (f = document.createEventObject()).eventType = s, f.detail = arguments[1], 
                                        e.type && (0, n.default)(f, e), i.fireEvent("on" + f.eventType, f);
                                    } else if (void 0 !== t[s]) if (arguments[0] = arguments[0].type ? arguments[0] : o.default.Event(arguments[0]), 
                                    arguments[0].detail = arguments.slice(1), "global" === c) for (var h in t[s]) for (d = 0; d < t[s][h].length; d++) t[s][h][d].apply(i, arguments); else for (d = 0; d < t[s][c].length; d++) t[s][c][d].apply(i, arguments);
                                }
                                return this;
                            };
                            var a, n = s(i(600)), r = s(i(9380)), o = s(i(4963)), l = s(i(8741));
                            function s(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            function u(e) {
                                return e instanceof Element;
                            }
                            t.Event = a, "function" == typeof r.default.CustomEvent ? t.Event = a = r.default.CustomEvent : l.default && (t.Event = a = function(e, t) {
                                t = t || {
                                    bubbles: !1,
                                    cancelable: !1,
                                    detail: void 0
                                };
                                var i = document.createEvent("CustomEvent");
                                return i.initCustomEvent(e, t.bubbles, t.cancelable, t.detail), i;
                            }, a.prototype = r.default.Event.prototype);
                        },
                        600: function(e, t) {
                            function i(e) {
                                return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, i(e);
                            }
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = function e() {
                                var t, a, n, r, o, l, s = arguments[0] || {}, u = 1, c = arguments.length, f = !1;
                                "boolean" == typeof s && (f = s, s = arguments[u] || {}, u++);
                                "object" !== i(s) && "function" != typeof s && (s = {});
                                for (;u < c; u++) if (null != (t = arguments[u])) for (a in t) n = s[a], r = t[a], 
                                s !== r && (f && r && ("[object Object]" === Object.prototype.toString.call(r) || (o = Array.isArray(r))) ? (o ? (o = !1, 
                                l = n && Array.isArray(n) ? n : []) : l = n && "[object Object]" === Object.prototype.toString.call(n) ? n : {}, 
                                s[a] = e(f, l, r)) : void 0 !== r && (s[a] = r));
                                return s;
                            };
                        },
                        4963: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0;
                            var a = l(i(600)), n = l(i(9380)), r = l(i(253)), o = i(3776);
                            function l(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var s = n.default.document;
                            function u(e) {
                                return e instanceof u ? e : this instanceof u ? void (null != e && e !== n.default && (this[0] = e.nodeName ? e : void 0 !== e[0] && e[0].nodeName ? e[0] : s.querySelector(e), 
                                void 0 !== this[0] && null !== this[0] && (this[0].eventRegistry = this[0].eventRegistry || {}))) : new u(e);
                            }
                            u.prototype = {
                                on: o.on,
                                off: o.off,
                                trigger: o.trigger
                            }, u.extend = a.default, u.data = r.default, u.Event = o.Event;
                            var c = u;
                            t.default = c;
                        },
                        9845: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.ua = t.mobile = t.iphone = t.iemobile = t.ie = void 0;
                            var a, n = (a = i(9380)) && a.__esModule ? a : {
                                default: a
                            };
                            var r = n.default.navigator && n.default.navigator.userAgent || "", o = r.indexOf("MSIE ") > 0 || r.indexOf("Trident/") > 0, l = "ontouchstart" in n.default, s = /iemobile/i.test(r), u = /iphone/i.test(r) && !s;
                            t.iphone = u, t.iemobile = s, t.mobile = l, t.ie = o, t.ua = r;
                        },
                        7184: function(e, t) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = function(e) {
                                return e.replace(i, "\\$1");
                            };
                            var i = new RegExp("(\\" + [ "/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^" ].join("|\\") + ")", "gim");
                        },
                        6030: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.EventHandlers = void 0;
                            var a, n = i(8711), r = (a = i(5581)) && a.__esModule ? a : {
                                default: a
                            }, o = i(9845), l = i(7215), s = i(7760), u = i(4713);
                            function c(e, t) {
                                var i = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                if (!i) {
                                    if (Array.isArray(e) || (i = function(e, t) {
                                        if (!e) return;
                                        if ("string" == typeof e) return f(e, t);
                                        var i = Object.prototype.toString.call(e).slice(8, -1);
                                        "Object" === i && e.constructor && (i = e.constructor.name);
                                        if ("Map" === i || "Set" === i) return Array.from(e);
                                        if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return f(e, t);
                                    }(e)) || t && e && "number" == typeof e.length) {
                                        i && (e = i);
                                        var a = 0, n = function() {};
                                        return {
                                            s: n,
                                            n: function() {
                                                return a >= e.length ? {
                                                    done: !0
                                                } : {
                                                    done: !1,
                                                    value: e[a++]
                                                };
                                            },
                                            e: function(e) {
                                                throw e;
                                            },
                                            f: n
                                        };
                                    }
                                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                                }
                                var r, o = !0, l = !1;
                                return {
                                    s: function() {
                                        i = i.call(e);
                                    },
                                    n: function() {
                                        var e = i.next();
                                        return o = e.done, e;
                                    },
                                    e: function(e) {
                                        l = !0, r = e;
                                    },
                                    f: function() {
                                        try {
                                            o || null == i.return || i.return();
                                        } finally {
                                            if (l) throw r;
                                        }
                                    }
                                };
                            }
                            function f(e, t) {
                                (null == t || t > e.length) && (t = e.length);
                                for (var i = 0, a = new Array(t); i < t; i++) a[i] = e[i];
                                return a;
                            }
                            var d = {
                                keydownEvent: function(e) {
                                    var t = this.inputmask, i = t.opts, a = t.dependencyLib, c = t.maskset, f = this, d = a(f), p = e.keyCode, h = n.caret.call(t, f), v = i.onKeyDown.call(this, e, n.getBuffer.call(t), h, i);
                                    if (void 0 !== v) return v;
                                    if (p === r.default.BACKSPACE || p === r.default.DELETE || o.iphone && p === r.default.BACKSPACE_SAFARI || e.ctrlKey && p === r.default.X && !("oncut" in f)) e.preventDefault(), 
                                    l.handleRemove.call(t, f, p, h), (0, s.writeBuffer)(f, n.getBuffer.call(t, !0), c.p, e, f.inputmask._valueGet() !== n.getBuffer.call(t).join("")); else if (p === r.default.END || p === r.default.PAGE_DOWN) {
                                        e.preventDefault();
                                        var m = n.seekNext.call(t, n.getLastValidPosition.call(t));
                                        n.caret.call(t, f, e.shiftKey ? h.begin : m, m, !0);
                                    } else p === r.default.HOME && !e.shiftKey || p === r.default.PAGE_UP ? (e.preventDefault(), 
                                    n.caret.call(t, f, 0, e.shiftKey ? h.begin : 0, !0)) : i.undoOnEscape && p === r.default.ESCAPE && !0 !== e.altKey ? ((0, 
                                    s.checkVal)(f, !0, !1, t.undoValue.split("")), d.trigger("click")) : p !== r.default.INSERT || e.shiftKey || e.ctrlKey || void 0 !== t.userOptions.insertMode ? !0 === i.tabThrough && p === r.default.TAB ? !0 === e.shiftKey ? (h.end = n.seekPrevious.call(t, h.end, !0), 
                                    !0 === u.getTest.call(t, h.end - 1).match.static && h.end--, h.begin = n.seekPrevious.call(t, h.end, !0), 
                                    h.begin >= 0 && h.end > 0 && (e.preventDefault(), n.caret.call(t, f, h.begin, h.end))) : (h.begin = n.seekNext.call(t, h.begin, !0), 
                                    h.end = n.seekNext.call(t, h.begin, !0), h.end < c.maskLength && h.end--, h.begin <= c.maskLength && (e.preventDefault(), 
                                    n.caret.call(t, f, h.begin, h.end))) : e.shiftKey || i.insertModeVisual && !1 === i.insertMode && (p === r.default.RIGHT ? setTimeout((function() {
                                        var e = n.caret.call(t, f);
                                        n.caret.call(t, f, e.begin);
                                    }), 0) : p === r.default.LEFT && setTimeout((function() {
                                        var e = n.translatePosition.call(t, f.inputmask.caretPos.begin);
                                        n.translatePosition.call(t, f.inputmask.caretPos.end);
                                        t.isRTL ? n.caret.call(t, f, e + (e === c.maskLength ? 0 : 1)) : n.caret.call(t, f, e - (0 === e ? 0 : 1));
                                    }), 0)) : l.isSelection.call(t, h) ? i.insertMode = !i.insertMode : (i.insertMode = !i.insertMode, 
                                    n.caret.call(t, f, h.begin, h.begin));
                                    t.ignorable = i.ignorables.includes(p);
                                },
                                keypressEvent: function(e, t, i, a, o) {
                                    var u = this.inputmask || this, c = u.opts, f = u.dependencyLib, d = u.maskset, p = u.el, h = f(p), v = e.keyCode;
                                    if (!(!0 === t || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || u.ignorable)) return v === r.default.ENTER && u.undoValue !== u._valueGet(!0) && (u.undoValue = u._valueGet(!0), 
                                    setTimeout((function() {
                                        h.trigger("change");
                                    }), 0)), u.skipInputEvent = !0, !0;
                                    if (v) {
                                        44 !== v && 46 !== v || 3 !== e.location || "" === c.radixPoint || (v = c.radixPoint.charCodeAt(0));
                                        var m, g = t ? {
                                            begin: o,
                                            end: o
                                        } : n.caret.call(u, p), k = String.fromCharCode(v);
                                        k = c.substitutes[k] || k, d.writeOutBuffer = !0;
                                        var y = l.isValid.call(u, g, k, a, void 0, void 0, void 0, t);
                                        if (!1 !== y && (n.resetMaskSet.call(u, !0), m = void 0 !== y.caret ? y.caret : n.seekNext.call(u, y.pos.begin ? y.pos.begin : y.pos), 
                                        d.p = m), m = c.numericInput && void 0 === y.caret ? n.seekPrevious.call(u, m) : m, 
                                        !1 !== i && (setTimeout((function() {
                                            c.onKeyValidation.call(p, v, y);
                                        }), 0), d.writeOutBuffer && !1 !== y)) {
                                            var b = n.getBuffer.call(u);
                                            (0, s.writeBuffer)(p, b, m, e, !0 !== t);
                                        }
                                        if (e.preventDefault(), t) return !1 !== y && (y.forwardPosition = m), y;
                                    }
                                },
                                keyupEvent: function(e) {
                                    var t = this.inputmask;
                                    !t.isComposing || e.keyCode !== r.default.KEY_229 && e.keyCode !== r.default.ENTER || t.$el.trigger("input");
                                },
                                pasteEvent: function(e) {
                                    var t, i = this.inputmask, a = i.opts, r = i._valueGet(!0), o = n.caret.call(i, this);
                                    i.isRTL && (t = o.end, o.end = n.translatePosition.call(i, o.begin), o.begin = n.translatePosition.call(i, t));
                                    var l = r.substr(0, o.begin), u = r.substr(o.end, r.length);
                                    if (l == (i.isRTL ? n.getBufferTemplate.call(i).slice().reverse() : n.getBufferTemplate.call(i)).slice(0, o.begin).join("") && (l = ""), 
                                    u == (i.isRTL ? n.getBufferTemplate.call(i).slice().reverse() : n.getBufferTemplate.call(i)).slice(o.end).join("") && (u = ""), 
                                    window.clipboardData && window.clipboardData.getData) r = l + window.clipboardData.getData("Text") + u; else {
                                        if (!e.clipboardData || !e.clipboardData.getData) return !0;
                                        r = l + e.clipboardData.getData("text/plain") + u;
                                    }
                                    var f = r;
                                    if (i.isRTL) {
                                        f = f.split("");
                                        var d, p = c(n.getBufferTemplate.call(i));
                                        try {
                                            for (p.s(); !(d = p.n()).done; ) {
                                                var h = d.value;
                                                f[0] === h && f.shift();
                                            }
                                        } catch (e) {
                                            p.e(e);
                                        } finally {
                                            p.f();
                                        }
                                        f = f.join("");
                                    }
                                    if ("function" == typeof a.onBeforePaste) {
                                        if (!1 === (f = a.onBeforePaste.call(i, f, a))) return !1;
                                        f || (f = r);
                                    }
                                    (0, s.checkVal)(this, !0, !1, f.toString().split(""), e), e.preventDefault();
                                },
                                inputFallBackEvent: function(e) {
                                    var t = this.inputmask, i = t.opts, a = t.dependencyLib;
                                    var l = this, c = l.inputmask._valueGet(!0), f = (t.isRTL ? n.getBuffer.call(t).slice().reverse() : n.getBuffer.call(t)).join(""), p = n.caret.call(t, l, void 0, void 0, !0);
                                    if (f !== c) {
                                        c = function(e, i, a) {
                                            if (o.iemobile) {
                                                var r = i.replace(n.getBuffer.call(t).join(""), "");
                                                if (1 === r.length) {
                                                    var l = i.split("");
                                                    l.splice(a.begin, 0, r), i = l.join("");
                                                }
                                            }
                                            return i;
                                        }(0, c, p);
                                        var h = function(e, a, r) {
                                            for (var o, l, s, c = e.substr(0, r.begin).split(""), f = e.substr(r.begin).split(""), d = a.substr(0, r.begin).split(""), p = a.substr(r.begin).split(""), h = c.length >= d.length ? c.length : d.length, v = f.length >= p.length ? f.length : p.length, m = "", g = [], k = "~"; c.length < h; ) c.push(k);
                                            for (;d.length < h; ) d.push(k);
                                            for (;f.length < v; ) f.unshift(k);
                                            for (;p.length < v; ) p.unshift(k);
                                            var y = c.concat(f), b = d.concat(p);
                                            for (l = 0, o = y.length; l < o; l++) switch (s = u.getPlaceholder.call(t, n.translatePosition.call(t, l)), 
                                            m) {
                                              case "insertText":
                                                b[l - 1] === y[l] && r.begin == y.length - 1 && g.push(y[l]), l = o;
                                                break;

                                              case "insertReplacementText":
                                              case "deleteContentBackward":
                                                y[l] === k ? r.end++ : l = o;
                                                break;

                                              default:
                                                y[l] !== b[l] && (y[l + 1] !== k && y[l + 1] !== s && void 0 !== y[l + 1] || (b[l] !== s || b[l + 1] !== k) && b[l] !== k ? b[l + 1] === k && b[l] === y[l + 1] ? (m = "insertText", 
                                                g.push(y[l]), r.begin--, r.end--) : y[l] !== s && y[l] !== k && (y[l + 1] === k || b[l] !== y[l] && b[l + 1] === y[l + 1]) ? (m = "insertReplacementText", 
                                                g.push(y[l]), r.begin--) : y[l] === k ? (m = "deleteContentBackward", (n.isMask.call(t, n.translatePosition.call(t, l), !0) || b[l] === i.radixPoint) && r.end++) : l = o : (m = "insertText", 
                                                g.push(y[l]), r.begin--, r.end--));
                                            }
                                            return {
                                                action: m,
                                                data: g,
                                                caret: r
                                            };
                                        }(c, f, p);
                                        switch ((l.inputmask.shadowRoot || l.ownerDocument).activeElement !== l && l.focus(), 
                                        (0, s.writeBuffer)(l, n.getBuffer.call(t)), n.caret.call(t, l, p.begin, p.end, !0), 
                                        h.action) {
                                          case "insertText":
                                          case "insertReplacementText":
                                            h.data.forEach((function(e, i) {
                                                var n = new a.Event("keypress");
                                                n.keyCode = e.charCodeAt(0), t.ignorable = !1, d.keypressEvent.call(l, n);
                                            })), setTimeout((function() {
                                                t.$el.trigger("keyup");
                                            }), 0);
                                            break;

                                          case "deleteContentBackward":
                                            var v = new a.Event("keydown");
                                            v.keyCode = r.default.BACKSPACE, d.keydownEvent.call(l, v);
                                            break;

                                          default:
                                            (0, s.applyInputValue)(l, c);
                                        }
                                        e.preventDefault();
                                    }
                                },
                                compositionendEvent: function(e) {
                                    var t = this.inputmask;
                                    t.isComposing = !1, t.$el.trigger("input");
                                },
                                setValueEvent: function(e) {
                                    var t = this.inputmask, i = this, a = e && e.detail ? e.detail[0] : arguments[1];
                                    void 0 === a && (a = i.inputmask._valueGet(!0)), (0, s.applyInputValue)(i, a), (e.detail && void 0 !== e.detail[1] || void 0 !== arguments[2]) && n.caret.call(t, i, e.detail ? e.detail[1] : arguments[2]);
                                },
                                focusEvent: function(e) {
                                    var t = this.inputmask, i = t.opts, a = this, r = a.inputmask._valueGet();
                                    i.showMaskOnFocus && r !== n.getBuffer.call(t).join("") && (0, s.writeBuffer)(a, n.getBuffer.call(t), n.seekNext.call(t, n.getLastValidPosition.call(t))), 
                                    !0 !== i.positionCaretOnTab || !1 !== t.mouseEnter || l.isComplete.call(t, n.getBuffer.call(t)) && -1 !== n.getLastValidPosition.call(t) || d.clickEvent.apply(a, [ e, !0 ]), 
                                    t.undoValue = t._valueGet(!0);
                                },
                                invalidEvent: function(e) {
                                    this.inputmask.validationEvent = !0;
                                },
                                mouseleaveEvent: function() {
                                    var e = this.inputmask, t = e.opts, i = this;
                                    e.mouseEnter = !1, t.clearMaskOnLostFocus && (i.inputmask.shadowRoot || i.ownerDocument).activeElement !== i && (0, 
                                    s.HandleNativePlaceholder)(i, e.originalPlaceholder);
                                },
                                clickEvent: function(e, t) {
                                    var i = this.inputmask, a = this;
                                    if ((a.inputmask.shadowRoot || a.ownerDocument).activeElement === a) {
                                        var r = n.determineNewCaretPosition.call(i, n.caret.call(i, a), t);
                                        void 0 !== r && n.caret.call(i, a, r);
                                    }
                                },
                                cutEvent: function(e) {
                                    var t = this.inputmask, i = t.maskset, a = this, o = n.caret.call(t, a), u = t.isRTL ? n.getBuffer.call(t).slice(o.end, o.begin) : n.getBuffer.call(t).slice(o.begin, o.end), c = t.isRTL ? u.reverse().join("") : u.join("");
                                    window.navigator.clipboard ? window.navigator.clipboard.writeText(c) : window.clipboardData && window.clipboardData.getData && window.clipboardData.setData("Text", c), 
                                    l.handleRemove.call(t, a, r.default.DELETE, o), (0, s.writeBuffer)(a, n.getBuffer.call(t), i.p, e, t.undoValue !== t._valueGet(!0));
                                },
                                blurEvent: function(e) {
                                    var t = this.inputmask, i = t.opts, a = (0, t.dependencyLib)(this), r = this;
                                    if (r.inputmask) {
                                        (0, s.HandleNativePlaceholder)(r, t.originalPlaceholder);
                                        var o = r.inputmask._valueGet(), u = n.getBuffer.call(t).slice();
                                        "" !== o && (i.clearMaskOnLostFocus && (-1 === n.getLastValidPosition.call(t) && o === n.getBufferTemplate.call(t).join("") ? u = [] : s.clearOptionalTail.call(t, u)), 
                                        !1 === l.isComplete.call(t, u) && (setTimeout((function() {
                                            a.trigger("incomplete");
                                        }), 0), i.clearIncomplete && (n.resetMaskSet.call(t), u = i.clearMaskOnLostFocus ? [] : n.getBufferTemplate.call(t).slice())), 
                                        (0, s.writeBuffer)(r, u, void 0, e)), t.undoValue !== t._valueGet(!0) && (t.undoValue = t._valueGet(!0), 
                                        a.trigger("change"));
                                    }
                                },
                                mouseenterEvent: function() {
                                    var e = this.inputmask, t = e.opts, i = this;
                                    if (e.mouseEnter = !0, (i.inputmask.shadowRoot || i.ownerDocument).activeElement !== i) {
                                        var a = (e.isRTL ? n.getBufferTemplate.call(e).slice().reverse() : n.getBufferTemplate.call(e)).join("");
                                        e.placeholder !== a && i.placeholder !== e.originalPlaceholder && (e.originalPlaceholder = i.placeholder), 
                                        t.showMaskOnHover && (0, s.HandleNativePlaceholder)(i, a);
                                    }
                                },
                                submitEvent: function() {
                                    var e = this.inputmask, t = e.opts;
                                    e.undoValue !== e._valueGet(!0) && e.$el.trigger("change"), -1 === n.getLastValidPosition.call(e) && e._valueGet && e._valueGet() === n.getBufferTemplate.call(e).join("") && e._valueSet(""), 
                                    t.clearIncomplete && !1 === l.isComplete.call(e, n.getBuffer.call(e)) && e._valueSet(""), 
                                    t.removeMaskOnSubmit && (e._valueSet(e.unmaskedvalue(), !0), setTimeout((function() {
                                        (0, s.writeBuffer)(e.el, n.getBuffer.call(e));
                                    }), 0));
                                },
                                resetEvent: function() {
                                    var e = this.inputmask;
                                    e.refreshValue = !0, setTimeout((function() {
                                        (0, s.applyInputValue)(e.el, e._valueGet(!0));
                                    }), 0);
                                }
                            };
                            t.EventHandlers = d;
                        },
                        9716: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.EventRuler = void 0;
                            var a = l(i(2394)), n = l(i(5581)), r = i(8711), o = i(7760);
                            function l(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var s = {
                                on: function(e, t, i) {
                                    var l = e.inputmask.dependencyLib, s = function(t) {
                                        t.originalEvent && (t = t.originalEvent || t, arguments[0] = t);
                                        var s, u = this, c = u.inputmask, f = c ? c.opts : void 0;
                                        if (void 0 === c && "FORM" !== this.nodeName) {
                                            var d = l.data(u, "_inputmask_opts");
                                            l(u).off(), d && new a.default(d).mask(u);
                                        } else {
                                            if ([ "submit", "reset", "setvalue" ].includes(t.type) || "FORM" === this.nodeName || !(u.disabled || u.readOnly && !("keydown" === t.type && t.ctrlKey && 67 === t.keyCode || !1 === f.tabThrough && t.keyCode === n.default.TAB))) {
                                                switch (t.type) {
                                                  case "input":
                                                    if (!0 === c.skipInputEvent || t.inputType && "insertCompositionText" === t.inputType) return c.skipInputEvent = !1, 
                                                    t.preventDefault();
                                                    break;

                                                  case "keydown":
                                                    c.skipKeyPressEvent = !1, c.skipInputEvent = c.isComposing = t.keyCode === n.default.KEY_229;
                                                    break;

                                                  case "keyup":
                                                  case "compositionend":
                                                    c.isComposing && (c.skipInputEvent = !1);
                                                    break;

                                                  case "keypress":
                                                    if (!0 === c.skipKeyPressEvent) return t.preventDefault();
                                                    c.skipKeyPressEvent = !0;
                                                    break;

                                                  case "click":
                                                  case "focus":
                                                    return c.validationEvent ? (c.validationEvent = !1, e.blur(), (0, o.HandleNativePlaceholder)(e, (c.isRTL ? r.getBufferTemplate.call(c).slice().reverse() : r.getBufferTemplate.call(c)).join("")), 
                                                    setTimeout((function() {
                                                        e.focus();
                                                    }), f.validationEventTimeOut), !1) : (s = arguments, setTimeout((function() {
                                                        e.inputmask && i.apply(u, s);
                                                    }), 0), !1);
                                                }
                                                var p = i.apply(u, arguments);
                                                return !1 === p && (t.preventDefault(), t.stopPropagation()), p;
                                            }
                                            t.preventDefault();
                                        }
                                    };
                                    [ "submit", "reset" ].includes(t) ? (s = s.bind(e), null !== e.form && l(e.form).on(t, s)) : l(e).on(t, s), 
                                    e.inputmask.events[t] = e.inputmask.events[t] || [], e.inputmask.events[t].push(s);
                                },
                                off: function(e, t) {
                                    if (e.inputmask && e.inputmask.events) {
                                        var i = e.inputmask.dependencyLib, a = e.inputmask.events;
                                        for (var n in t && ((a = [])[t] = e.inputmask.events[t]), a) {
                                            for (var r = a[n]; r.length > 0; ) {
                                                var o = r.pop();
                                                [ "submit", "reset" ].includes(n) ? null !== e.form && i(e.form).off(n, o) : i(e).off(n, o);
                                            }
                                            delete e.inputmask.events[n];
                                        }
                                    }
                                }
                            };
                            t.EventRuler = s;
                        },
                        219: function(e, t, i) {
                            var a = d(i(2394)), n = d(i(5581)), r = d(i(7184)), o = i(8711), l = i(4713);
                            function s(e) {
                                return s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, s(e);
                            }
                            function u(e, t) {
                                return function(e) {
                                    if (Array.isArray(e)) return e;
                                }(e) || function(e, t) {
                                    var i = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                    if (null == i) return;
                                    var a, n, r = [], o = !0, l = !1;
                                    try {
                                        for (i = i.call(e); !(o = (a = i.next()).done) && (r.push(a.value), !t || r.length !== t); o = !0) ;
                                    } catch (e) {
                                        l = !0, n = e;
                                    } finally {
                                        try {
                                            o || null == i.return || i.return();
                                        } finally {
                                            if (l) throw n;
                                        }
                                    }
                                    return r;
                                }(e, t) || function(e, t) {
                                    if (!e) return;
                                    if ("string" == typeof e) return c(e, t);
                                    var i = Object.prototype.toString.call(e).slice(8, -1);
                                    "Object" === i && e.constructor && (i = e.constructor.name);
                                    if ("Map" === i || "Set" === i) return Array.from(e);
                                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return c(e, t);
                                }(e, t) || function() {
                                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                                }();
                            }
                            function c(e, t) {
                                (null == t || t > e.length) && (t = e.length);
                                for (var i = 0, a = new Array(t); i < t; i++) a[i] = e[i];
                                return a;
                            }
                            function f(e, t) {
                                for (var i = 0; i < t.length; i++) {
                                    var a = t[i];
                                    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), 
                                    Object.defineProperty(e, a.key, a);
                                }
                            }
                            function d(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var p = a.default.dependencyLib, h = function() {
                                function e(t, i, a) {
                                    !function(e, t) {
                                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
                                    }(this, e), this.mask = t, this.format = i, this.opts = a, this._date = new Date(1, 0, 1), 
                                    this.initDateObject(t, this.opts);
                                }
                                var t, i, a;
                                return t = e, (i = [ {
                                    key: "date",
                                    get: function() {
                                        return void 0 === this._date && (this._date = new Date(1, 0, 1), this.initDateObject(void 0, this.opts)), 
                                        this._date;
                                    }
                                }, {
                                    key: "initDateObject",
                                    value: function(e, t) {
                                        var i;
                                        for (P(t).lastIndex = 0; i = P(t).exec(this.format); ) {
                                            var a = new RegExp("\\d+$").exec(i[0]), n = a ? i[0][0] + "x" : i[0], r = void 0;
                                            if (void 0 !== e) {
                                                if (a) {
                                                    var o = P(t).lastIndex, l = O(i.index, t);
                                                    P(t).lastIndex = o, r = e.slice(0, e.indexOf(l.nextMatch[0]));
                                                } else r = e.slice(0, n.length);
                                                e = e.slice(r.length);
                                            }
                                            Object.prototype.hasOwnProperty.call(g, n) && this.setValue(this, r, n, g[n][2], g[n][1]);
                                        }
                                    }
                                }, {
                                    key: "setValue",
                                    value: function(e, t, i, a, n) {
                                        if (void 0 !== t && (e[a] = "ampm" === a ? t : t.replace(/[^0-9]/g, "0"), e["raw" + a] = t.replace(/\s/g, "_")), 
                                        void 0 !== n) {
                                            var r = e[a];
                                            ("day" === a && 29 === parseInt(r) || "month" === a && 2 === parseInt(r)) && (29 !== parseInt(e.day) || 2 !== parseInt(e.month) || "" !== e.year && void 0 !== e.year || e._date.setFullYear(2012, 1, 29)), 
                                            "day" === a && (m = !0, 0 === parseInt(r) && (r = 1)), "month" === a && (m = !0), 
                                            "year" === a && (m = !0, r.length < 4 && (r = _(r, 4, !0))), "" === r || isNaN(r) || n.call(e._date, r), 
                                            "ampm" === a && n.call(e._date, r);
                                        }
                                    }
                                }, {
                                    key: "reset",
                                    value: function() {
                                        this._date = new Date(1, 0, 1);
                                    }
                                }, {
                                    key: "reInit",
                                    value: function() {
                                        this._date = void 0, this.date;
                                    }
                                } ]) && f(t.prototype, i), a && f(t, a), Object.defineProperty(t, "prototype", {
                                    writable: !1
                                }), e;
                            }(), v = (new Date).getFullYear(), m = !1, g = {
                                d: [ "[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", Date.prototype.getDate ],
                                dd: [ "0[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", function() {
                                    return _(Date.prototype.getDate.call(this), 2);
                                } ],
                                ddd: [ "" ],
                                dddd: [ "" ],
                                m: [ "[1-9]|1[012]", function(e) {
                                    var t = e ? parseInt(e) : 0;
                                    return t > 0 && t--, Date.prototype.setMonth.call(this, t);
                                }, "month", function() {
                                    return Date.prototype.getMonth.call(this) + 1;
                                } ],
                                mm: [ "0[1-9]|1[012]", function(e) {
                                    var t = e ? parseInt(e) : 0;
                                    return t > 0 && t--, Date.prototype.setMonth.call(this, t);
                                }, "month", function() {
                                    return _(Date.prototype.getMonth.call(this) + 1, 2);
                                } ],
                                mmm: [ "" ],
                                mmmm: [ "" ],
                                yy: [ "[0-9]{2}", Date.prototype.setFullYear, "year", function() {
                                    return _(Date.prototype.getFullYear.call(this), 2);
                                } ],
                                yyyy: [ "[0-9]{4}", Date.prototype.setFullYear, "year", function() {
                                    return _(Date.prototype.getFullYear.call(this), 4);
                                } ],
                                h: [ "[1-9]|1[0-2]", Date.prototype.setHours, "hours", Date.prototype.getHours ],
                                hh: [ "0[1-9]|1[0-2]", Date.prototype.setHours, "hours", function() {
                                    return _(Date.prototype.getHours.call(this), 2);
                                } ],
                                hx: [ function(e) {
                                    return "[0-9]{".concat(e, "}");
                                }, Date.prototype.setHours, "hours", function(e) {
                                    return Date.prototype.getHours;
                                } ],
                                H: [ "1?[0-9]|2[0-3]", Date.prototype.setHours, "hours", Date.prototype.getHours ],
                                HH: [ "0[0-9]|1[0-9]|2[0-3]", Date.prototype.setHours, "hours", function() {
                                    return _(Date.prototype.getHours.call(this), 2);
                                } ],
                                Hx: [ function(e) {
                                    return "[0-9]{".concat(e, "}");
                                }, Date.prototype.setHours, "hours", function(e) {
                                    return function() {
                                        return _(Date.prototype.getHours.call(this), e);
                                    };
                                } ],
                                M: [ "[1-5]?[0-9]", Date.prototype.setMinutes, "minutes", Date.prototype.getMinutes ],
                                MM: [ "0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setMinutes, "minutes", function() {
                                    return _(Date.prototype.getMinutes.call(this), 2);
                                } ],
                                s: [ "[1-5]?[0-9]", Date.prototype.setSeconds, "seconds", Date.prototype.getSeconds ],
                                ss: [ "0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setSeconds, "seconds", function() {
                                    return _(Date.prototype.getSeconds.call(this), 2);
                                } ],
                                l: [ "[0-9]{3}", Date.prototype.setMilliseconds, "milliseconds", function() {
                                    return _(Date.prototype.getMilliseconds.call(this), 3);
                                } ],
                                L: [ "[0-9]{2}", Date.prototype.setMilliseconds, "milliseconds", function() {
                                    return _(Date.prototype.getMilliseconds.call(this), 2);
                                } ],
                                t: [ "[ap]", y, "ampm", b, 1 ],
                                tt: [ "[ap]m", y, "ampm", b, 2 ],
                                T: [ "[AP]", y, "ampm", b, 1 ],
                                TT: [ "[AP]M", y, "ampm", b, 2 ],
                                Z: [ ".*", void 0, "Z", function() {
                                    var e = this.toString().match(/\((.+)\)/)[1];
                                    e.includes(" ") && (e = (e = e.replace("-", " ").toUpperCase()).split(" ").map((function(e) {
                                        return u(e, 1)[0];
                                    })).join(""));
                                    return e;
                                } ],
                                o: [ "" ],
                                S: [ "" ]
                            }, k = {
                                isoDate: "yyyy-mm-dd",
                                isoTime: "HH:MM:ss",
                                isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
                                isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
                            };
                            function y(e) {
                                var t = this.getHours();
                                e.toLowerCase().includes("p") ? this.setHours(t + 12) : e.toLowerCase().includes("a") && t >= 12 && this.setHours(t - 12);
                            }
                            function b() {
                                var e = this.getHours();
                                return (e = e || 12) >= 12 ? "PM" : "AM";
                            }
                            function x(e) {
                                var t = new RegExp("\\d+$").exec(e[0]);
                                if (t && void 0 !== t[0]) {
                                    var i = g[e[0][0] + "x"].slice("");
                                    return i[0] = i[0](t[0]), i[3] = i[3](t[0]), i;
                                }
                                if (g[e[0]]) return g[e[0]];
                            }
                            function P(e) {
                                if (!e.tokenizer) {
                                    var t = [], i = [];
                                    for (var a in g) if (/\.*x$/.test(a)) {
                                        var n = a[0] + "\\d+";
                                        -1 === i.indexOf(n) && i.push(n);
                                    } else -1 === t.indexOf(a[0]) && t.push(a[0]);
                                    e.tokenizer = "(" + (i.length > 0 ? i.join("|") + "|" : "") + t.join("+|") + ")+?|.", 
                                    e.tokenizer = new RegExp(e.tokenizer, "g");
                                }
                                return e.tokenizer;
                            }
                            function E(e, t, i) {
                                if (!m) return !0;
                                if (void 0 === e.rawday || !isFinite(e.rawday) && new Date(e.date.getFullYear(), isFinite(e.rawmonth) ? e.month : e.date.getMonth() + 1, 0).getDate() >= e.day || "29" == e.day && (!isFinite(e.rawyear) || void 0 === e.rawyear || "" === e.rawyear) || new Date(e.date.getFullYear(), isFinite(e.rawmonth) ? e.month : e.date.getMonth() + 1, 0).getDate() >= e.day) return t;
                                if ("29" == e.day) {
                                    var a = O(t.pos, i);
                                    if ("yyyy" === a.targetMatch[0] && t.pos - a.targetMatchIndex == 2) return t.remove = t.pos + 1, 
                                    t;
                                } else if ("02" == e.month && "30" == e.day && void 0 !== t.c) return e.day = "03", 
                                e.date.setDate(3), e.date.setMonth(1), t.insert = [ {
                                    pos: t.pos,
                                    c: "0"
                                }, {
                                    pos: t.pos + 1,
                                    c: t.c
                                } ], t.caret = o.seekNext.call(this, t.pos + 1), t;
                                return !1;
                            }
                            function S(e, t, i, a) {
                                var n, o, l = "";
                                for (P(i).lastIndex = 0; n = P(i).exec(e); ) if (void 0 === t) if (o = x(n)) l += "(" + o[0] + ")"; else switch (n[0]) {
                                  case "[":
                                    l += "(";
                                    break;

                                  case "]":
                                    l += ")?";
                                    break;

                                  default:
                                    l += (0, r.default)(n[0]);
                                } else if (o = x(n)) if (!0 !== a && o[3]) l += o[3].call(t.date); else o[2] ? l += t["raw" + o[2]] : l += n[0]; else l += n[0];
                                return l;
                            }
                            function _(e, t, i) {
                                for (e = String(e), t = t || 2; e.length < t; ) e = i ? e + "0" : "0" + e;
                                return e;
                            }
                            function w(e, t, i) {
                                return "string" == typeof e ? new h(e, t, i) : e && "object" === s(e) && Object.prototype.hasOwnProperty.call(e, "date") ? e : void 0;
                            }
                            function M(e, t) {
                                return S(t.inputFormat, {
                                    date: e
                                }, t);
                            }
                            function O(e, t) {
                                var i, a, n = 0, r = 0;
                                for (P(t).lastIndex = 0; a = P(t).exec(t.inputFormat); ) {
                                    var o = new RegExp("\\d+$").exec(a[0]);
                                    if ((n += r = o ? parseInt(o[0]) : a[0].length) >= e + 1) {
                                        i = a, a = P(t).exec(t.inputFormat);
                                        break;
                                    }
                                }
                                return {
                                    targetMatchIndex: n - r,
                                    nextMatch: a,
                                    targetMatch: i
                                };
                            }
                            a.default.extendAliases({
                                datetime: {
                                    mask: function(e) {
                                        return e.numericInput = !1, g.S = e.i18n.ordinalSuffix.join("|"), e.inputFormat = k[e.inputFormat] || e.inputFormat, 
                                        e.displayFormat = k[e.displayFormat] || e.displayFormat || e.inputFormat, e.outputFormat = k[e.outputFormat] || e.outputFormat || e.inputFormat, 
                                        e.placeholder = "" !== e.placeholder ? e.placeholder : e.inputFormat.replace(/[[\]]/, ""), 
                                        e.regex = S(e.inputFormat, void 0, e), e.min = w(e.min, e.inputFormat, e), e.max = w(e.max, e.inputFormat, e), 
                                        null;
                                    },
                                    placeholder: "",
                                    inputFormat: "isoDateTime",
                                    displayFormat: null,
                                    outputFormat: null,
                                    min: null,
                                    max: null,
                                    skipOptionalPartCharacter: "",
                                    i18n: {
                                        dayNames: [ "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" ],
                                        monthNames: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                                        ordinalSuffix: [ "st", "nd", "rd", "th" ]
                                    },
                                    preValidation: function(e, t, i, a, n, r, o, l) {
                                        if (l) return !0;
                                        if (isNaN(i) && e[t] !== i) {
                                            var s = O(t, n);
                                            if (s.nextMatch && s.nextMatch[0] === i && s.targetMatch[0].length > 1) {
                                                var u = g[s.targetMatch[0]][0];
                                                if (new RegExp(u).test("0" + e[t - 1])) return e[t] = e[t - 1], e[t - 1] = "0", 
                                                {
                                                    fuzzy: !0,
                                                    buffer: e,
                                                    refreshFromBuffer: {
                                                        start: t - 1,
                                                        end: t + 1
                                                    },
                                                    pos: t + 1
                                                };
                                            }
                                        }
                                        return !0;
                                    },
                                    postValidation: function(e, t, i, a, n, r, o, s) {
                                        var u, c;
                                        if (o) return !0;
                                        if (!1 === a && (((u = O(t + 1, n)).targetMatch && u.targetMatchIndex === t && u.targetMatch[0].length > 1 && void 0 !== g[u.targetMatch[0]] || (u = O(t + 2, n)).targetMatch && u.targetMatchIndex === t + 1 && u.targetMatch[0].length > 1 && void 0 !== g[u.targetMatch[0]]) && (c = g[u.targetMatch[0]][0]), 
                                        void 0 !== c && (void 0 !== r.validPositions[t + 1] && new RegExp(c).test(i + "0") ? (e[t] = i, 
                                        e[t + 1] = "0", a = {
                                            pos: t + 2,
                                            caret: t
                                        }) : new RegExp(c).test("0" + i) && (e[t] = "0", e[t + 1] = i, a = {
                                            pos: t + 2
                                        })), !1 === a)) return a;
                                        if (a.fuzzy && (e = a.buffer, t = a.pos), (u = O(t, n)).targetMatch && u.targetMatch[0] && void 0 !== g[u.targetMatch[0]]) {
                                            var f = g[u.targetMatch[0]];
                                            c = f[0];
                                            var d = e.slice(u.targetMatchIndex, u.targetMatchIndex + u.targetMatch[0].length);
                                            if (!1 === new RegExp(c).test(d.join("")) && 2 === u.targetMatch[0].length && r.validPositions[u.targetMatchIndex] && r.validPositions[u.targetMatchIndex + 1] && (r.validPositions[u.targetMatchIndex + 1].input = "0"), 
                                            "year" == f[2]) for (var p = l.getMaskTemplate.call(this, !1, 1, void 0, !0), h = t + 1; h < e.length; h++) e[h] = p[h], 
                                            delete r.validPositions[h];
                                        }
                                        var m = a, k = w(e.join(""), n.inputFormat, n);
                                        return m && k.date.getTime() == k.date.getTime() && (n.prefillYear && (m = function(e, t, i) {
                                            if (e.year !== e.rawyear) {
                                                var a = v.toString(), n = e.rawyear.replace(/[^0-9]/g, ""), r = a.slice(0, n.length), o = a.slice(n.length);
                                                if (2 === n.length && n === r) {
                                                    var l = new Date(v, e.month - 1, e.day);
                                                    e.day == l.getDate() && (!i.max || i.max.date.getTime() >= l.getTime()) && (e.date.setFullYear(v), 
                                                    e.year = a, t.insert = [ {
                                                        pos: t.pos + 1,
                                                        c: o[0]
                                                    }, {
                                                        pos: t.pos + 2,
                                                        c: o[1]
                                                    } ]);
                                                }
                                            }
                                            return t;
                                        }(k, m, n)), m = function(e, t, i, a, n) {
                                            if (!t) return t;
                                            if (t && i.min && i.min.date.getTime() == i.min.date.getTime()) {
                                                var r;
                                                for (e.reset(), P(i).lastIndex = 0; r = P(i).exec(i.inputFormat); ) {
                                                    var o;
                                                    if ((o = x(r)) && o[3]) {
                                                        for (var l = o[1], s = e[o[2]], u = i.min[o[2]], c = i.max ? i.max[o[2]] : u, f = [], d = !1, p = 0; p < u.length; p++) void 0 !== a.validPositions[p + r.index] || d ? (f[p] = s[p], 
                                                        d = d || s[p] > u[p]) : (f[p] = u[p], "year" === o[2] && s.length - 1 == p && u != c && (f = (parseInt(f.join("")) + 1).toString().split("")), 
                                                        "ampm" === o[2] && u != c && i.min.date.getTime() > e.date.getTime() && (f[p] = c[p]));
                                                        l.call(e._date, f.join(""));
                                                    }
                                                }
                                                t = i.min.date.getTime() <= e.date.getTime(), e.reInit();
                                            }
                                            return t && i.max && i.max.date.getTime() == i.max.date.getTime() && (t = i.max.date.getTime() >= e.date.getTime()), 
                                            t;
                                        }(k, m = E.call(this, k, m, n), n, r)), void 0 !== t && m && a.pos !== t ? {
                                            buffer: S(n.inputFormat, k, n).split(""),
                                            refreshFromBuffer: {
                                                start: t,
                                                end: a.pos
                                            },
                                            pos: a.caret || a.pos
                                        } : m;
                                    },
                                    onKeyDown: function(e, t, i, a) {
                                        e.ctrlKey && e.keyCode === n.default.RIGHT && (this.inputmask._valueSet(M(new Date, a)), 
                                        p(this).trigger("setvalue"));
                                    },
                                    onUnMask: function(e, t, i) {
                                        return t ? S(i.outputFormat, w(e, i.inputFormat, i), i, !0) : t;
                                    },
                                    casing: function(e, t, i, a) {
                                        return 0 == t.nativeDef.indexOf("[ap]") ? e.toLowerCase() : 0 == t.nativeDef.indexOf("[AP]") ? e.toUpperCase() : e;
                                    },
                                    onBeforeMask: function(e, t) {
                                        return "[object Date]" === Object.prototype.toString.call(e) && (e = M(e, t)), e;
                                    },
                                    insertMode: !1,
                                    shiftPositions: !1,
                                    keepStatic: !1,
                                    inputmode: "numeric",
                                    prefillYear: !0
                                }
                            });
                        },
                        3851: function(e, t, i) {
                            var a, n = (a = i(2394)) && a.__esModule ? a : {
                                default: a
                            }, r = i(8711), o = i(4713);
                            n.default.extendDefinitions({
                                A: {
                                    validator: "[A-Za-zА-яЁёÀ-ÿµ]",
                                    casing: "upper"
                                },
                                "&": {
                                    validator: "[0-9A-Za-zА-яЁёÀ-ÿµ]",
                                    casing: "upper"
                                },
                                "#": {
                                    validator: "[0-9A-Fa-f]",
                                    casing: "upper"
                                }
                            });
                            var l = new RegExp("25[0-5]|2[0-4][0-9]|[01][0-9][0-9]");
                            function s(e, t, i, a, n) {
                                return i - 1 > -1 && "." !== t.buffer[i - 1] ? (e = t.buffer[i - 1] + e, e = i - 2 > -1 && "." !== t.buffer[i - 2] ? t.buffer[i - 2] + e : "0" + e) : e = "00" + e, 
                                l.test(e);
                            }
                            n.default.extendAliases({
                                cssunit: {
                                    regex: "[+-]?[0-9]+\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)"
                                },
                                url: {
                                    regex: "(https?|ftp)://.*",
                                    autoUnmask: !1,
                                    keepStatic: !1,
                                    tabThrough: !0
                                },
                                ip: {
                                    mask: "i{1,3}.j{1,3}.k{1,3}.l{1,3}",
                                    definitions: {
                                        i: {
                                            validator: s
                                        },
                                        j: {
                                            validator: s
                                        },
                                        k: {
                                            validator: s
                                        },
                                        l: {
                                            validator: s
                                        }
                                    },
                                    onUnMask: function(e, t, i) {
                                        return e;
                                    },
                                    inputmode: "decimal",
                                    substitutes: {
                                        ",": "."
                                    }
                                },
                                email: {
                                    mask: function(e) {
                                        var t = "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]", i = t;
                                        if (e.separator) for (var a = 0; a < e.quantifier; a++) i += "[".concat(e.separator).concat(t, "]");
                                        return i;
                                    },
                                    greedy: !1,
                                    casing: "lower",
                                    separator: null,
                                    quantifier: 5,
                                    skipOptionalPartCharacter: "",
                                    onBeforePaste: function(e, t) {
                                        return (e = e.toLowerCase()).replace("mailto:", "");
                                    },
                                    definitions: {
                                        "*": {
                                            validator: "[0-9１-９A-Za-zА-яЁёÀ-ÿµ!#$%&'*+/=?^_`{|}~-]"
                                        },
                                        "-": {
                                            validator: "[0-9A-Za-z-]"
                                        }
                                    },
                                    onUnMask: function(e, t, i) {
                                        return e;
                                    },
                                    inputmode: "email"
                                },
                                mac: {
                                    mask: "##:##:##:##:##:##"
                                },
                                vin: {
                                    mask: "V{13}9{4}",
                                    definitions: {
                                        V: {
                                            validator: "[A-HJ-NPR-Za-hj-npr-z\\d]",
                                            casing: "upper"
                                        }
                                    },
                                    clearIncomplete: !0,
                                    autoUnmask: !0
                                },
                                ssn: {
                                    mask: "999-99-9999",
                                    postValidation: function(e, t, i, a, n, l, s) {
                                        var u = o.getMaskTemplate.call(this, !0, r.getLastValidPosition.call(this), !0, !0);
                                        return /^(?!219-09-9999|078-05-1120)(?!666|000|9.{2}).{3}-(?!00).{2}-(?!0{4}).{4}$/.test(u.join(""));
                                    }
                                }
                            });
                        },
                        207: function(e, t, i) {
                            var a = l(i(2394)), n = l(i(5581)), r = l(i(7184)), o = i(8711);
                            function l(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var s = a.default.dependencyLib;
                            function u(e, t) {
                                for (var i = "", n = 0; n < e.length; n++) a.default.prototype.definitions[e.charAt(n)] || t.definitions[e.charAt(n)] || t.optionalmarker[0] === e.charAt(n) || t.optionalmarker[1] === e.charAt(n) || t.quantifiermarker[0] === e.charAt(n) || t.quantifiermarker[1] === e.charAt(n) || t.groupmarker[0] === e.charAt(n) || t.groupmarker[1] === e.charAt(n) || t.alternatormarker === e.charAt(n) ? i += "\\" + e.charAt(n) : i += e.charAt(n);
                                return i;
                            }
                            function c(e, t, i, a) {
                                if (e.length > 0 && t > 0 && (!i.digitsOptional || a)) {
                                    var n = e.indexOf(i.radixPoint), r = !1;
                                    i.negationSymbol.back === e[e.length - 1] && (r = !0, e.length--), -1 === n && (e.push(i.radixPoint), 
                                    n = e.length - 1);
                                    for (var o = 1; o <= t; o++) isFinite(e[n + o]) || (e[n + o] = "0");
                                }
                                return r && e.push(i.negationSymbol.back), e;
                            }
                            function f(e, t) {
                                var i = 0;
                                if ("+" === e) {
                                    for (i in t.validPositions) ;
                                    i = o.seekNext.call(this, parseInt(i));
                                }
                                for (var a in t.tests) if ((a = parseInt(a)) >= i) for (var n = 0, r = t.tests[a].length; n < r; n++) if ((void 0 === t.validPositions[a] || "-" === e) && t.tests[a][n].match.def === e) return a + (void 0 !== t.validPositions[a] && "-" !== e ? 1 : 0);
                                return i;
                            }
                            function d(e, t) {
                                var i = -1;
                                for (var a in t.validPositions) {
                                    var n = t.validPositions[a];
                                    if (n && n.match.def === e) {
                                        i = parseInt(a);
                                        break;
                                    }
                                }
                                return i;
                            }
                            function p(e, t, i, a, n) {
                                var r = t.buffer ? t.buffer.indexOf(n.radixPoint) : -1, o = (-1 !== r || a && n.jitMasking) && new RegExp(n.definitions[9].validator).test(e);
                                return n._radixDance && -1 !== r && o && null == t.validPositions[r] ? {
                                    insert: {
                                        pos: r === i ? r + 1 : r,
                                        c: n.radixPoint
                                    },
                                    pos: i
                                } : o;
                            }
                            a.default.extendAliases({
                                numeric: {
                                    mask: function(e) {
                                        e.repeat = 0, e.groupSeparator === e.radixPoint && e.digits && "0" !== e.digits && ("." === e.radixPoint ? e.groupSeparator = "," : "," === e.radixPoint ? e.groupSeparator = "." : e.groupSeparator = ""), 
                                        " " === e.groupSeparator && (e.skipOptionalPartCharacter = void 0), e.placeholder.length > 1 && (e.placeholder = e.placeholder.charAt(0)), 
                                        "radixFocus" === e.positionCaretOnClick && "" === e.placeholder && (e.positionCaretOnClick = "lvp");
                                        var t = "0", i = e.radixPoint;
                                        !0 === e.numericInput && void 0 === e.__financeInput ? (t = "1", e.positionCaretOnClick = "radixFocus" === e.positionCaretOnClick ? "lvp" : e.positionCaretOnClick, 
                                        e.digitsOptional = !1, isNaN(e.digits) && (e.digits = 2), e._radixDance = !1, i = "," === e.radixPoint ? "?" : "!", 
                                        "" !== e.radixPoint && void 0 === e.definitions[i] && (e.definitions[i] = {}, e.definitions[i].validator = "[" + e.radixPoint + "]", 
                                        e.definitions[i].placeholder = e.radixPoint, e.definitions[i].static = !0, e.definitions[i].generated = !0)) : (e.__financeInput = !1, 
                                        e.numericInput = !0);
                                        var a, n = "[+]";
                                        if (n += u(e.prefix, e), "" !== e.groupSeparator ? (void 0 === e.definitions[e.groupSeparator] && (e.definitions[e.groupSeparator] = {}, 
                                        e.definitions[e.groupSeparator].validator = "[" + e.groupSeparator + "]", e.definitions[e.groupSeparator].placeholder = e.groupSeparator, 
                                        e.definitions[e.groupSeparator].static = !0, e.definitions[e.groupSeparator].generated = !0), 
                                        n += e._mask(e)) : n += "9{+}", void 0 !== e.digits && 0 !== e.digits) {
                                            var o = e.digits.toString().split(",");
                                            isFinite(o[0]) && o[1] && isFinite(o[1]) ? n += i + t + "{" + e.digits + "}" : (isNaN(e.digits) || parseInt(e.digits) > 0) && (e.digitsOptional || e.jitMasking ? (a = n + i + t + "{0," + e.digits + "}", 
                                            e.keepStatic = !0) : n += i + t + "{" + e.digits + "}");
                                        } else e.inputmode = "numeric";
                                        return n += u(e.suffix, e), n += "[-]", a && (n = [ a + u(e.suffix, e) + "[-]", n ]), 
                                        e.greedy = !1, function(e) {
                                            void 0 === e.parseMinMaxOptions && (null !== e.min && (e.min = e.min.toString().replace(new RegExp((0, 
                                            r.default)(e.groupSeparator), "g"), ""), "," === e.radixPoint && (e.min = e.min.replace(e.radixPoint, ".")), 
                                            e.min = isFinite(e.min) ? parseFloat(e.min) : NaN, isNaN(e.min) && (e.min = Number.MIN_VALUE)), 
                                            null !== e.max && (e.max = e.max.toString().replace(new RegExp((0, r.default)(e.groupSeparator), "g"), ""), 
                                            "," === e.radixPoint && (e.max = e.max.replace(e.radixPoint, ".")), e.max = isFinite(e.max) ? parseFloat(e.max) : NaN, 
                                            isNaN(e.max) && (e.max = Number.MAX_VALUE)), e.parseMinMaxOptions = "done");
                                        }(e), "" !== e.radixPoint && (e.substitutes["." == e.radixPoint ? "," : "."] = e.radixPoint), 
                                        n;
                                    },
                                    _mask: function(e) {
                                        return "(" + e.groupSeparator + "999){+|1}";
                                    },
                                    digits: "*",
                                    digitsOptional: !0,
                                    enforceDigitsOnBlur: !1,
                                    radixPoint: ".",
                                    positionCaretOnClick: "radixFocus",
                                    _radixDance: !0,
                                    groupSeparator: "",
                                    allowMinus: !0,
                                    negationSymbol: {
                                        front: "-",
                                        back: ""
                                    },
                                    prefix: "",
                                    suffix: "",
                                    min: null,
                                    max: null,
                                    SetMaxOnOverflow: !1,
                                    step: 1,
                                    inputType: "text",
                                    unmaskAsNumber: !1,
                                    roundingFN: Math.round,
                                    inputmode: "decimal",
                                    shortcuts: {
                                        k: "1000",
                                        m: "1000000"
                                    },
                                    placeholder: "0",
                                    greedy: !1,
                                    rightAlign: !0,
                                    insertMode: !0,
                                    autoUnmask: !1,
                                    skipOptionalPartCharacter: "",
                                    usePrototypeDefinitions: !1,
                                    stripLeadingZeroes: !0,
                                    definitions: {
                                        0: {
                                            validator: p
                                        },
                                        1: {
                                            validator: p,
                                            definitionSymbol: "9"
                                        },
                                        9: {
                                            validator: "[0-9０-９٠-٩۰-۹]",
                                            definitionSymbol: "*"
                                        },
                                        "+": {
                                            validator: function(e, t, i, a, n) {
                                                return n.allowMinus && ("-" === e || e === n.negationSymbol.front);
                                            }
                                        },
                                        "-": {
                                            validator: function(e, t, i, a, n) {
                                                return n.allowMinus && e === n.negationSymbol.back;
                                            }
                                        }
                                    },
                                    preValidation: function(e, t, i, a, n, r, o, l) {
                                        if (!1 !== n.__financeInput && i === n.radixPoint) return !1;
                                        var s = e.indexOf(n.radixPoint), u = t;
                                        if (t = function(e, t, i, a, n) {
                                            return n._radixDance && n.numericInput && t !== n.negationSymbol.back && e <= i && (i > 0 || t == n.radixPoint) && (void 0 === a.validPositions[e - 1] || a.validPositions[e - 1].input !== n.negationSymbol.back) && (e -= 1), 
                                            e;
                                        }(t, i, s, r, n), "-" === i || i === n.negationSymbol.front) {
                                            if (!0 !== n.allowMinus) return !1;
                                            var c = !1, p = d("+", r), h = d("-", r);
                                            return -1 !== p && (c = [ p, h ]), !1 !== c ? {
                                                remove: c,
                                                caret: u - n.negationSymbol.back.length
                                            } : {
                                                insert: [ {
                                                    pos: f.call(this, "+", r),
                                                    c: n.negationSymbol.front,
                                                    fromIsValid: !0
                                                }, {
                                                    pos: f.call(this, "-", r),
                                                    c: n.negationSymbol.back,
                                                    fromIsValid: void 0
                                                } ],
                                                caret: u + n.negationSymbol.back.length
                                            };
                                        }
                                        if (i === n.groupSeparator) return {
                                            caret: u
                                        };
                                        if (l) return !0;
                                        if (-1 !== s && !0 === n._radixDance && !1 === a && i === n.radixPoint && void 0 !== n.digits && (isNaN(n.digits) || parseInt(n.digits) > 0) && s !== t) return {
                                            caret: n._radixDance && t === s - 1 ? s + 1 : s
                                        };
                                        if (!1 === n.__financeInput) if (a) {
                                            if (n.digitsOptional) return {
                                                rewritePosition: o.end
                                            };
                                            if (!n.digitsOptional) {
                                                if (o.begin > s && o.end <= s) return i === n.radixPoint ? {
                                                    insert: {
                                                        pos: s + 1,
                                                        c: "0",
                                                        fromIsValid: !0
                                                    },
                                                    rewritePosition: s
                                                } : {
                                                    rewritePosition: s + 1
                                                };
                                                if (o.begin < s) return {
                                                    rewritePosition: o.begin - 1
                                                };
                                            }
                                        } else if (!n.showMaskOnHover && !n.showMaskOnFocus && !n.digitsOptional && n.digits > 0 && "" === this.__valueGet.call(this.el)) return {
                                            rewritePosition: s
                                        };
                                        return {
                                            rewritePosition: t
                                        };
                                    },
                                    postValidation: function(e, t, i, a, n, r, o) {
                                        if (!1 === a) return a;
                                        if (o) return !0;
                                        if (null !== n.min || null !== n.max) {
                                            var l = n.onUnMask(e.slice().reverse().join(""), void 0, s.extend({}, n, {
                                                unmaskAsNumber: !0
                                            }));
                                            if (null !== n.min && l < n.min && (l.toString().length > n.min.toString().length || l < 0)) return !1;
                                            if (null !== n.max && l > n.max) return !!n.SetMaxOnOverflow && {
                                                refreshFromBuffer: !0,
                                                buffer: c(n.max.toString().replace(".", n.radixPoint).split(""), n.digits, n).reverse()
                                            };
                                        }
                                        return a;
                                    },
                                    onUnMask: function(e, t, i) {
                                        if ("" === t && !0 === i.nullable) return t;
                                        var a = e.replace(i.prefix, "");
                                        return a = (a = a.replace(i.suffix, "")).replace(new RegExp((0, r.default)(i.groupSeparator), "g"), ""), 
                                        "" !== i.placeholder.charAt(0) && (a = a.replace(new RegExp(i.placeholder.charAt(0), "g"), "0")), 
                                        i.unmaskAsNumber ? ("" !== i.radixPoint && -1 !== a.indexOf(i.radixPoint) && (a = a.replace(r.default.call(this, i.radixPoint), ".")), 
                                        a = (a = a.replace(new RegExp("^" + (0, r.default)(i.negationSymbol.front)), "-")).replace(new RegExp((0, 
                                        r.default)(i.negationSymbol.back) + "$"), ""), Number(a)) : a;
                                    },
                                    isComplete: function(e, t) {
                                        var i = (t.numericInput ? e.slice().reverse() : e).join("");
                                        return i = (i = (i = (i = (i = i.replace(new RegExp("^" + (0, r.default)(t.negationSymbol.front)), "-")).replace(new RegExp((0, 
                                        r.default)(t.negationSymbol.back) + "$"), "")).replace(t.prefix, "")).replace(t.suffix, "")).replace(new RegExp((0, 
                                        r.default)(t.groupSeparator) + "([0-9]{3})", "g"), "$1"), "," === t.radixPoint && (i = i.replace((0, 
                                        r.default)(t.radixPoint), ".")), isFinite(i);
                                    },
                                    onBeforeMask: function(e, t) {
                                        var i = t.radixPoint || ",";
                                        isFinite(t.digits) && (t.digits = parseInt(t.digits)), "number" != typeof e && "number" !== t.inputType || "" === i || (e = e.toString().replace(".", i));
                                        var a = "-" === e.charAt(0) || e.charAt(0) === t.negationSymbol.front, n = e.split(i), o = n[0].replace(/[^\-0-9]/g, ""), l = n.length > 1 ? n[1].replace(/[^0-9]/g, "") : "", s = n.length > 1;
                                        e = o + ("" !== l ? i + l : l);
                                        var u = 0;
                                        if ("" !== i && (u = t.digitsOptional ? t.digits < l.length ? t.digits : l.length : t.digits, 
                                        "" !== l || !t.digitsOptional)) {
                                            var f = Math.pow(10, u || 1);
                                            e = e.replace((0, r.default)(i), "."), isNaN(parseFloat(e)) || (e = (t.roundingFN(parseFloat(e) * f) / f).toFixed(u)), 
                                            e = e.toString().replace(".", i);
                                        }
                                        if (0 === t.digits && -1 !== e.indexOf(i) && (e = e.substring(0, e.indexOf(i))), 
                                        null !== t.min || null !== t.max) {
                                            var d = e.toString().replace(i, ".");
                                            null !== t.min && d < t.min ? e = t.min.toString().replace(".", i) : null !== t.max && d > t.max && (e = t.max.toString().replace(".", i));
                                        }
                                        return a && "-" !== e.charAt(0) && (e = "-" + e), c(e.toString().split(""), u, t, s).join("");
                                    },
                                    onBeforeWrite: function(e, t, i, a) {
                                        function n(e, t) {
                                            if (!1 !== a.__financeInput || t) {
                                                var i = e.indexOf(a.radixPoint);
                                                -1 !== i && e.splice(i, 1);
                                            }
                                            if ("" !== a.groupSeparator) for (;-1 !== (i = e.indexOf(a.groupSeparator)); ) e.splice(i, 1);
                                            return e;
                                        }
                                        var o, l;
                                        if (a.stripLeadingZeroes && (l = function(e, t) {
                                            var i = new RegExp("(^" + ("" !== t.negationSymbol.front ? (0, r.default)(t.negationSymbol.front) + "?" : "") + (0, 
                                            r.default)(t.prefix) + ")(.*)(" + (0, r.default)(t.suffix) + ("" != t.negationSymbol.back ? (0, 
                                            r.default)(t.negationSymbol.back) + "?" : "") + "$)").exec(e.slice().reverse().join("")), a = i ? i[2] : "", n = !1;
                                            return a && (a = a.split(t.radixPoint.charAt(0))[0], n = new RegExp("^[0" + t.groupSeparator + "]*").exec(a)), 
                                            !(!n || !(n[0].length > 1 || n[0].length > 0 && n[0].length < a.length)) && n;
                                        }(t, a))) for (var u = t.join("").lastIndexOf(l[0].split("").reverse().join("")) - (l[0] == l.input ? 0 : 1), f = l[0] == l.input ? 1 : 0, d = l[0].length - f; d > 0; d--) delete this.maskset.validPositions[u + d], 
                                        delete t[u + d];
                                        if (e) switch (e.type) {
                                          case "blur":
                                          case "checkval":
                                            if (null !== a.min) {
                                                var p = a.onUnMask(t.slice().reverse().join(""), void 0, s.extend({}, a, {
                                                    unmaskAsNumber: !0
                                                }));
                                                if (null !== a.min && p < a.min) return {
                                                    refreshFromBuffer: !0,
                                                    buffer: c(a.min.toString().replace(".", a.radixPoint).split(""), a.digits, a).reverse()
                                                };
                                            }
                                            if (t[t.length - 1] === a.negationSymbol.front) {
                                                var h = new RegExp("(^" + ("" != a.negationSymbol.front ? (0, r.default)(a.negationSymbol.front) + "?" : "") + (0, 
                                                r.default)(a.prefix) + ")(.*)(" + (0, r.default)(a.suffix) + ("" != a.negationSymbol.back ? (0, 
                                                r.default)(a.negationSymbol.back) + "?" : "") + "$)").exec(n(t.slice(), !0).reverse().join(""));
                                                0 == (h ? h[2] : "") && (o = {
                                                    refreshFromBuffer: !0,
                                                    buffer: [ 0 ]
                                                });
                                            } else if ("" !== a.radixPoint) t.indexOf(a.radixPoint) === a.suffix.length && (o && o.buffer ? o.buffer.splice(0, 1 + a.suffix.length) : (t.splice(0, 1 + a.suffix.length), 
                                            o = {
                                                refreshFromBuffer: !0,
                                                buffer: n(t)
                                            }));
                                            if (a.enforceDigitsOnBlur) {
                                                var v = (o = o || {}) && o.buffer || t.slice().reverse();
                                                o.refreshFromBuffer = !0, o.buffer = c(v, a.digits, a, !0).reverse();
                                            }
                                        }
                                        return o;
                                    },
                                    onKeyDown: function(e, t, i, a) {
                                        var r, o, l = s(this), u = String.fromCharCode(e.keyCode).toLowerCase();
                                        if ((o = a.shortcuts && a.shortcuts[u]) && o.length > 1) return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) * parseInt(o)), 
                                        l.trigger("setvalue"), !1;
                                        if (e.ctrlKey) switch (e.keyCode) {
                                          case n.default.UP:
                                            return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(a.step)), 
                                            l.trigger("setvalue"), !1;

                                          case n.default.DOWN:
                                            return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(a.step)), 
                                            l.trigger("setvalue"), !1;
                                        }
                                        if (!e.shiftKey && (e.keyCode === n.default.DELETE || e.keyCode === n.default.BACKSPACE || e.keyCode === n.default.BACKSPACE_SAFARI) && i.begin !== t.length) {
                                            if (t[e.keyCode === n.default.DELETE ? i.begin - 1 : i.end] === a.negationSymbol.front) return r = t.slice().reverse(), 
                                            "" !== a.negationSymbol.front && r.shift(), "" !== a.negationSymbol.back && r.pop(), 
                                            l.trigger("setvalue", [ r.join(""), i.begin ]), !1;
                                            if (!0 === a._radixDance) {
                                                var f = t.indexOf(a.radixPoint);
                                                if (a.digitsOptional) {
                                                    if (0 === f) return (r = t.slice().reverse()).pop(), l.trigger("setvalue", [ r.join(""), i.begin >= r.length ? r.length : i.begin ]), 
                                                    !1;
                                                } else if (-1 !== f && (i.begin < f || i.end < f || e.keyCode === n.default.DELETE && i.begin === f)) return i.begin !== i.end || e.keyCode !== n.default.BACKSPACE && e.keyCode !== n.default.BACKSPACE_SAFARI || i.begin++, 
                                                (r = t.slice().reverse()).splice(r.length - i.begin, i.begin - i.end + 1), r = c(r, a.digits, a).join(""), 
                                                l.trigger("setvalue", [ r, i.begin >= r.length ? f + 1 : i.begin ]), !1;
                                            }
                                        }
                                    }
                                },
                                currency: {
                                    prefix: "",
                                    groupSeparator: ",",
                                    alias: "numeric",
                                    digits: 2,
                                    digitsOptional: !1
                                },
                                decimal: {
                                    alias: "numeric"
                                },
                                integer: {
                                    alias: "numeric",
                                    inputmode: "numeric",
                                    digits: 0
                                },
                                percentage: {
                                    alias: "numeric",
                                    min: 0,
                                    max: 100,
                                    suffix: " %",
                                    digits: 0,
                                    allowMinus: !1
                                },
                                indianns: {
                                    alias: "numeric",
                                    _mask: function(e) {
                                        return "(" + e.groupSeparator + "99){*|1}(" + e.groupSeparator + "999){1|1}";
                                    },
                                    groupSeparator: ",",
                                    radixPoint: ".",
                                    placeholder: "0",
                                    digits: 2,
                                    digitsOptional: !1
                                }
                            });
                        },
                        9380: function(e, t, i) {
                            var a;
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0;
                            var n = ((a = i(8741)) && a.__esModule ? a : {
                                default: a
                            }).default ? window : {};
                            t.default = n;
                        },
                        7760: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.HandleNativePlaceholder = function(e, t) {
                                var i = e ? e.inputmask : this;
                                if (s.ie) {
                                    if (e.inputmask._valueGet() !== t && (e.placeholder !== t || "" === e.placeholder)) {
                                        var a = o.getBuffer.call(i).slice(), n = e.inputmask._valueGet();
                                        if (n !== t) {
                                            var r = o.getLastValidPosition.call(i);
                                            -1 === r && n === o.getBufferTemplate.call(i).join("") ? a = [] : -1 !== r && f.call(i, a), 
                                            p(e, a);
                                        }
                                    }
                                } else e.placeholder !== t && (e.placeholder = t, "" === e.placeholder && e.removeAttribute("placeholder"));
                            }, t.applyInputValue = c, t.checkVal = d, t.clearOptionalTail = f, t.unmaskedvalue = function(e) {
                                var t = e ? e.inputmask : this, i = t.opts, a = t.maskset;
                                if (e) {
                                    if (void 0 === e.inputmask) return e.value;
                                    e.inputmask && e.inputmask.refreshValue && c(e, e.inputmask._valueGet(!0));
                                }
                                var n = [], r = a.validPositions;
                                for (var l in r) r[l] && r[l].match && (1 != r[l].match.static || Array.isArray(a.metadata) && !0 !== r[l].generatedInput) && n.push(r[l].input);
                                var s = 0 === n.length ? "" : (t.isRTL ? n.reverse() : n).join("");
                                if ("function" == typeof i.onUnMask) {
                                    var u = (t.isRTL ? o.getBuffer.call(t).slice().reverse() : o.getBuffer.call(t)).join("");
                                    s = i.onUnMask.call(t, u, s, i);
                                }
                                return s;
                            }, t.writeBuffer = p;
                            var a, n = (a = i(5581)) && a.__esModule ? a : {
                                default: a
                            }, r = i(4713), o = i(8711), l = i(7215), s = i(9845), u = i(6030);
                            function c(e, t) {
                                var i = e ? e.inputmask : this, a = i.opts;
                                e.inputmask.refreshValue = !1, "function" == typeof a.onBeforeMask && (t = a.onBeforeMask.call(i, t, a) || t), 
                                d(e, !0, !1, t = t.toString().split("")), i.undoValue = i._valueGet(!0), (a.clearMaskOnLostFocus || a.clearIncomplete) && e.inputmask._valueGet() === o.getBufferTemplate.call(i).join("") && -1 === o.getLastValidPosition.call(i) && e.inputmask._valueSet("");
                            }
                            function f(e) {
                                e.length = 0;
                                for (var t, i = r.getMaskTemplate.call(this, !0, 0, !0, void 0, !0); void 0 !== (t = i.shift()); ) e.push(t);
                                return e;
                            }
                            function d(e, t, i, a, n) {
                                var s = e ? e.inputmask : this, c = s.maskset, f = s.opts, d = s.dependencyLib, h = a.slice(), v = "", m = -1, g = void 0, k = f.skipOptionalPartCharacter;
                                f.skipOptionalPartCharacter = "", o.resetMaskSet.call(s), c.tests = {}, m = f.radixPoint ? o.determineNewCaretPosition.call(s, {
                                    begin: 0,
                                    end: 0
                                }, !1, !1 === f.__financeInput ? "radixFocus" : void 0).begin : 0, c.p = m, s.caretPos = {
                                    begin: m
                                };
                                var y = [], b = s.caretPos;
                                if (h.forEach((function(e, t) {
                                    if (void 0 !== e) {
                                        var a = new d.Event("_checkval");
                                        a.keyCode = e.toString().charCodeAt(0), v += e;
                                        var n = o.getLastValidPosition.call(s, void 0, !0);
                                        !function(e, t) {
                                            for (var i = r.getMaskTemplate.call(s, !0, 0).slice(e, o.seekNext.call(s, e, !1, !1)).join("").replace(/'/g, ""), a = i.indexOf(t); a > 0 && " " === i[a - 1]; ) a--;
                                            var n = 0 === a && !o.isMask.call(s, e) && (r.getTest.call(s, e).match.nativeDef === t.charAt(0) || !0 === r.getTest.call(s, e).match.static && r.getTest.call(s, e).match.nativeDef === "'" + t.charAt(0) || " " === r.getTest.call(s, e).match.nativeDef && (r.getTest.call(s, e + 1).match.nativeDef === t.charAt(0) || !0 === r.getTest.call(s, e + 1).match.static && r.getTest.call(s, e + 1).match.nativeDef === "'" + t.charAt(0)));
                                            if (!n && a > 0 && !o.isMask.call(s, e, !1, !0)) {
                                                var l = o.seekNext.call(s, e);
                                                s.caretPos.begin < l && (s.caretPos = {
                                                    begin: l
                                                });
                                            }
                                            return n;
                                        }(m, v) ? (g = u.EventHandlers.keypressEvent.call(s, a, !0, !1, i, s.caretPos.begin)) && (m = s.caretPos.begin + 1, 
                                        v = "") : g = u.EventHandlers.keypressEvent.call(s, a, !0, !1, i, n + 1), g ? (void 0 !== g.pos && c.validPositions[g.pos] && !0 === c.validPositions[g.pos].match.static && void 0 === c.validPositions[g.pos].alternation && (y.push(g.pos), 
                                        s.isRTL || (g.forwardPosition = g.pos + 1)), p.call(s, void 0, o.getBuffer.call(s), g.forwardPosition, a, !1), 
                                        s.caretPos = {
                                            begin: g.forwardPosition,
                                            end: g.forwardPosition
                                        }, b = s.caretPos) : void 0 === c.validPositions[t] && h[t] === r.getPlaceholder.call(s, t) && o.isMask.call(s, t, !0) ? s.caretPos.begin++ : s.caretPos = b;
                                    }
                                })), y.length > 0) {
                                    var x, P, E = o.seekNext.call(s, -1, void 0, !1);
                                    if (!l.isComplete.call(s, o.getBuffer.call(s)) && y.length <= E || l.isComplete.call(s, o.getBuffer.call(s)) && y.length > 0 && y.length !== E && 0 === y[0]) for (var S = E; void 0 !== (x = y.shift()); ) {
                                        var _ = new d.Event("_checkval");
                                        if ((P = c.validPositions[x]).generatedInput = !0, _.keyCode = P.input.charCodeAt(0), 
                                        (g = u.EventHandlers.keypressEvent.call(s, _, !0, !1, i, S)) && void 0 !== g.pos && g.pos !== x && c.validPositions[g.pos] && !0 === c.validPositions[g.pos].match.static) y.push(g.pos); else if (!g) break;
                                        S++;
                                    }
                                }
                                t && p.call(s, e, o.getBuffer.call(s), g ? g.forwardPosition : s.caretPos.begin, n || new d.Event("checkval"), n && ("input" === n.type && s.undoValue !== o.getBuffer.call(s).join("") || "paste" === n.type)), 
                                f.skipOptionalPartCharacter = k;
                            }
                            function p(e, t, i, a, r) {
                                var s = e ? e.inputmask : this, u = s.opts, c = s.dependencyLib;
                                if (a && "function" == typeof u.onBeforeWrite) {
                                    var f = u.onBeforeWrite.call(s, a, t, i, u);
                                    if (f) {
                                        if (f.refreshFromBuffer) {
                                            var d = f.refreshFromBuffer;
                                            l.refreshFromBuffer.call(s, !0 === d ? d : d.start, d.end, f.buffer || t), t = o.getBuffer.call(s, !0);
                                        }
                                        void 0 !== i && (i = void 0 !== f.caret ? f.caret : i);
                                    }
                                }
                                if (void 0 !== e && (e.inputmask._valueSet(t.join("")), void 0 === i || void 0 !== a && "blur" === a.type || o.caret.call(s, e, i, void 0, void 0, void 0 !== a && "keydown" === a.type && (a.keyCode === n.default.DELETE || a.keyCode === n.default.BACKSPACE)), 
                                !0 === r)) {
                                    var p = c(e), h = e.inputmask._valueGet();
                                    e.inputmask.skipInputEvent = !0, p.trigger("input"), setTimeout((function() {
                                        h === o.getBufferTemplate.call(s).join("") ? p.trigger("cleared") : !0 === l.isComplete.call(s, t) && p.trigger("complete");
                                    }), 0);
                                }
                            }
                        },
                        2394: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0, i(7149), i(3194);
                            var a = i(157), n = m(i(4963)), r = m(i(9380)), o = i(2391), l = i(4713), s = i(8711), u = i(7215), c = i(7760), f = i(9716), d = m(i(7392)), p = m(i(3976)), h = m(i(8741));
                            function v(e) {
                                return v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, v(e);
                            }
                            function m(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var g = r.default.document, k = "_inputmask_opts";
                            function y(e, t, i) {
                                if (h.default) {
                                    if (!(this instanceof y)) return new y(e, t, i);
                                    this.dependencyLib = n.default, this.el = void 0, this.events = {}, this.maskset = void 0, 
                                    !0 !== i && ("[object Object]" === Object.prototype.toString.call(e) ? t = e : (t = t || {}, 
                                    e && (t.alias = e)), this.opts = n.default.extend(!0, {}, this.defaults, t), this.noMasksCache = t && void 0 !== t.definitions, 
                                    this.userOptions = t || {}, b(this.opts.alias, t, this.opts)), this.refreshValue = !1, 
                                    this.undoValue = void 0, this.$el = void 0, this.skipKeyPressEvent = !1, this.skipInputEvent = !1, 
                                    this.validationEvent = !1, this.ignorable = !1, this.maxLength, this.mouseEnter = !1, 
                                    this.originalPlaceholder = void 0, this.isComposing = !1;
                                }
                            }
                            function b(e, t, i) {
                                var a = y.prototype.aliases[e];
                                return a ? (a.alias && b(a.alias, void 0, i), n.default.extend(!0, i, a), n.default.extend(!0, i, t), 
                                !0) : (null === i.mask && (i.mask = e), !1);
                            }
                            y.prototype = {
                                dataAttribute: "data-inputmask",
                                defaults: p.default,
                                definitions: d.default,
                                aliases: {},
                                masksCache: {},
                                get isRTL() {
                                    return this.opts.isRTL || this.opts.numericInput;
                                },
                                mask: function(e) {
                                    var t = this;
                                    return "string" == typeof e && (e = g.getElementById(e) || g.querySelectorAll(e)), 
                                    (e = e.nodeName ? [ e ] : Array.isArray(e) ? e : Array.from(e)).forEach((function(e, i) {
                                        var l = n.default.extend(!0, {}, t.opts);
                                        if (function(e, t, i, a) {
                                            function o(t, n) {
                                                var o = "" === a ? t : a + "-" + t;
                                                null !== (n = void 0 !== n ? n : e.getAttribute(o)) && ("string" == typeof n && (0 === t.indexOf("on") ? n = r.default[n] : "false" === n ? n = !1 : "true" === n && (n = !0)), 
                                                i[t] = n);
                                            }
                                            if (!0 === t.importDataAttributes) {
                                                var l, s, u, c, f = e.getAttribute(a);
                                                if (f && "" !== f && (f = f.replace(/'/g, '"'), s = JSON.parse("{" + f + "}")), 
                                                s) for (c in u = void 0, s) if ("alias" === c.toLowerCase()) {
                                                    u = s[c];
                                                    break;
                                                }
                                                for (l in o("alias", u), i.alias && b(i.alias, i, t), t) {
                                                    if (s) for (c in u = void 0, s) if (c.toLowerCase() === l.toLowerCase()) {
                                                        u = s[c];
                                                        break;
                                                    }
                                                    o(l, u);
                                                }
                                            }
                                            n.default.extend(!0, t, i), ("rtl" === e.dir || t.rightAlign) && (e.style.textAlign = "right");
                                            ("rtl" === e.dir || t.numericInput) && (e.dir = "ltr", e.removeAttribute("dir"), 
                                            t.isRTL = !0);
                                            return Object.keys(i).length;
                                        }(e, l, n.default.extend(!0, {}, t.userOptions), t.dataAttribute)) {
                                            var s = (0, o.generateMaskSet)(l, t.noMasksCache);
                                            void 0 !== s && (void 0 !== e.inputmask && (e.inputmask.opts.autoUnmask = !0, e.inputmask.remove()), 
                                            e.inputmask = new y(void 0, void 0, !0), e.inputmask.opts = l, e.inputmask.noMasksCache = t.noMasksCache, 
                                            e.inputmask.userOptions = n.default.extend(!0, {}, t.userOptions), e.inputmask.el = e, 
                                            e.inputmask.$el = (0, n.default)(e), e.inputmask.maskset = s, n.default.data(e, k, t.userOptions), 
                                            a.mask.call(e.inputmask));
                                        }
                                    })), e && e[0] && e[0].inputmask || this;
                                },
                                option: function(e, t) {
                                    return "string" == typeof e ? this.opts[e] : "object" === v(e) ? (n.default.extend(this.userOptions, e), 
                                    this.el && !0 !== t && this.mask(this.el), this) : void 0;
                                },
                                unmaskedvalue: function(e) {
                                    if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), 
                                    void 0 === this.el || void 0 !== e) {
                                        var t = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split("");
                                        c.checkVal.call(this, void 0, !1, !1, t), "function" == typeof this.opts.onBeforeWrite && this.opts.onBeforeWrite.call(this, void 0, s.getBuffer.call(this), 0, this.opts);
                                    }
                                    return c.unmaskedvalue.call(this, this.el);
                                },
                                remove: function() {
                                    if (this.el) {
                                        n.default.data(this.el, k, null);
                                        var e = this.opts.autoUnmask ? (0, c.unmaskedvalue)(this.el) : this._valueGet(this.opts.autoUnmask);
                                        e !== s.getBufferTemplate.call(this).join("") ? this._valueSet(e, this.opts.autoUnmask) : this._valueSet(""), 
                                        f.EventRuler.off(this.el), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this.el), "value") && this.__valueGet && Object.defineProperty(this.el, "value", {
                                            get: this.__valueGet,
                                            set: this.__valueSet,
                                            configurable: !0
                                        }) : g.__lookupGetter__ && this.el.__lookupGetter__("value") && this.__valueGet && (this.el.__defineGetter__("value", this.__valueGet), 
                                        this.el.__defineSetter__("value", this.__valueSet)), this.el.inputmask = void 0;
                                    }
                                    return this.el;
                                },
                                getemptymask: function() {
                                    return this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), 
                                    s.getBufferTemplate.call(this).join("");
                                },
                                hasMaskedValue: function() {
                                    return !this.opts.autoUnmask;
                                },
                                isComplete: function() {
                                    return this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), 
                                    u.isComplete.call(this, s.getBuffer.call(this));
                                },
                                getmetadata: function() {
                                    if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), 
                                    Array.isArray(this.maskset.metadata)) {
                                        var e = l.getMaskTemplate.call(this, !0, 0, !1).join("");
                                        return this.maskset.metadata.forEach((function(t) {
                                            return t.mask !== e || (e = t, !1);
                                        })), e;
                                    }
                                    return this.maskset.metadata;
                                },
                                isValid: function(e) {
                                    if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), 
                                    e) {
                                        var t = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split("");
                                        c.checkVal.call(this, void 0, !0, !1, t);
                                    } else e = this.isRTL ? s.getBuffer.call(this).slice().reverse().join("") : s.getBuffer.call(this).join("");
                                    for (var i = s.getBuffer.call(this), a = s.determineLastRequiredPosition.call(this), n = i.length - 1; n > a && !s.isMask.call(this, n); n--) ;
                                    return i.splice(a, n + 1 - a), u.isComplete.call(this, i) && e === (this.isRTL ? s.getBuffer.call(this).slice().reverse().join("") : s.getBuffer.call(this).join(""));
                                },
                                format: function(e, t) {
                                    this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache);
                                    var i = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split("");
                                    c.checkVal.call(this, void 0, !0, !1, i);
                                    var a = this.isRTL ? s.getBuffer.call(this).slice().reverse().join("") : s.getBuffer.call(this).join("");
                                    return t ? {
                                        value: a,
                                        metadata: this.getmetadata()
                                    } : a;
                                },
                                setValue: function(e) {
                                    this.el && (0, n.default)(this.el).trigger("setvalue", [ e ]);
                                },
                                analyseMask: o.analyseMask
                            }, y.extendDefaults = function(e) {
                                n.default.extend(!0, y.prototype.defaults, e);
                            }, y.extendDefinitions = function(e) {
                                n.default.extend(!0, y.prototype.definitions, e);
                            }, y.extendAliases = function(e) {
                                n.default.extend(!0, y.prototype.aliases, e);
                            }, y.format = function(e, t, i) {
                                return y(t).format(e, i);
                            }, y.unmask = function(e, t) {
                                return y(t).unmaskedvalue(e);
                            }, y.isValid = function(e, t) {
                                return y(t).isValid(e);
                            }, y.remove = function(e) {
                                "string" == typeof e && (e = g.getElementById(e) || g.querySelectorAll(e)), (e = e.nodeName ? [ e ] : e).forEach((function(e) {
                                    e.inputmask && e.inputmask.remove();
                                }));
                            }, y.setValue = function(e, t) {
                                "string" == typeof e && (e = g.getElementById(e) || g.querySelectorAll(e)), (e = e.nodeName ? [ e ] : e).forEach((function(e) {
                                    e.inputmask ? e.inputmask.setValue(t) : (0, n.default)(e).trigger("setvalue", [ t ]);
                                }));
                            }, y.dependencyLib = n.default, r.default.Inputmask = y;
                            var x = y;
                            t.default = x;
                        },
                        5296: function(e, t, i) {
                            function a(e) {
                                return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, a(e);
                            }
                            var n = h(i(9380)), r = h(i(2394)), o = h(i(8741));
                            function l(e, t) {
                                for (var i = 0; i < t.length; i++) {
                                    var a = t[i];
                                    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), 
                                    Object.defineProperty(e, a.key, a);
                                }
                            }
                            function s(e, t) {
                                if (t && ("object" === a(t) || "function" == typeof t)) return t;
                                if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                                return function(e) {
                                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                    return e;
                                }(e);
                            }
                            function u(e) {
                                var t = "function" == typeof Map ? new Map : void 0;
                                return u = function(e) {
                                    if (null === e || (i = e, -1 === Function.toString.call(i).indexOf("[native code]"))) return e;
                                    var i;
                                    if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
                                    if (void 0 !== t) {
                                        if (t.has(e)) return t.get(e);
                                        t.set(e, a);
                                    }
                                    function a() {
                                        return c(e, arguments, p(this).constructor);
                                    }
                                    return a.prototype = Object.create(e.prototype, {
                                        constructor: {
                                            value: a,
                                            enumerable: !1,
                                            writable: !0,
                                            configurable: !0
                                        }
                                    }), d(a, e);
                                }, u(e);
                            }
                            function c(e, t, i) {
                                return c = f() ? Reflect.construct : function(e, t, i) {
                                    var a = [ null ];
                                    a.push.apply(a, t);
                                    var n = new (Function.bind.apply(e, a));
                                    return i && d(n, i.prototype), n;
                                }, c.apply(null, arguments);
                            }
                            function f() {
                                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                                if (Reflect.construct.sham) return !1;
                                if ("function" == typeof Proxy) return !0;
                                try {
                                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), 
                                    !0;
                                } catch (e) {
                                    return !1;
                                }
                            }
                            function d(e, t) {
                                return d = Object.setPrototypeOf || function(e, t) {
                                    return e.__proto__ = t, e;
                                }, d(e, t);
                            }
                            function p(e) {
                                return p = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                                    return e.__proto__ || Object.getPrototypeOf(e);
                                }, p(e);
                            }
                            function h(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var v = n.default.document;
                            if (o.default && v && v.head && v.head.attachShadow && n.default.customElements && void 0 === n.default.customElements.get("input-mask")) {
                                var m = function(e) {
                                    !function(e, t) {
                                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                                        Object.defineProperty(e, "prototype", {
                                            value: Object.create(t && t.prototype, {
                                                constructor: {
                                                    value: e,
                                                    writable: !0,
                                                    configurable: !0
                                                }
                                            }),
                                            writable: !1
                                        }), t && d(e, t);
                                    }(c, e);
                                    var t, i, a, n, o, u = (t = c, i = f(), function() {
                                        var e, a = p(t);
                                        if (i) {
                                            var n = p(this).constructor;
                                            e = Reflect.construct(a, arguments, n);
                                        } else e = a.apply(this, arguments);
                                        return s(this, e);
                                    });
                                    function c() {
                                        var e;
                                        !function(e, t) {
                                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
                                        }(this, c);
                                        var t = (e = u.call(this)).getAttributeNames(), i = e.attachShadow({
                                            mode: "closed"
                                        }), a = v.createElement("input");
                                        for (var n in a.type = "text", i.appendChild(a), t) Object.prototype.hasOwnProperty.call(t, n) && a.setAttribute(t[n], e.getAttribute(t[n]));
                                        var o = new r.default;
                                        return o.dataAttribute = "", o.mask(a), a.inputmask.shadowRoot = i, e;
                                    }
                                    return a = c, n && l(a.prototype, n), o && l(a, o), Object.defineProperty(a, "prototype", {
                                        writable: !1
                                    }), a;
                                }(u(HTMLElement));
                                n.default.customElements.define("input-mask", m);
                            }
                        },
                        2391: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.analyseMask = function(e, t, i) {
                                var a, o, l, s, u, c, f = /(?:[?*+]|\{[0-9+*]+(?:,[0-9+*]*)?(?:\|[0-9+*]*)?\})|[^.?*+^${[]()|\\]+|./g, d = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g, p = !1, h = new n.default, v = [], m = [], g = !1;
                                function k(e, a, n) {
                                    n = void 0 !== n ? n : e.matches.length;
                                    var o = e.matches[n - 1];
                                    if (t) 0 === a.indexOf("[") || p && /\\d|\\s|\\w/i.test(a) || "." === a ? e.matches.splice(n++, 0, {
                                        fn: new RegExp(a, i.casing ? "i" : ""),
                                        static: !1,
                                        optionality: !1,
                                        newBlockMarker: void 0 === o ? "master" : o.def !== a,
                                        casing: null,
                                        def: a,
                                        placeholder: void 0,
                                        nativeDef: a
                                    }) : (p && (a = a[a.length - 1]), a.split("").forEach((function(t, a) {
                                        o = e.matches[n - 1], e.matches.splice(n++, 0, {
                                            fn: /[a-z]/i.test(i.staticDefinitionSymbol || t) ? new RegExp("[" + (i.staticDefinitionSymbol || t) + "]", i.casing ? "i" : "") : null,
                                            static: !0,
                                            optionality: !1,
                                            newBlockMarker: void 0 === o ? "master" : o.def !== t && !0 !== o.static,
                                            casing: null,
                                            def: i.staticDefinitionSymbol || t,
                                            placeholder: void 0 !== i.staticDefinitionSymbol ? t : void 0,
                                            nativeDef: (p ? "'" : "") + t
                                        });
                                    }))), p = !1; else {
                                        var l = i.definitions && i.definitions[a] || i.usePrototypeDefinitions && r.default.prototype.definitions[a];
                                        l && !p ? e.matches.splice(n++, 0, {
                                            fn: l.validator ? "string" == typeof l.validator ? new RegExp(l.validator, i.casing ? "i" : "") : new function() {
                                                this.test = l.validator;
                                            } : new RegExp("."),
                                            static: l.static || !1,
                                            optionality: l.optional || !1,
                                            newBlockMarker: void 0 === o || l.optional ? "master" : o.def !== (l.definitionSymbol || a),
                                            casing: l.casing,
                                            def: l.definitionSymbol || a,
                                            placeholder: l.placeholder,
                                            nativeDef: a,
                                            generated: l.generated
                                        }) : (e.matches.splice(n++, 0, {
                                            fn: /[a-z]/i.test(i.staticDefinitionSymbol || a) ? new RegExp("[" + (i.staticDefinitionSymbol || a) + "]", i.casing ? "i" : "") : null,
                                            static: !0,
                                            optionality: !1,
                                            newBlockMarker: void 0 === o ? "master" : o.def !== a && !0 !== o.static,
                                            casing: null,
                                            def: i.staticDefinitionSymbol || a,
                                            placeholder: void 0 !== i.staticDefinitionSymbol ? a : void 0,
                                            nativeDef: (p ? "'" : "") + a
                                        }), p = !1);
                                    }
                                }
                                function y() {
                                    if (v.length > 0) {
                                        if (k(s = v[v.length - 1], o), s.isAlternator) {
                                            u = v.pop();
                                            for (var e = 0; e < u.matches.length; e++) u.matches[e].isGroup && (u.matches[e].isGroup = !1);
                                            v.length > 0 ? (s = v[v.length - 1]).matches.push(u) : h.matches.push(u);
                                        }
                                    } else k(h, o);
                                }
                                function b(e) {
                                    var t = new n.default(!0);
                                    return t.openGroup = !1, t.matches = e, t;
                                }
                                function x() {
                                    if ((l = v.pop()).openGroup = !1, void 0 !== l) if (v.length > 0) {
                                        if ((s = v[v.length - 1]).matches.push(l), s.isAlternator) {
                                            for (var e = (u = v.pop()).matches[0].matches ? u.matches[0].matches.length : 1, t = 0; t < u.matches.length; t++) u.matches[t].isGroup = !1, 
                                            u.matches[t].alternatorGroup = !1, null === i.keepStatic && e < (u.matches[t].matches ? u.matches[t].matches.length : 1) && (i.keepStatic = !0), 
                                            e = u.matches[t].matches ? u.matches[t].matches.length : 1;
                                            v.length > 0 ? (s = v[v.length - 1]).matches.push(u) : h.matches.push(u);
                                        }
                                    } else h.matches.push(l); else y();
                                }
                                function P(e) {
                                    var t = e.pop();
                                    return t.isQuantifier && (t = b([ e.pop(), t ])), t;
                                }
                                t && (i.optionalmarker[0] = void 0, i.optionalmarker[1] = void 0);
                                for (;a = t ? d.exec(e) : f.exec(e); ) {
                                    if (o = a[0], t) {
                                        switch (o.charAt(0)) {
                                          case "?":
                                            o = "{0,1}";
                                            break;

                                          case "+":
                                          case "*":
                                            o = "{" + o + "}";
                                            break;

                                          case "|":
                                            if (0 === v.length) {
                                                var E = b(h.matches);
                                                E.openGroup = !0, v.push(E), h.matches = [], g = !0;
                                            }
                                        }
                                        if ("\\d" === o) o = "[0-9]";
                                    }
                                    if (p) y(); else switch (o.charAt(0)) {
                                      case "$":
                                      case "^":
                                        t || y();
                                        break;

                                      case i.escapeChar:
                                        p = !0, t && y();
                                        break;

                                      case i.optionalmarker[1]:
                                      case i.groupmarker[1]:
                                        x();
                                        break;

                                      case i.optionalmarker[0]:
                                        v.push(new n.default(!1, !0));
                                        break;

                                      case i.groupmarker[0]:
                                        v.push(new n.default(!0));
                                        break;

                                      case i.quantifiermarker[0]:
                                        var S = new n.default(!1, !1, !0), _ = (o = o.replace(/[{}?]/g, "")).split("|"), w = _[0].split(","), M = isNaN(w[0]) ? w[0] : parseInt(w[0]), O = 1 === w.length ? M : isNaN(w[1]) ? w[1] : parseInt(w[1]), T = isNaN(_[1]) ? _[1] : parseInt(_[1]);
                                        "*" !== M && "+" !== M || (M = "*" === O ? 0 : 1), S.quantifier = {
                                            min: M,
                                            max: O,
                                            jit: T
                                        };
                                        var C = v.length > 0 ? v[v.length - 1].matches : h.matches;
                                        if ((a = C.pop()).isAlternator) {
                                            C.push(a), C = a.matches;
                                            var A = new n.default(!0), D = C.pop();
                                            C.push(A), C = A.matches, a = D;
                                        }
                                        a.isGroup || (a = b([ a ])), C.push(a), C.push(S);
                                        break;

                                      case i.alternatormarker:
                                        if (v.length > 0) {
                                            var j = (s = v[v.length - 1]).matches[s.matches.length - 1];
                                            c = s.openGroup && (void 0 === j.matches || !1 === j.isGroup && !1 === j.isAlternator) ? v.pop() : P(s.matches);
                                        } else c = P(h.matches);
                                        if (c.isAlternator) v.push(c); else if (c.alternatorGroup ? (u = v.pop(), c.alternatorGroup = !1) : u = new n.default(!1, !1, !1, !0), 
                                        u.matches.push(c), v.push(u), c.openGroup) {
                                            c.openGroup = !1;
                                            var B = new n.default(!0);
                                            B.alternatorGroup = !0, v.push(B);
                                        }
                                        break;

                                      default:
                                        y();
                                    }
                                }
                                g && x();
                                for (;v.length > 0; ) l = v.pop(), h.matches.push(l);
                                h.matches.length > 0 && (!function e(a) {
                                    a && a.matches && a.matches.forEach((function(n, r) {
                                        var o = a.matches[r + 1];
                                        (void 0 === o || void 0 === o.matches || !1 === o.isQuantifier) && n && n.isGroup && (n.isGroup = !1, 
                                        t || (k(n, i.groupmarker[0], 0), !0 !== n.openGroup && k(n, i.groupmarker[1]))), 
                                        e(n);
                                    }));
                                }(h), m.push(h));
                                (i.numericInput || i.isRTL) && function e(t) {
                                    for (var a in t.matches = t.matches.reverse(), t.matches) if (Object.prototype.hasOwnProperty.call(t.matches, a)) {
                                        var n = parseInt(a);
                                        if (t.matches[a].isQuantifier && t.matches[n + 1] && t.matches[n + 1].isGroup) {
                                            var r = t.matches[a];
                                            t.matches.splice(a, 1), t.matches.splice(n + 1, 0, r);
                                        }
                                        void 0 !== t.matches[a].matches ? t.matches[a] = e(t.matches[a]) : t.matches[a] = ((o = t.matches[a]) === i.optionalmarker[0] ? o = i.optionalmarker[1] : o === i.optionalmarker[1] ? o = i.optionalmarker[0] : o === i.groupmarker[0] ? o = i.groupmarker[1] : o === i.groupmarker[1] && (o = i.groupmarker[0]), 
                                        o);
                                    }
                                    var o;
                                    return t;
                                }(m[0]);
                                return m;
                            }, t.generateMaskSet = function(e, t) {
                                var i;
                                function n(e, i, n) {
                                    var o, l, s = !1;
                                    if (null !== e && "" !== e || ((s = null !== n.regex) ? e = (e = n.regex).replace(/^(\^)(.*)(\$)$/, "$2") : (s = !0, 
                                    e = ".*")), 1 === e.length && !1 === n.greedy && 0 !== n.repeat && (n.placeholder = ""), 
                                    n.repeat > 0 || "*" === n.repeat || "+" === n.repeat) {
                                        var u = "*" === n.repeat ? 0 : "+" === n.repeat ? 1 : n.repeat;
                                        e = n.groupmarker[0] + e + n.groupmarker[1] + n.quantifiermarker[0] + u + "," + n.repeat + n.quantifiermarker[1];
                                    }
                                    return l = s ? "regex_" + n.regex : n.numericInput ? e.split("").reverse().join("") : e, 
                                    null !== n.keepStatic && (l = "ks_" + n.keepStatic + l), void 0 === r.default.prototype.masksCache[l] || !0 === t ? (o = {
                                        mask: e,
                                        maskToken: r.default.prototype.analyseMask(e, s, n),
                                        validPositions: {},
                                        _buffer: void 0,
                                        buffer: void 0,
                                        tests: {},
                                        excludes: {},
                                        metadata: i,
                                        maskLength: void 0,
                                        jitOffset: {}
                                    }, !0 !== t && (r.default.prototype.masksCache[l] = o, o = a.default.extend(!0, {}, r.default.prototype.masksCache[l]))) : o = a.default.extend(!0, {}, r.default.prototype.masksCache[l]), 
                                    o;
                                }
                                "function" == typeof e.mask && (e.mask = e.mask(e));
                                if (Array.isArray(e.mask)) {
                                    if (e.mask.length > 1) {
                                        null === e.keepStatic && (e.keepStatic = !0);
                                        var o = e.groupmarker[0];
                                        return (e.isRTL ? e.mask.reverse() : e.mask).forEach((function(t) {
                                            o.length > 1 && (o += e.alternatormarker), void 0 !== t.mask && "function" != typeof t.mask ? o += t.mask : o += t;
                                        })), n(o += e.groupmarker[1], e.mask, e);
                                    }
                                    e.mask = e.mask.pop();
                                }
                                i = e.mask && void 0 !== e.mask.mask && "function" != typeof e.mask.mask ? n(e.mask.mask, e.mask, e) : n(e.mask, e.mask, e);
                                null === e.keepStatic && (e.keepStatic = !1);
                                return i;
                            };
                            var a = o(i(4963)), n = o(i(9695)), r = o(i(2394));
                            function o(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                        },
                        157: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.mask = function() {
                                var e = this, t = this.opts, i = this.el, a = this.dependencyLib;
                                l.EventRuler.off(i);
                                var f = function(t, i) {
                                    "textarea" !== t.tagName.toLowerCase() && i.ignorables.push(n.default.ENTER);
                                    var s = t.getAttribute("type"), u = "input" === t.tagName.toLowerCase() && i.supportsInputType.includes(s) || t.isContentEditable || "textarea" === t.tagName.toLowerCase();
                                    if (!u) if ("input" === t.tagName.toLowerCase()) {
                                        var c = document.createElement("input");
                                        c.setAttribute("type", s), u = "text" === c.type, c = null;
                                    } else u = "partial";
                                    return !1 !== u ? function(t) {
                                        var n, s;
                                        function u() {
                                            return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== r.getLastValidPosition.call(e) || !0 !== i.nullable ? (this.inputmask.shadowRoot || this.ownerDocument).activeElement === this && i.clearMaskOnLostFocus ? (e.isRTL ? o.clearOptionalTail.call(e, r.getBuffer.call(e).slice()).reverse() : o.clearOptionalTail.call(e, r.getBuffer.call(e).slice())).join("") : n.call(this) : "" : n.call(this);
                                        }
                                        function c(e) {
                                            s.call(this, e), this.inputmask && (0, o.applyInputValue)(this, e);
                                        }
                                        if (!t.inputmask.__valueGet) {
                                            if (!0 !== i.noValuePatching) {
                                                if (Object.getOwnPropertyDescriptor) {
                                                    var f = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t), "value") : void 0;
                                                    f && f.get && f.set ? (n = f.get, s = f.set, Object.defineProperty(t, "value", {
                                                        get: u,
                                                        set: c,
                                                        configurable: !0
                                                    })) : "input" !== t.tagName.toLowerCase() && (n = function() {
                                                        return this.textContent;
                                                    }, s = function(e) {
                                                        this.textContent = e;
                                                    }, Object.defineProperty(t, "value", {
                                                        get: u,
                                                        set: c,
                                                        configurable: !0
                                                    }));
                                                } else document.__lookupGetter__ && t.__lookupGetter__("value") && (n = t.__lookupGetter__("value"), 
                                                s = t.__lookupSetter__("value"), t.__defineGetter__("value", u), t.__defineSetter__("value", c));
                                                t.inputmask.__valueGet = n, t.inputmask.__valueSet = s;
                                            }
                                            t.inputmask._valueGet = function(t) {
                                                return e.isRTL && !0 !== t ? n.call(this.el).split("").reverse().join("") : n.call(this.el);
                                            }, t.inputmask._valueSet = function(t, i) {
                                                s.call(this.el, null == t ? "" : !0 !== i && e.isRTL ? t.split("").reverse().join("") : t);
                                            }, void 0 === n && (n = function() {
                                                return this.value;
                                            }, s = function(e) {
                                                this.value = e;
                                            }, function(t) {
                                                if (a.valHooks && (void 0 === a.valHooks[t] || !0 !== a.valHooks[t].inputmaskpatch)) {
                                                    var n = a.valHooks[t] && a.valHooks[t].get ? a.valHooks[t].get : function(e) {
                                                        return e.value;
                                                    }, l = a.valHooks[t] && a.valHooks[t].set ? a.valHooks[t].set : function(e, t) {
                                                        return e.value = t, e;
                                                    };
                                                    a.valHooks[t] = {
                                                        get: function(t) {
                                                            if (t.inputmask) {
                                                                if (t.inputmask.opts.autoUnmask) return t.inputmask.unmaskedvalue();
                                                                var a = n(t);
                                                                return -1 !== r.getLastValidPosition.call(e, void 0, void 0, t.inputmask.maskset.validPositions) || !0 !== i.nullable ? a : "";
                                                            }
                                                            return n(t);
                                                        },
                                                        set: function(e, t) {
                                                            var i = l(e, t);
                                                            return e.inputmask && (0, o.applyInputValue)(e, t), i;
                                                        },
                                                        inputmaskpatch: !0
                                                    };
                                                }
                                            }(t.type), function(t) {
                                                l.EventRuler.on(t, "mouseenter", (function() {
                                                    var t = this.inputmask._valueGet(!0);
                                                    t !== (e.isRTL ? r.getBuffer.call(e).reverse() : r.getBuffer.call(e)).join("") && (0, 
                                                    o.applyInputValue)(this, t);
                                                }));
                                            }(t));
                                        }
                                    }(t) : t.inputmask = void 0, u;
                                }(i, t);
                                if (!1 !== f) {
                                    e.originalPlaceholder = i.placeholder, e.maxLength = void 0 !== i ? i.maxLength : void 0, 
                                    -1 === e.maxLength && (e.maxLength = void 0), "inputMode" in i && null === i.getAttribute("inputmode") && (i.inputMode = t.inputmode, 
                                    i.setAttribute("inputmode", t.inputmode)), !0 === f && (t.showMaskOnFocus = t.showMaskOnFocus && -1 === [ "cc-number", "cc-exp" ].indexOf(i.autocomplete), 
                                    s.iphone && (t.insertModeVisual = !1), l.EventRuler.on(i, "submit", c.EventHandlers.submitEvent), 
                                    l.EventRuler.on(i, "reset", c.EventHandlers.resetEvent), l.EventRuler.on(i, "blur", c.EventHandlers.blurEvent), 
                                    l.EventRuler.on(i, "focus", c.EventHandlers.focusEvent), l.EventRuler.on(i, "invalid", c.EventHandlers.invalidEvent), 
                                    l.EventRuler.on(i, "click", c.EventHandlers.clickEvent), l.EventRuler.on(i, "mouseleave", c.EventHandlers.mouseleaveEvent), 
                                    l.EventRuler.on(i, "mouseenter", c.EventHandlers.mouseenterEvent), l.EventRuler.on(i, "paste", c.EventHandlers.pasteEvent), 
                                    l.EventRuler.on(i, "cut", c.EventHandlers.cutEvent), l.EventRuler.on(i, "complete", t.oncomplete), 
                                    l.EventRuler.on(i, "incomplete", t.onincomplete), l.EventRuler.on(i, "cleared", t.oncleared), 
                                    !0 !== t.inputEventOnly && (l.EventRuler.on(i, "keydown", c.EventHandlers.keydownEvent), 
                                    l.EventRuler.on(i, "keypress", c.EventHandlers.keypressEvent), l.EventRuler.on(i, "keyup", c.EventHandlers.keyupEvent)), 
                                    (s.mobile || t.inputEventOnly) && i.removeAttribute("maxLength"), l.EventRuler.on(i, "input", c.EventHandlers.inputFallBackEvent), 
                                    l.EventRuler.on(i, "compositionend", c.EventHandlers.compositionendEvent)), l.EventRuler.on(i, "setvalue", c.EventHandlers.setValueEvent), 
                                    r.getBufferTemplate.call(e).join(""), e.undoValue = e._valueGet(!0);
                                    var d = (i.inputmask.shadowRoot || i.ownerDocument).activeElement;
                                    if ("" !== i.inputmask._valueGet(!0) || !1 === t.clearMaskOnLostFocus || d === i) {
                                        (0, o.applyInputValue)(i, i.inputmask._valueGet(!0), t);
                                        var p = r.getBuffer.call(e).slice();
                                        !1 === u.isComplete.call(e, p) && t.clearIncomplete && r.resetMaskSet.call(e), t.clearMaskOnLostFocus && d !== i && (-1 === r.getLastValidPosition.call(e) ? p = [] : o.clearOptionalTail.call(e, p)), 
                                        (!1 === t.clearMaskOnLostFocus || t.showMaskOnFocus && d === i || "" !== i.inputmask._valueGet(!0)) && (0, 
                                        o.writeBuffer)(i, p), d === i && r.caret.call(e, i, r.seekNext.call(e, r.getLastValidPosition.call(e)));
                                    }
                                }
                            };
                            var a, n = (a = i(5581)) && a.__esModule ? a : {
                                default: a
                            }, r = i(8711), o = i(7760), l = i(9716), s = i(9845), u = i(7215), c = i(6030);
                        },
                        9695: function(e, t) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = function(e, t, i, a) {
                                this.matches = [], this.openGroup = e || !1, this.alternatorGroup = !1, this.isGroup = e || !1, 
                                this.isOptional = t || !1, this.isQuantifier = i || !1, this.isAlternator = a || !1, 
                                this.quantifier = {
                                    min: 1,
                                    max: 1
                                };
                            };
                        },
                        3194: function() {
                            Array.prototype.includes || Object.defineProperty(Array.prototype, "includes", {
                                value: function(e, t) {
                                    if (null == this) throw new TypeError('"this" is null or not defined');
                                    var i = Object(this), a = i.length >>> 0;
                                    if (0 === a) return !1;
                                    for (var n = 0 | t, r = Math.max(n >= 0 ? n : a - Math.abs(n), 0); r < a; ) {
                                        if (i[r] === e) return !0;
                                        r++;
                                    }
                                    return !1;
                                }
                            });
                        },
                        7149: function() {
                            function e(t) {
                                return e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, e(t);
                            }
                            "function" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" === e("test".__proto__) ? function(e) {
                                return e.__proto__;
                            } : function(e) {
                                return e.constructor.prototype;
                            });
                        },
                        8711: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.caret = function(e, t, i, a, n) {
                                var r, o = this, l = this.opts;
                                if (void 0 === t) return "selectionStart" in e && "selectionEnd" in e ? (t = e.selectionStart, 
                                i = e.selectionEnd) : window.getSelection ? (r = window.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== e && r.commonAncestorContainer !== e || (t = r.startOffset, 
                                i = r.endOffset) : document.selection && document.selection.createRange && (r = document.selection.createRange(), 
                                t = 0 - r.duplicate().moveStart("character", -e.inputmask._valueGet().length), i = t + r.text.length), 
                                {
                                    begin: a ? t : u.call(o, t),
                                    end: a ? i : u.call(o, i)
                                };
                                if (Array.isArray(t) && (i = o.isRTL ? t[0] : t[1], t = o.isRTL ? t[1] : t[0]), 
                                void 0 !== t.begin && (i = o.isRTL ? t.begin : t.end, t = o.isRTL ? t.end : t.begin), 
                                "number" == typeof t) {
                                    t = a ? t : u.call(o, t), i = "number" == typeof (i = a ? i : u.call(o, i)) ? i : t;
                                    var s = parseInt(((e.ownerDocument.defaultView || window).getComputedStyle ? (e.ownerDocument.defaultView || window).getComputedStyle(e, null) : e.currentStyle).fontSize) * i;
                                    if (e.scrollLeft = s > e.scrollWidth ? s : 0, e.inputmask.caretPos = {
                                        begin: t,
                                        end: i
                                    }, l.insertModeVisual && !1 === l.insertMode && t === i && (n || i++), e === (e.inputmask.shadowRoot || e.ownerDocument).activeElement) if ("setSelectionRange" in e) e.setSelectionRange(t, i); else if (window.getSelection) {
                                        if (r = document.createRange(), void 0 === e.firstChild || null === e.firstChild) {
                                            var c = document.createTextNode("");
                                            e.appendChild(c);
                                        }
                                        r.setStart(e.firstChild, t < e.inputmask._valueGet().length ? t : e.inputmask._valueGet().length), 
                                        r.setEnd(e.firstChild, i < e.inputmask._valueGet().length ? i : e.inputmask._valueGet().length), 
                                        r.collapse(!0);
                                        var f = window.getSelection();
                                        f.removeAllRanges(), f.addRange(r);
                                    } else e.createTextRange && ((r = e.createTextRange()).collapse(!0), r.moveEnd("character", i), 
                                    r.moveStart("character", t), r.select());
                                }
                            }, t.determineLastRequiredPosition = function(e) {
                                var t, i, r = this, l = this.maskset, s = this.dependencyLib, u = a.getMaskTemplate.call(r, !0, o.call(r), !0, !0), c = u.length, f = o.call(r), d = {}, p = l.validPositions[f], h = void 0 !== p ? p.locator.slice() : void 0;
                                for (t = f + 1; t < u.length; t++) i = a.getTestTemplate.call(r, t, h, t - 1), h = i.locator.slice(), 
                                d[t] = s.extend(!0, {}, i);
                                var v = p && void 0 !== p.alternation ? p.locator[p.alternation] : void 0;
                                for (t = c - 1; t > f && ((i = d[t]).match.optionality || i.match.optionalQuantifier && i.match.newBlockMarker || v && (v !== d[t].locator[p.alternation] && 1 != i.match.static || !0 === i.match.static && i.locator[p.alternation] && n.checkAlternationMatch.call(r, i.locator[p.alternation].toString().split(","), v.toString().split(",")) && "" !== a.getTests.call(r, t)[0].def)) && u[t] === a.getPlaceholder.call(r, t, i.match); t--) c--;
                                return e ? {
                                    l: c,
                                    def: d[c] ? d[c].match : void 0
                                } : c;
                            }, t.determineNewCaretPosition = function(e, t, i) {
                                var n = this, u = this.maskset, c = this.opts;
                                t && (n.isRTL ? e.end = e.begin : e.begin = e.end);
                                if (e.begin === e.end) {
                                    switch (i = i || c.positionCaretOnClick) {
                                      case "none":
                                        break;

                                      case "select":
                                        e = {
                                            begin: 0,
                                            end: r.call(n).length
                                        };
                                        break;

                                      case "ignore":
                                        e.end = e.begin = s.call(n, o.call(n));
                                        break;

                                      case "radixFocus":
                                        if (function(e) {
                                            if ("" !== c.radixPoint && 0 !== c.digits) {
                                                var t = u.validPositions;
                                                if (void 0 === t[e] || t[e].input === a.getPlaceholder.call(n, e)) {
                                                    if (e < s.call(n, -1)) return !0;
                                                    var i = r.call(n).indexOf(c.radixPoint);
                                                    if (-1 !== i) {
                                                        for (var o in t) if (t[o] && i < o && t[o].input !== a.getPlaceholder.call(n, o)) return !1;
                                                        return !0;
                                                    }
                                                }
                                            }
                                            return !1;
                                        }(e.begin)) {
                                            var f = r.call(n).join("").indexOf(c.radixPoint);
                                            e.end = e.begin = c.numericInput ? s.call(n, f) : f;
                                            break;
                                        }

                                      default:
                                        var d = e.begin, p = o.call(n, d, !0), h = s.call(n, -1 !== p || l.call(n, 0) ? p : -1);
                                        if (d <= h) e.end = e.begin = l.call(n, d, !1, !0) ? d : s.call(n, d); else {
                                            var v = u.validPositions[p], m = a.getTestTemplate.call(n, h, v ? v.match.locator : void 0, v), g = a.getPlaceholder.call(n, h, m.match);
                                            if ("" !== g && r.call(n)[h] !== g && !0 !== m.match.optionalQuantifier && !0 !== m.match.newBlockMarker || !l.call(n, h, c.keepStatic, !0) && m.match.def === g) {
                                                var k = s.call(n, h);
                                                (d >= k || d === h) && (h = k);
                                            }
                                            e.end = e.begin = h;
                                        }
                                    }
                                    return e;
                                }
                            }, t.getBuffer = r, t.getBufferTemplate = function() {
                                var e = this.maskset;
                                void 0 === e._buffer && (e._buffer = a.getMaskTemplate.call(this, !1, 1), void 0 === e.buffer && (e.buffer = e._buffer.slice()));
                                return e._buffer;
                            }, t.getLastValidPosition = o, t.isMask = l, t.resetMaskSet = function(e) {
                                var t = this.maskset;
                                t.buffer = void 0, !0 !== e && (t.validPositions = {}, t.p = 0);
                            }, t.seekNext = s, t.seekPrevious = function(e, t) {
                                var i = this, n = e - 1;
                                if (e <= 0) return 0;
                                for (;n > 0 && (!0 === t && (!0 !== a.getTest.call(i, n).match.newBlockMarker || !l.call(i, n, void 0, !0)) || !0 !== t && !l.call(i, n, void 0, !0)); ) n--;
                                return n;
                            }, t.translatePosition = u;
                            var a = i(4713), n = i(7215);
                            function r(e) {
                                var t = this.maskset;
                                return void 0 !== t.buffer && !0 !== e || (t.buffer = a.getMaskTemplate.call(this, !0, o.call(this), !0), 
                                void 0 === t._buffer && (t._buffer = t.buffer.slice())), t.buffer;
                            }
                            function o(e, t, i) {
                                var a = this.maskset, n = -1, r = -1, o = i || a.validPositions;
                                for (var l in void 0 === e && (e = -1), o) {
                                    var s = parseInt(l);
                                    o[s] && (t || !0 !== o[s].generatedInput) && (s <= e && (n = s), s >= e && (r = s));
                                }
                                return -1 === n || n == e ? r : -1 == r || e - n < r - e ? n : r;
                            }
                            function l(e, t, i) {
                                var n = this, r = this.maskset, o = a.getTestTemplate.call(n, e).match;
                                if ("" === o.def && (o = a.getTest.call(n, e).match), !0 !== o.static) return o.fn;
                                if (!0 === i && void 0 !== r.validPositions[e] && !0 !== r.validPositions[e].generatedInput) return !0;
                                if (!0 !== t && e > -1) {
                                    if (i) {
                                        var l = a.getTests.call(n, e);
                                        return l.length > 1 + ("" === l[l.length - 1].match.def ? 1 : 0);
                                    }
                                    var s = a.determineTestTemplate.call(n, e, a.getTests.call(n, e)), u = a.getPlaceholder.call(n, e, s.match);
                                    return s.match.def !== u;
                                }
                                return !1;
                            }
                            function s(e, t, i) {
                                var n = this;
                                void 0 === i && (i = !0);
                                for (var r = e + 1; "" !== a.getTest.call(n, r).match.def && (!0 === t && (!0 !== a.getTest.call(n, r).match.newBlockMarker || !l.call(n, r, void 0, !0)) || !0 !== t && !l.call(n, r, void 0, i)); ) r++;
                                return r;
                            }
                            function u(e) {
                                var t = this.opts, i = this.el;
                                return !this.isRTL || "number" != typeof e || t.greedy && "" === t.placeholder || !i || (e = Math.abs(this._valueGet().length - e)), 
                                e;
                            }
                        },
                        4713: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.determineTestTemplate = u, t.getDecisionTaker = o, t.getMaskTemplate = function(e, t, i, a, n) {
                                var r = this, o = this.opts, c = this.maskset, f = o.greedy;
                                n && o.greedy && (o.greedy = !1, r.maskset.tests = {});
                                t = t || 0;
                                var p, h, v, m, g = [], k = 0;
                                do {
                                    if (!0 === e && c.validPositions[k]) v = n && c.validPositions[k].match.optionality && void 0 === c.validPositions[k + 1] && (!0 === c.validPositions[k].generatedInput || c.validPositions[k].input == o.skipOptionalPartCharacter && k > 0) ? u.call(r, k, d.call(r, k, p, k - 1)) : c.validPositions[k], 
                                    h = v.match, p = v.locator.slice(), g.push(!0 === i ? v.input : !1 === i ? h.nativeDef : l.call(r, k, h)); else {
                                        v = s.call(r, k, p, k - 1), h = v.match, p = v.locator.slice();
                                        var y = !0 !== a && (!1 !== o.jitMasking ? o.jitMasking : h.jit);
                                        (m = (m && h.static && h.def !== o.groupSeparator && null === h.fn || c.validPositions[k - 1] && h.static && h.def !== o.groupSeparator && null === h.fn) && c.tests[k] && 1 === c.tests[k].length) || !1 === y || void 0 === y || "number" == typeof y && isFinite(y) && y > k ? g.push(!1 === i ? h.nativeDef : l.call(r, k, h)) : m = !1;
                                    }
                                    k++;
                                } while (!0 !== h.static || "" !== h.def || t > k);
                                "" === g[g.length - 1] && g.pop();
                                !1 === i && void 0 !== c.maskLength || (c.maskLength = k - 1);
                                return o.greedy = f, g;
                            }, t.getPlaceholder = l, t.getTest = c, t.getTestTemplate = s, t.getTests = d, t.isSubsetOf = f;
                            var a, n = (a = i(2394)) && a.__esModule ? a : {
                                default: a
                            };
                            function r(e, t) {
                                var i = (null != e.alternation ? e.mloc[o(e)] : e.locator).join("");
                                if ("" !== i) for (;i.length < t; ) i += "0";
                                return i;
                            }
                            function o(e) {
                                var t = e.locator[e.alternation];
                                return "string" == typeof t && t.length > 0 && (t = t.split(",")[0]), void 0 !== t ? t.toString() : "";
                            }
                            function l(e, t, i) {
                                var a = this.opts, n = this.maskset;
                                if (void 0 !== (t = t || c.call(this, e).match).placeholder || !0 === i) return "function" == typeof t.placeholder ? t.placeholder(a) : t.placeholder;
                                if (!0 === t.static) {
                                    if (e > -1 && void 0 === n.validPositions[e]) {
                                        var r, o = d.call(this, e), l = [];
                                        if (o.length > 1 + ("" === o[o.length - 1].match.def ? 1 : 0)) for (var s = 0; s < o.length; s++) if ("" !== o[s].match.def && !0 !== o[s].match.optionality && !0 !== o[s].match.optionalQuantifier && (!0 === o[s].match.static || void 0 === r || !1 !== o[s].match.fn.test(r.match.def, n, e, !0, a)) && (l.push(o[s]), 
                                        !0 === o[s].match.static && (r = o[s]), l.length > 1 && /[0-9a-bA-Z]/.test(l[0].match.def))) return a.placeholder.charAt(e % a.placeholder.length);
                                    }
                                    return t.def;
                                }
                                return a.placeholder.charAt(e % a.placeholder.length);
                            }
                            function s(e, t, i) {
                                return this.maskset.validPositions[e] || u.call(this, e, d.call(this, e, t ? t.slice() : t, i));
                            }
                            function u(e, t) {
                                var i = this.opts, a = function(e, t) {
                                    var i = 0, a = !1;
                                    t.forEach((function(e) {
                                        e.match.optionality && (0 !== i && i !== e.match.optionality && (a = !0), (0 === i || i > e.match.optionality) && (i = e.match.optionality));
                                    })), i && (0 == e || 1 == t.length ? i = 0 : a || (i = 0));
                                    return i;
                                }(e, t);
                                e = e > 0 ? e - 1 : 0;
                                var n, o, l, s = r(c.call(this, e));
                                i.greedy && t.length > 1 && "" === t[t.length - 1].match.def && t.pop();
                                for (var u = 0; u < t.length; u++) {
                                    var f = t[u];
                                    n = r(f, s.length);
                                    var d = Math.abs(n - s);
                                    (void 0 === o || "" !== n && d < o || l && !i.greedy && l.match.optionality && l.match.optionality - a > 0 && "master" === l.match.newBlockMarker && (!f.match.optionality || f.match.optionality - a < 1 || !f.match.newBlockMarker) || l && !i.greedy && l.match.optionalQuantifier && !f.match.optionalQuantifier) && (o = d, 
                                    l = f);
                                }
                                return l;
                            }
                            function c(e, t) {
                                var i = this.maskset;
                                return i.validPositions[e] ? i.validPositions[e] : (t || d.call(this, e))[0];
                            }
                            function f(e, t, i) {
                                function a(e) {
                                    for (var t, i = [], a = -1, n = 0, r = e.length; n < r; n++) if ("-" === e.charAt(n)) for (t = e.charCodeAt(n + 1); ++a < t; ) i.push(String.fromCharCode(a)); else a = e.charCodeAt(n), 
                                    i.push(e.charAt(n));
                                    return i.join("");
                                }
                                return e.match.def === t.match.nativeDef || !(!(i.regex || e.match.fn instanceof RegExp && t.match.fn instanceof RegExp) || !0 === e.match.static || !0 === t.match.static) && -1 !== a(t.match.fn.toString().replace(/[[\]/]/g, "")).indexOf(a(e.match.fn.toString().replace(/[[\]/]/g, "")));
                            }
                            function d(e, t, i) {
                                var a, r, o = this, l = this.dependencyLib, s = this.maskset, c = this.opts, d = this.el, p = s.maskToken, h = t ? i : 0, v = t ? t.slice() : [ 0 ], m = [], g = !1, k = t ? t.join("") : "";
                                function y(t, i, r, o) {
                                    function l(r, o, u) {
                                        function p(e, t) {
                                            var i = 0 === t.matches.indexOf(e);
                                            return i || t.matches.every((function(a, n) {
                                                return !0 === a.isQuantifier ? i = p(e, t.matches[n - 1]) : Object.prototype.hasOwnProperty.call(a, "matches") && (i = p(e, a)), 
                                                !i;
                                            })), i;
                                        }
                                        function v(e, t, i) {
                                            var a, n;
                                            if ((s.tests[e] || s.validPositions[e]) && (s.tests[e] || [ s.validPositions[e] ]).every((function(e, r) {
                                                if (e.mloc[t]) return a = e, !1;
                                                var o = void 0 !== i ? i : e.alternation, l = void 0 !== e.locator[o] ? e.locator[o].toString().indexOf(t) : -1;
                                                return (void 0 === n || l < n) && -1 !== l && (a = e, n = l), !0;
                                            })), a) {
                                                var r = a.locator[a.alternation];
                                                return (a.mloc[t] || a.mloc[r] || a.locator).slice((void 0 !== i ? i : a.alternation) + 1);
                                            }
                                            return void 0 !== i ? v(e, t) : void 0;
                                        }
                                        function b(e, t) {
                                            var i = e.alternation, a = void 0 === t || i === t.alternation && -1 === e.locator[i].toString().indexOf(t.locator[i]);
                                            if (!a && i > t.alternation) for (var n = t.alternation; n < i; n++) if (e.locator[n] !== t.locator[n]) {
                                                i = n, a = !0;
                                                break;
                                            }
                                            if (a) {
                                                e.mloc = e.mloc || {};
                                                var r = e.locator[i];
                                                if (void 0 !== r) {
                                                    if ("string" == typeof r && (r = r.split(",")[0]), void 0 === e.mloc[r] && (e.mloc[r] = e.locator.slice()), 
                                                    void 0 !== t) {
                                                        for (var o in t.mloc) "string" == typeof o && (o = o.split(",")[0]), void 0 === e.mloc[o] && (e.mloc[o] = t.mloc[o]);
                                                        e.locator[i] = Object.keys(e.mloc).join(",");
                                                    }
                                                    return !0;
                                                }
                                                e.alternation = void 0;
                                            }
                                            return !1;
                                        }
                                        function x(e, t) {
                                            if (e.locator.length !== t.locator.length) return !1;
                                            for (var i = e.alternation + 1; i < e.locator.length; i++) if (e.locator[i] !== t.locator[i]) return !1;
                                            return !0;
                                        }
                                        if (h > e + c._maxTestPos) throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + s.mask;
                                        if (h === e && void 0 === r.matches) {
                                            if (m.push({
                                                match: r,
                                                locator: o.reverse(),
                                                cd: k,
                                                mloc: {}
                                            }), !r.optionality || void 0 !== u || !(c.definitions && c.definitions[r.nativeDef] && c.definitions[r.nativeDef].optional || n.default.prototype.definitions[r.nativeDef] && n.default.prototype.definitions[r.nativeDef].optional)) return !0;
                                            g = !0, h = e;
                                        } else if (void 0 !== r.matches) {
                                            if (r.isGroup && u !== r) {
                                                if (r = l(t.matches[t.matches.indexOf(r) + 1], o, u)) return !0;
                                            } else if (r.isOptional) {
                                                var P = r, E = m.length;
                                                if (r = y(r, i, o, u)) {
                                                    if (m.forEach((function(e, t) {
                                                        t >= E && (e.match.optionality = e.match.optionality ? e.match.optionality + 1 : 1);
                                                    })), a = m[m.length - 1].match, void 0 !== u || !p(a, P)) return !0;
                                                    g = !0, h = e;
                                                }
                                            } else if (r.isAlternator) {
                                                var S, _ = r, w = [], M = m.slice(), O = o.length, T = !1, C = i.length > 0 ? i.shift() : -1;
                                                if (-1 === C || "string" == typeof C) {
                                                    var A, D = h, j = i.slice(), B = [];
                                                    if ("string" == typeof C) B = C.split(","); else for (A = 0; A < _.matches.length; A++) B.push(A.toString());
                                                    if (void 0 !== s.excludes[e]) {
                                                        for (var R = B.slice(), L = 0, I = s.excludes[e].length; L < I; L++) {
                                                            var F = s.excludes[e][L].toString().split(":");
                                                            o.length == F[1] && B.splice(B.indexOf(F[0]), 1);
                                                        }
                                                        0 === B.length && (delete s.excludes[e], B = R);
                                                    }
                                                    (!0 === c.keepStatic || isFinite(parseInt(c.keepStatic)) && D >= c.keepStatic) && (B = B.slice(0, 1));
                                                    for (var N = 0; N < B.length; N++) {
                                                        A = parseInt(B[N]), m = [], i = "string" == typeof C && v(h, A, O) || j.slice();
                                                        var V = _.matches[A];
                                                        if (V && l(V, [ A ].concat(o), u)) r = !0; else if (0 === N && (T = !0), V && V.matches && V.matches.length > _.matches[0].matches.length) break;
                                                        S = m.slice(), h = D, m = [];
                                                        for (var G = 0; G < S.length; G++) {
                                                            var H = S[G], K = !1;
                                                            H.match.jit = H.match.jit || T, H.alternation = H.alternation || O, b(H);
                                                            for (var U = 0; U < w.length; U++) {
                                                                var $ = w[U];
                                                                if ("string" != typeof C || void 0 !== H.alternation && B.includes(H.locator[H.alternation].toString())) {
                                                                    if (H.match.nativeDef === $.match.nativeDef) {
                                                                        K = !0, b($, H);
                                                                        break;
                                                                    }
                                                                    if (f(H, $, c)) {
                                                                        b(H, $) && (K = !0, w.splice(w.indexOf($), 0, H));
                                                                        break;
                                                                    }
                                                                    if (f($, H, c)) {
                                                                        b($, H);
                                                                        break;
                                                                    }
                                                                    if (Z = $, !0 === (Q = H).match.static && !0 !== Z.match.static && Z.match.fn.test(Q.match.def, s, e, !1, c, !1)) {
                                                                        x(H, $) || void 0 !== d.inputmask.userOptions.keepStatic ? b(H, $) && (K = !0, w.splice(w.indexOf($), 0, H)) : c.keepStatic = !0;
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                            K || w.push(H);
                                                        }
                                                    }
                                                    m = M.concat(w), h = e, g = m.length > 0, r = w.length > 0, i = j.slice();
                                                } else r = l(_.matches[C] || t.matches[C], [ C ].concat(o), u);
                                                if (r) return !0;
                                            } else if (r.isQuantifier && u !== t.matches[t.matches.indexOf(r) - 1]) for (var q = r, z = i.length > 0 ? i.shift() : 0; z < (isNaN(q.quantifier.max) ? z + 1 : q.quantifier.max) && h <= e; z++) {
                                                var W = t.matches[t.matches.indexOf(q) - 1];
                                                if (r = l(W, [ z ].concat(o), W)) {
                                                    if ((a = m[m.length - 1].match).optionalQuantifier = z >= q.quantifier.min, a.jit = (z + 1) * (W.matches.indexOf(a) + 1) > q.quantifier.jit, 
                                                    a.optionalQuantifier && p(a, W)) {
                                                        g = !0, h = e;
                                                        break;
                                                    }
                                                    return a.jit && (s.jitOffset[e] = W.matches.length - W.matches.indexOf(a)), !0;
                                                }
                                            } else if (r = y(r, i, o, u)) return !0;
                                        } else h++;
                                        var Q, Z;
                                    }
                                    for (var u = i.length > 0 ? i.shift() : 0; u < t.matches.length; u++) if (!0 !== t.matches[u].isQuantifier) {
                                        var p = l(t.matches[u], [ u ].concat(r), o);
                                        if (p && h === e) return p;
                                        if (h > e) break;
                                    }
                                }
                                if (e > -1) {
                                    if (void 0 === t) {
                                        for (var b, x = e - 1; void 0 === (b = s.validPositions[x] || s.tests[x]) && x > -1; ) x--;
                                        void 0 !== b && x > -1 && (v = function(e, t) {
                                            var i, a = [];
                                            return Array.isArray(t) || (t = [ t ]), t.length > 0 && (void 0 === t[0].alternation || !0 === c.keepStatic ? 0 === (a = u.call(o, e, t.slice()).locator.slice()).length && (a = t[0].locator.slice()) : t.forEach((function(e) {
                                                "" !== e.def && (0 === a.length ? (i = e.alternation, a = e.locator.slice()) : e.locator[i] && -1 === a[i].toString().indexOf(e.locator[i]) && (a[i] += "," + e.locator[i]));
                                            }))), a;
                                        }(x, b), k = v.join(""), h = x);
                                    }
                                    if (s.tests[e] && s.tests[e][0].cd === k) return s.tests[e];
                                    for (var P = v.shift(); P < p.length; P++) if (y(p[P], v, [ P ]) && h === e || h > e) break;
                                }
                                return (0 === m.length || g) && m.push({
                                    match: {
                                        fn: null,
                                        static: !0,
                                        optionality: !1,
                                        casing: null,
                                        def: "",
                                        placeholder: ""
                                    },
                                    locator: [],
                                    mloc: {},
                                    cd: k
                                }), void 0 !== t && s.tests[e] ? r = l.extend(!0, [], m) : (s.tests[e] = l.extend(!0, [], m), 
                                r = s.tests[e]), m.forEach((function(e) {
                                    e.match.optionality = !1;
                                })), r;
                            }
                        },
                        7215: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.alternate = s, t.checkAlternationMatch = function(e, t, i) {
                                for (var a, n = this.opts.greedy ? t : t.slice(0, 1), r = !1, o = void 0 !== i ? i.split(",") : [], l = 0; l < o.length; l++) -1 !== (a = e.indexOf(o[l])) && e.splice(a, 1);
                                for (var s = 0; s < e.length; s++) if (n.includes(e[s])) {
                                    r = !0;
                                    break;
                                }
                                return r;
                            }, t.handleRemove = function(e, t, i, a, l) {
                                var u = this, c = this.maskset, f = this.opts;
                                if ((f.numericInput || u.isRTL) && (t === r.default.BACKSPACE ? t = r.default.DELETE : t === r.default.DELETE && (t = r.default.BACKSPACE), 
                                u.isRTL)) {
                                    var d = i.end;
                                    i.end = i.begin, i.begin = d;
                                }
                                var p, h = o.getLastValidPosition.call(u, void 0, !0);
                                i.end >= o.getBuffer.call(u).length && h >= i.end && (i.end = h + 1);
                                t === r.default.BACKSPACE ? i.end - i.begin < 1 && (i.begin = o.seekPrevious.call(u, i.begin)) : t === r.default.DELETE && i.begin === i.end && (i.end = o.isMask.call(u, i.end, !0, !0) ? i.end + 1 : o.seekNext.call(u, i.end) + 1);
                                if (!1 !== (p = m.call(u, i))) {
                                    if (!0 !== a && !1 !== f.keepStatic || null !== f.regex && -1 !== n.getTest.call(u, i.begin).match.def.indexOf("|")) {
                                        var v = s.call(u, !0);
                                        if (v) {
                                            var g = void 0 !== v.caret ? v.caret : v.pos ? o.seekNext.call(u, v.pos.begin ? v.pos.begin : v.pos) : o.getLastValidPosition.call(u, -1, !0);
                                            (t !== r.default.DELETE || i.begin > g) && i.begin;
                                        }
                                    }
                                    !0 !== a && (c.p = t === r.default.DELETE ? i.begin + p : i.begin, c.p = o.determineNewCaretPosition.call(u, {
                                        begin: c.p,
                                        end: c.p
                                    }, !1, !1 === f.insertMode && t === r.default.BACKSPACE ? "none" : void 0).begin);
                                }
                            }, t.isComplete = c, t.isSelection = f, t.isValid = d, t.refreshFromBuffer = h, 
                            t.revalidateMask = m;
                            var a, n = i(4713), r = (a = i(5581)) && a.__esModule ? a : {
                                default: a
                            }, o = i(8711), l = i(6030);
                            function s(e, t, i, a, r, l) {
                                var u, c, f, p, h, v, m, g, k, y, b, x = this, P = this.dependencyLib, E = this.opts, S = x.maskset, _ = P.extend(!0, {}, S.validPositions), w = P.extend(!0, {}, S.tests), M = !1, O = !1, T = void 0 !== r ? r : o.getLastValidPosition.call(x);
                                if (l && (y = l.begin, b = l.end, l.begin > l.end && (y = l.end, b = l.begin)), 
                                -1 === T && void 0 === r) u = 0, c = (p = n.getTest.call(x, u)).alternation; else for (;T >= 0; T--) if ((f = S.validPositions[T]) && void 0 !== f.alternation) {
                                    if (p && p.locator[f.alternation] !== f.locator[f.alternation]) break;
                                    u = T, c = S.validPositions[u].alternation, p = f;
                                }
                                if (void 0 !== c) {
                                    m = parseInt(u), S.excludes[m] = S.excludes[m] || [], !0 !== e && S.excludes[m].push((0, 
                                    n.getDecisionTaker)(p) + ":" + p.alternation);
                                    var C = [], A = -1;
                                    for (h = m; h < o.getLastValidPosition.call(x, void 0, !0) + 1; h++) -1 === A && e <= h && void 0 !== t && (C.push(t), 
                                    A = C.length - 1), (v = S.validPositions[h]) && !0 !== v.generatedInput && (void 0 === l || h < y || h >= b) && C.push(v.input), 
                                    delete S.validPositions[h];
                                    for (-1 === A && void 0 !== t && (C.push(t), A = C.length - 1); void 0 !== S.excludes[m] && S.excludes[m].length < 10; ) {
                                        for (S.tests = {}, o.resetMaskSet.call(x, !0), M = !0, h = 0; h < C.length && (g = M.caret || o.getLastValidPosition.call(x, void 0, !0) + 1, 
                                        k = C[h], M = d.call(x, g, k, !1, a, !0)); h++) h === A && (O = M), 1 == e && M && (O = {
                                            caretPos: h
                                        });
                                        if (M) break;
                                        if (o.resetMaskSet.call(x), p = n.getTest.call(x, m), S.validPositions = P.extend(!0, {}, _), 
                                        S.tests = P.extend(!0, {}, w), !S.excludes[m]) {
                                            O = s.call(x, e, t, i, a, m - 1, l);
                                            break;
                                        }
                                        var D = (0, n.getDecisionTaker)(p);
                                        if (-1 !== S.excludes[m].indexOf(D + ":" + p.alternation)) {
                                            O = s.call(x, e, t, i, a, m - 1, l);
                                            break;
                                        }
                                        for (S.excludes[m].push(D + ":" + p.alternation), h = m; h < o.getLastValidPosition.call(x, void 0, !0) + 1; h++) delete S.validPositions[h];
                                    }
                                }
                                return O && !1 === E.keepStatic || delete S.excludes[m], O;
                            }
                            function u(e, t, i) {
                                var a = this.opts, n = this.maskset;
                                switch (a.casing || t.casing) {
                                  case "upper":
                                    e = e.toUpperCase();
                                    break;

                                  case "lower":
                                    e = e.toLowerCase();
                                    break;

                                  case "title":
                                    var o = n.validPositions[i - 1];
                                    e = 0 === i || o && o.input === String.fromCharCode(r.default.SPACE) ? e.toUpperCase() : e.toLowerCase();
                                    break;

                                  default:
                                    if ("function" == typeof a.casing) {
                                        var l = Array.prototype.slice.call(arguments);
                                        l.push(n.validPositions), e = a.casing.apply(this, l);
                                    }
                                }
                                return e;
                            }
                            function c(e) {
                                var t = this, i = this.opts, a = this.maskset;
                                if ("function" == typeof i.isComplete) return i.isComplete(e, i);
                                if ("*" !== i.repeat) {
                                    var r = !1, l = o.determineLastRequiredPosition.call(t, !0), s = o.seekPrevious.call(t, l.l);
                                    if (void 0 === l.def || l.def.newBlockMarker || l.def.optionality || l.def.optionalQuantifier) {
                                        r = !0;
                                        for (var u = 0; u <= s; u++) {
                                            var c = n.getTestTemplate.call(t, u).match;
                                            if (!0 !== c.static && void 0 === a.validPositions[u] && !0 !== c.optionality && !0 !== c.optionalQuantifier || !0 === c.static && e[u] !== n.getPlaceholder.call(t, u, c)) {
                                                r = !1;
                                                break;
                                            }
                                        }
                                    }
                                    return r;
                                }
                            }
                            function f(e) {
                                var t = this.opts.insertMode ? 0 : 1;
                                return this.isRTL ? e.begin - e.end > t : e.end - e.begin > t;
                            }
                            function d(e, t, i, a, r, l, p) {
                                var g = this, k = this.dependencyLib, y = this.opts, b = g.maskset;
                                i = !0 === i;
                                var x = e;
                                function P(e) {
                                    if (void 0 !== e) {
                                        if (void 0 !== e.remove && (Array.isArray(e.remove) || (e.remove = [ e.remove ]), 
                                        e.remove.sort((function(e, t) {
                                            return t.pos - e.pos;
                                        })).forEach((function(e) {
                                            m.call(g, {
                                                begin: e,
                                                end: e + 1
                                            });
                                        })), e.remove = void 0), void 0 !== e.insert && (Array.isArray(e.insert) || (e.insert = [ e.insert ]), 
                                        e.insert.sort((function(e, t) {
                                            return e.pos - t.pos;
                                        })).forEach((function(e) {
                                            "" !== e.c && d.call(g, e.pos, e.c, void 0 === e.strict || e.strict, void 0 !== e.fromIsValid ? e.fromIsValid : a);
                                        })), e.insert = void 0), e.refreshFromBuffer && e.buffer) {
                                            var t = e.refreshFromBuffer;
                                            h.call(g, !0 === t ? t : t.start, t.end, e.buffer), e.refreshFromBuffer = void 0;
                                        }
                                        void 0 !== e.rewritePosition && (x = e.rewritePosition, e = !0);
                                    }
                                    return e;
                                }
                                function E(t, i, r) {
                                    var l = !1;
                                    return n.getTests.call(g, t).every((function(s, c) {
                                        var d = s.match;
                                        if (o.getBuffer.call(g, !0), !1 !== (l = (!d.jit || void 0 !== b.validPositions[o.seekPrevious.call(g, t)]) && (null != d.fn ? d.fn.test(i, b, t, r, y, f.call(g, e)) : (i === d.def || i === y.skipOptionalPartCharacter) && "" !== d.def && {
                                            c: n.getPlaceholder.call(g, t, d, !0) || d.def,
                                            pos: t
                                        }))) {
                                            var p = void 0 !== l.c ? l.c : i, h = t;
                                            return p = p === y.skipOptionalPartCharacter && !0 === d.static ? n.getPlaceholder.call(g, t, d, !0) || d.def : p, 
                                            !0 !== (l = P(l)) && void 0 !== l.pos && l.pos !== t && (h = l.pos), !0 !== l && void 0 === l.pos && void 0 === l.c ? !1 : (!1 === m.call(g, e, k.extend({}, s, {
                                                input: u.call(g, p, d, h)
                                            }), a, h) && (l = !1), !1);
                                        }
                                        return !0;
                                    })), l;
                                }
                                void 0 !== e.begin && (x = g.isRTL ? e.end : e.begin);
                                var S = !0, _ = k.extend(!0, {}, b.validPositions);
                                if (!1 === y.keepStatic && void 0 !== b.excludes[x] && !0 !== r && !0 !== a) for (var w = x; w < (g.isRTL ? e.begin : e.end); w++) void 0 !== b.excludes[w] && (b.excludes[w] = void 0, 
                                delete b.tests[w]);
                                if ("function" == typeof y.preValidation && !0 !== a && !0 !== l && (S = P(S = y.preValidation.call(g, o.getBuffer.call(g), x, t, f.call(g, e), y, b, e, i || r))), 
                                !0 === S) {
                                    if (S = E(x, t, i), (!i || !0 === a) && !1 === S && !0 !== l) {
                                        var M = b.validPositions[x];
                                        if (!M || !0 !== M.match.static || M.match.def !== t && t !== y.skipOptionalPartCharacter) {
                                            if (y.insertMode || void 0 === b.validPositions[o.seekNext.call(g, x)] || e.end > x) {
                                                var O = !1;
                                                if (b.jitOffset[x] && void 0 === b.validPositions[o.seekNext.call(g, x)] && !1 !== (S = d.call(g, x + b.jitOffset[x], t, !0, !0)) && (!0 !== r && (S.caret = x), 
                                                O = !0), e.end > x && (b.validPositions[x] = void 0), !O && !o.isMask.call(g, x, y.keepStatic && 0 === x)) for (var T = x + 1, C = o.seekNext.call(g, x, !1, 0 !== x); T <= C; T++) if (!1 !== (S = E(T, t, i))) {
                                                    S = v.call(g, x, void 0 !== S.pos ? S.pos : T) || S, x = T;
                                                    break;
                                                }
                                            }
                                        } else S = {
                                            caret: o.seekNext.call(g, x)
                                        };
                                    }
                                    !1 !== S || !y.keepStatic || !c.call(g, o.getBuffer.call(g)) && 0 !== x || i || !0 === r ? f.call(g, e) && b.tests[x] && b.tests[x].length > 1 && y.keepStatic && !i && !0 !== r && (S = s.call(g, !0)) : S = s.call(g, x, t, i, a, void 0, e), 
                                    !0 === S && (S = {
                                        pos: x
                                    });
                                }
                                if ("function" == typeof y.postValidation && !0 !== a && !0 !== l) {
                                    var A = y.postValidation.call(g, o.getBuffer.call(g, !0), void 0 !== e.begin ? g.isRTL ? e.end : e.begin : e, t, S, y, b, i, p);
                                    void 0 !== A && (S = !0 === A ? S : A);
                                }
                                S && void 0 === S.pos && (S.pos = x), !1 === S || !0 === l ? (o.resetMaskSet.call(g, !0), 
                                b.validPositions = k.extend(!0, {}, _)) : v.call(g, void 0, x, !0);
                                var D = P(S);
                                void 0 !== g.maxLength && o.getBuffer.call(g).length > g.maxLength && !a && (o.resetMaskSet.call(g, !0), 
                                b.validPositions = k.extend(!0, {}, _), D = !1);
                                return D;
                            }
                            function p(e, t, i) {
                                for (var a = this.maskset, r = !1, o = n.getTests.call(this, e), l = 0; l < o.length; l++) {
                                    if (o[l].match && (o[l].match.nativeDef === t.match[i.shiftPositions ? "def" : "nativeDef"] && (!i.shiftPositions || !t.match.static) || o[l].match.nativeDef === t.match.nativeDef || i.regex && !o[l].match.static && o[l].match.fn.test(t.input))) {
                                        r = !0;
                                        break;
                                    }
                                    if (o[l].match && o[l].match.def === t.match.nativeDef) {
                                        r = void 0;
                                        break;
                                    }
                                }
                                return !1 === r && void 0 !== a.jitOffset[e] && (r = p.call(this, e + a.jitOffset[e], t, i)), 
                                r;
                            }
                            function h(e, t, i) {
                                var a, n, r = this, s = this.maskset, u = this.opts, c = this.dependencyLib, f = u.skipOptionalPartCharacter, d = r.isRTL ? i.slice().reverse() : i;
                                if (u.skipOptionalPartCharacter = "", !0 === e) o.resetMaskSet.call(r), s.tests = {}, 
                                e = 0, t = i.length, n = o.determineNewCaretPosition.call(r, {
                                    begin: 0,
                                    end: 0
                                }, !1).begin; else {
                                    for (a = e; a < t; a++) delete s.validPositions[a];
                                    n = e;
                                }
                                var p = new c.Event("keypress");
                                for (a = e; a < t; a++) {
                                    p.keyCode = d[a].toString().charCodeAt(0), r.ignorable = !1;
                                    var h = l.EventHandlers.keypressEvent.call(r, p, !0, !1, !1, n);
                                    !1 !== h && void 0 !== h && (n = h.forwardPosition);
                                }
                                u.skipOptionalPartCharacter = f;
                            }
                            function v(e, t, i) {
                                var a = this, r = this.maskset, l = this.dependencyLib;
                                if (void 0 === e) for (e = t - 1; e > 0 && !r.validPositions[e]; e--) ;
                                for (var s = e; s < t; s++) if (void 0 === r.validPositions[s] && !o.isMask.call(a, s, !1)) if (0 == s ? n.getTest.call(a, s) : r.validPositions[s - 1]) {
                                    var u = n.getTests.call(a, s).slice();
                                    "" === u[u.length - 1].match.def && u.pop();
                                    var c, f = n.determineTestTemplate.call(a, s, u);
                                    if (f && (!0 !== f.match.jit || "master" === f.match.newBlockMarker && (c = r.validPositions[s + 1]) && !0 === c.match.optionalQuantifier) && ((f = l.extend({}, f, {
                                        input: n.getPlaceholder.call(a, s, f.match, !0) || f.match.def
                                    })).generatedInput = !0, m.call(a, s, f, !0), !0 !== i)) {
                                        var p = r.validPositions[t].input;
                                        return r.validPositions[t] = void 0, d.call(a, t, p, !0, !0);
                                    }
                                }
                            }
                            function m(e, t, i, a) {
                                var r = this, l = this.maskset, s = this.opts, u = this.dependencyLib;
                                function c(e, t, i) {
                                    var a = t[e];
                                    if (void 0 !== a && !0 === a.match.static && !0 !== a.match.optionality && (void 0 === t[0] || void 0 === t[0].alternation)) {
                                        var n = i.begin <= e - 1 ? t[e - 1] && !0 === t[e - 1].match.static && t[e - 1] : t[e - 1], r = i.end > e + 1 ? t[e + 1] && !0 === t[e + 1].match.static && t[e + 1] : t[e + 1];
                                        return n && r;
                                    }
                                    return !1;
                                }
                                var f = 0, h = void 0 !== e.begin ? e.begin : e, v = void 0 !== e.end ? e.end : e, m = !0;
                                if (e.begin > e.end && (h = e.end, v = e.begin), a = void 0 !== a ? a : h, h !== v || s.insertMode && void 0 !== l.validPositions[a] && void 0 === i || void 0 === t || t.match.optionalQuantifier || t.match.optionality) {
                                    var g, k = u.extend(!0, {}, l.validPositions), y = o.getLastValidPosition.call(r, void 0, !0);
                                    for (l.p = h, g = y; g >= h; g--) delete l.validPositions[g], void 0 === t && delete l.tests[g + 1];
                                    var b, x, P = a, E = P;
                                    for (t && (l.validPositions[a] = u.extend(!0, {}, t), E++, P++), g = t ? v : v - 1; g <= y; g++) {
                                        if (void 0 !== (b = k[g]) && !0 !== b.generatedInput && (g >= v || g >= h && c(g, k, {
                                            begin: h,
                                            end: v
                                        }))) {
                                            for (;"" !== n.getTest.call(r, E).match.def; ) {
                                                if (!1 !== (x = p.call(r, E, b, s)) || "+" === b.match.def) {
                                                    "+" === b.match.def && o.getBuffer.call(r, !0);
                                                    var S = d.call(r, E, b.input, "+" !== b.match.def, !0);
                                                    if (m = !1 !== S, P = (S.pos || E) + 1, !m && x) break;
                                                } else m = !1;
                                                if (m) {
                                                    void 0 === t && b.match.static && g === e.begin && f++;
                                                    break;
                                                }
                                                if (!m && o.getBuffer.call(r), E > l.maskLength) break;
                                                E++;
                                            }
                                            "" == n.getTest.call(r, E).match.def && (m = !1), E = P;
                                        }
                                        if (!m) break;
                                    }
                                    if (!m) return l.validPositions = u.extend(!0, {}, k), o.resetMaskSet.call(r, !0), 
                                    !1;
                                } else t && n.getTest.call(r, a).match.cd === t.match.cd && (l.validPositions[a] = u.extend(!0, {}, t));
                                return o.resetMaskSet.call(r, !0), f;
                            }
                        },
                        5581: function(e) {
                            e.exports = JSON.parse('{"BACKSPACE":8,"BACKSPACE_SAFARI":127,"DELETE":46,"DOWN":40,"END":35,"ENTER":13,"ESCAPE":27,"HOME":36,"INSERT":45,"LEFT":37,"PAGE_DOWN":34,"PAGE_UP":33,"RIGHT":39,"SPACE":32,"TAB":9,"UP":38,"X":88,"Z":90,"CONTROL":17,"PAUSE/BREAK":19,"WINDOWS_LEFT":91,"WINDOWS_RIGHT":92,"KEY_229":229}');
                        }
                    }, t = {};
                    function i(a) {
                        var n = t[a];
                        if (void 0 !== n) return n.exports;
                        var r = t[a] = {
                            exports: {}
                        };
                        return e[a](r, r.exports, i), r.exports;
                    }
                    var a = {};
                    return function() {
                        var e, t = a;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }), t.default = void 0, i(3851), i(219), i(207), i(5296);
                        var n = ((e = i(2394)) && e.__esModule ? e : {
                            default: e
                        }).default;
                        t.default = n;
                    }(), a;
                }();
            }));
        },
        81: module => {
            module.exports = function isShallowEqual(a, b) {
                if (a === b) return true;
                for (var i in a) if (!(i in b)) return false;
                for (var i in b) if (a[i] !== b[i]) return false;
                return true;
            };
        },
        9575: function(module, exports, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            (function(global, factory) {
                true ? module.exports = factory(global) : 0;
            })("undefined" !== typeof self ? self : "undefined" !== typeof window ? window : "undefined" !== typeof __webpack_require__.g ? __webpack_require__.g : this, (function(global) {
                "use strict";
                global = global || {};
                var _Base64 = global.Base64;
                var version = "2.6.4";
                var b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                var b64tab = function(bin) {
                    var t = {};
                    for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
                    return t;
                }(b64chars);
                var fromCharCode = String.fromCharCode;
                var cb_utob = function(c) {
                    if (c.length < 2) {
                        var cc = c.charCodeAt(0);
                        return cc < 128 ? c : cc < 2048 ? fromCharCode(192 | cc >>> 6) + fromCharCode(128 | 63 & cc) : fromCharCode(224 | cc >>> 12 & 15) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | 63 & cc);
                    } else {
                        cc = 65536 + 1024 * (c.charCodeAt(0) - 55296) + (c.charCodeAt(1) - 56320);
                        return fromCharCode(240 | cc >>> 18 & 7) + fromCharCode(128 | cc >>> 12 & 63) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | 63 & cc);
                    }
                };
                var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
                var utob = function(u) {
                    return u.replace(re_utob, cb_utob);
                };
                var cb_encode = function(ccc) {
                    var padlen = [ 0, 2, 1 ][ccc.length % 3], ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0), chars = [ b64chars.charAt(ord >>> 18), b64chars.charAt(ord >>> 12 & 63), padlen >= 2 ? "=" : b64chars.charAt(ord >>> 6 & 63), padlen >= 1 ? "=" : b64chars.charAt(63 & ord) ];
                    return chars.join("");
                };
                var btoa = global.btoa && "function" == typeof global.btoa ? function(b) {
                    return global.btoa(b);
                } : function(b) {
                    if (b.match(/[^\x00-\xFF]/)) throw new RangeError("The string contains invalid characters.");
                    return b.replace(/[\s\S]{1,3}/g, cb_encode);
                };
                var _encode = function(u) {
                    return btoa(utob(String(u)));
                };
                var mkUriSafe = function(b64) {
                    return b64.replace(/[+\/]/g, (function(m0) {
                        return "+" == m0 ? "-" : "_";
                    })).replace(/=/g, "");
                };
                var encode = function(u, urisafe) {
                    return urisafe ? mkUriSafe(_encode(u)) : _encode(u);
                };
                var encodeURI = function(u) {
                    return encode(u, true);
                };
                var fromUint8Array;
                if (global.Uint8Array) fromUint8Array = function(a, urisafe) {
                    var b64 = "";
                    for (var i = 0, l = a.length; i < l; i += 3) {
                        var a0 = a[i], a1 = a[i + 1], a2 = a[i + 2];
                        var ord = a0 << 16 | a1 << 8 | a2;
                        b64 += b64chars.charAt(ord >>> 18) + b64chars.charAt(ord >>> 12 & 63) + ("undefined" != typeof a1 ? b64chars.charAt(ord >>> 6 & 63) : "=") + ("undefined" != typeof a2 ? b64chars.charAt(63 & ord) : "=");
                    }
                    return urisafe ? mkUriSafe(b64) : b64;
                };
                var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
                var cb_btou = function(cccc) {
                    switch (cccc.length) {
                      case 4:
                        var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
                        return fromCharCode((offset >>> 10) + 55296) + fromCharCode((1023 & offset) + 56320);

                      case 3:
                        return fromCharCode((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));

                      default:
                        return fromCharCode((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
                    }
                };
                var btou = function(b) {
                    return b.replace(re_btou, cb_btou);
                };
                var cb_decode = function(cccc) {
                    var len = cccc.length, padlen = len % 4, n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0), chars = [ fromCharCode(n >>> 16), fromCharCode(n >>> 8 & 255), fromCharCode(255 & n) ];
                    chars.length -= [ 0, 0, 2, 1 ][padlen];
                    return chars.join("");
                };
                var _atob = global.atob && "function" == typeof global.atob ? function(a) {
                    return global.atob(a);
                } : function(a) {
                    return a.replace(/\S{1,4}/g, cb_decode);
                };
                var atob = function(a) {
                    return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ""));
                };
                var _decode = function(a) {
                    return btou(_atob(a));
                };
                var _fromURI = function(a) {
                    return String(a).replace(/[-_]/g, (function(m0) {
                        return "-" == m0 ? "+" : "/";
                    })).replace(/[^A-Za-z0-9\+\/]/g, "");
                };
                var decode = function(a) {
                    return _decode(_fromURI(a));
                };
                var toUint8Array;
                if (global.Uint8Array) toUint8Array = function(a) {
                    return Uint8Array.from(atob(_fromURI(a)), (function(c) {
                        return c.charCodeAt(0);
                    }));
                };
                var noConflict = function() {
                    var Base64 = global.Base64;
                    global.Base64 = _Base64;
                    return Base64;
                };
                global.Base64 = {
                    VERSION: version,
                    atob,
                    btoa,
                    fromBase64: decode,
                    toBase64: encode,
                    utob,
                    encode,
                    encodeURI,
                    btou,
                    decode,
                    noConflict,
                    fromUint8Array,
                    toUint8Array
                };
                if ("function" === typeof Object.defineProperty) {
                    var noEnum = function(v) {
                        return {
                            value: v,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        };
                    };
                    global.Base64.extendString = function() {
                        Object.defineProperty(String.prototype, "fromBase64", noEnum((function() {
                            return decode(this);
                        })));
                        Object.defineProperty(String.prototype, "toBase64", noEnum((function(urisafe) {
                            return encode(this, urisafe);
                        })));
                        Object.defineProperty(String.prototype, "toBase64URI", noEnum((function() {
                            return encode(this, true);
                        })));
                    };
                }
                if (global["Meteor"]) Base64 = global.Base64;
                if (true && module.exports) module.exports.Base64 = global.Base64; else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], 
                __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return global.Base64;
                }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                return {
                    Base64: global.Base64
                };
            }));
        },
        5097: function(module) {
            /**
 * lightgallery | 2.4.0 | January 29th 2022
 * http://www.lightgalleryjs.com/
 * Copyright (c) 2020 Sachin Neravath;
 * @license GPLv3
 */
            !function(t, e) {
                true ? module.exports = e() : 0;
            }(0, (function() {
                "use strict";
                var t = function() {
                    return (t = Object.assign || function(t) {
                        for (var e, i = 1, s = arguments.length; i < s; i++) for (var h in e = arguments[i]) Object.prototype.hasOwnProperty.call(e, h) && (t[h] = e[h]);
                        return t;
                    }).apply(this, arguments);
                }, e = {
                    thumbnail: !0,
                    animateThumb: !0,
                    currentPagerPosition: "middle",
                    alignThumbnails: "middle",
                    thumbWidth: 100,
                    thumbHeight: "80px",
                    thumbMargin: 5,
                    appendThumbnailsTo: ".lg-components",
                    toggleThumb: !1,
                    enableThumbDrag: !0,
                    enableThumbSwipe: !0,
                    thumbnailSwipeThreshold: 10,
                    loadYouTubeThumbnail: !0,
                    youTubeThumbSize: 1,
                    thumbnailPluginStrings: {
                        toggleThumbnails: "Toggle thumbnails"
                    }
                }, i = "lgContainerResize", s = "lgUpdateSlides", h = "lgBeforeOpen", n = "lgBeforeSlide";
                return function() {
                    function o(t, e) {
                        return this.thumbOuterWidth = 0, this.thumbTotalWidth = 0, this.translateX = 0, 
                        this.thumbClickable = !1, this.core = t, this.$LG = e, this;
                    }
                    return o.prototype.init = function() {
                        this.settings = t(t({}, e), this.core.settings), this.thumbOuterWidth = 0, this.thumbTotalWidth = this.core.galleryItems.length * (this.settings.thumbWidth + this.settings.thumbMargin), 
                        this.translateX = 0, this.setAnimateThumbStyles(), this.core.settings.allowMediaOverlap || (this.settings.toggleThumb = !1), 
                        this.settings.thumbnail && (this.build(), this.settings.animateThumb ? (this.settings.enableThumbDrag && this.enableThumbDrag(), 
                        this.settings.enableThumbSwipe && this.enableThumbSwipe(), this.thumbClickable = !1) : this.thumbClickable = !0, 
                        this.toggleThumbBar(), this.thumbKeyPress());
                    }, o.prototype.build = function() {
                        var t = this;
                        this.setThumbMarkup(), this.manageActiveClassOnSlideChange(), this.$lgThumb.first().on("click.lg touchend.lg", (function(e) {
                            var i = t.$LG(e.target);
                            i.hasAttribute("data-lg-item-id") && setTimeout((function() {
                                if (t.thumbClickable && !t.core.lgBusy) {
                                    var e = parseInt(i.attr("data-lg-item-id"));
                                    t.core.slide(e, !1, !0, !1);
                                }
                            }), 50);
                        })), this.core.LGel.on(n + ".thumb", (function(e) {
                            var i = e.detail.index;
                            t.animateThumb(i);
                        })), this.core.LGel.on(h + ".thumb", (function() {
                            t.thumbOuterWidth = t.core.outer.get().offsetWidth;
                        })), this.core.LGel.on(s + ".thumb", (function() {
                            t.rebuildThumbnails();
                        })), this.core.LGel.on(i + ".thumb", (function() {
                            t.core.lgOpened && setTimeout((function() {
                                t.thumbOuterWidth = t.core.outer.get().offsetWidth, t.animateThumb(t.core.index), 
                                t.thumbOuterWidth = t.core.outer.get().offsetWidth;
                            }), 50);
                        }));
                    }, o.prototype.setThumbMarkup = function() {
                        var t = "lg-thumb-outer ";
                        this.settings.alignThumbnails && (t += "lg-thumb-align-" + this.settings.alignThumbnails);
                        var e = '<div class="' + t + '">\n        <div class="lg-thumb lg-group">\n        </div>\n        </div>';
                        this.core.outer.addClass("lg-has-thumb"), ".lg-components" === this.settings.appendThumbnailsTo ? this.core.$lgComponents.append(e) : this.core.outer.append(e), 
                        this.$thumbOuter = this.core.outer.find(".lg-thumb-outer").first(), this.$lgThumb = this.core.outer.find(".lg-thumb").first(), 
                        this.settings.animateThumb && this.core.outer.find(".lg-thumb").css("transition-duration", this.core.settings.speed + "ms").css("width", this.thumbTotalWidth + "px").css("position", "relative"), 
                        this.setThumbItemHtml(this.core.galleryItems);
                    }, o.prototype.enableThumbDrag = function() {
                        var t = this, e = {
                            cords: {
                                startX: 0,
                                endX: 0
                            },
                            isMoved: !1,
                            newTranslateX: 0,
                            startTime: new Date,
                            endTime: new Date,
                            touchMoveTime: 0
                        }, i = !1;
                        this.$thumbOuter.addClass("lg-grab"), this.core.outer.find(".lg-thumb").first().on("mousedown.lg.thumb", (function(s) {
                            t.thumbTotalWidth > t.thumbOuterWidth && (s.preventDefault(), e.cords.startX = s.pageX, 
                            e.startTime = new Date, t.thumbClickable = !1, i = !0, t.core.outer.get().scrollLeft += 1, 
                            t.core.outer.get().scrollLeft -= 1, t.$thumbOuter.removeClass("lg-grab").addClass("lg-grabbing"));
                        })), this.$LG(window).on("mousemove.lg.thumb.global" + this.core.lgId, (function(s) {
                            t.core.lgOpened && i && (e.cords.endX = s.pageX, e = t.onThumbTouchMove(e));
                        })), this.$LG(window).on("mouseup.lg.thumb.global" + this.core.lgId, (function() {
                            t.core.lgOpened && (e.isMoved ? e = t.onThumbTouchEnd(e) : t.thumbClickable = !0, 
                            i && (i = !1, t.$thumbOuter.removeClass("lg-grabbing").addClass("lg-grab")));
                        }));
                    }, o.prototype.enableThumbSwipe = function() {
                        var t = this, e = {
                            cords: {
                                startX: 0,
                                endX: 0
                            },
                            isMoved: !1,
                            newTranslateX: 0,
                            startTime: new Date,
                            endTime: new Date,
                            touchMoveTime: 0
                        };
                        this.$lgThumb.on("touchstart.lg", (function(i) {
                            t.thumbTotalWidth > t.thumbOuterWidth && (i.preventDefault(), e.cords.startX = i.targetTouches[0].pageX, 
                            t.thumbClickable = !1, e.startTime = new Date);
                        })), this.$lgThumb.on("touchmove.lg", (function(i) {
                            t.thumbTotalWidth > t.thumbOuterWidth && (i.preventDefault(), e.cords.endX = i.targetTouches[0].pageX, 
                            e = t.onThumbTouchMove(e));
                        })), this.$lgThumb.on("touchend.lg", (function() {
                            e.isMoved ? e = t.onThumbTouchEnd(e) : t.thumbClickable = !0;
                        }));
                    }, o.prototype.rebuildThumbnails = function() {
                        var t = this;
                        this.$thumbOuter.addClass("lg-rebuilding-thumbnails"), setTimeout((function() {
                            t.thumbTotalWidth = t.core.galleryItems.length * (t.settings.thumbWidth + t.settings.thumbMargin), 
                            t.$lgThumb.css("width", t.thumbTotalWidth + "px"), t.$lgThumb.empty(), t.setThumbItemHtml(t.core.galleryItems), 
                            t.animateThumb(t.core.index);
                        }), 50), setTimeout((function() {
                            t.$thumbOuter.removeClass("lg-rebuilding-thumbnails");
                        }), 200);
                    }, o.prototype.setTranslate = function(t) {
                        this.$lgThumb.css("transform", "translate3d(-" + t + "px, 0px, 0px)");
                    }, o.prototype.getPossibleTransformX = function(t) {
                        return t > this.thumbTotalWidth - this.thumbOuterWidth && (t = this.thumbTotalWidth - this.thumbOuterWidth), 
                        t < 0 && (t = 0), t;
                    }, o.prototype.animateThumb = function(t) {
                        if (this.$lgThumb.css("transition-duration", this.core.settings.speed + "ms"), this.settings.animateThumb) {
                            var e = 0;
                            switch (this.settings.currentPagerPosition) {
                              case "left":
                                e = 0;
                                break;

                              case "middle":
                                e = this.thumbOuterWidth / 2 - this.settings.thumbWidth / 2;
                                break;

                              case "right":
                                e = this.thumbOuterWidth - this.settings.thumbWidth;
                            }
                            this.translateX = (this.settings.thumbWidth + this.settings.thumbMargin) * t - 1 - e, 
                            this.translateX > this.thumbTotalWidth - this.thumbOuterWidth && (this.translateX = this.thumbTotalWidth - this.thumbOuterWidth), 
                            this.translateX < 0 && (this.translateX = 0), this.setTranslate(this.translateX);
                        }
                    }, o.prototype.onThumbTouchMove = function(t) {
                        return t.newTranslateX = this.translateX, t.isMoved = !0, t.touchMoveTime = (new Date).valueOf(), 
                        t.newTranslateX -= t.cords.endX - t.cords.startX, t.newTranslateX = this.getPossibleTransformX(t.newTranslateX), 
                        this.setTranslate(t.newTranslateX), this.$thumbOuter.addClass("lg-dragging"), t;
                    }, o.prototype.onThumbTouchEnd = function(t) {
                        t.isMoved = !1, t.endTime = new Date, this.$thumbOuter.removeClass("lg-dragging");
                        var e = t.endTime.valueOf() - t.startTime.valueOf(), i = t.cords.endX - t.cords.startX, s = Math.abs(i) / e;
                        return s > .15 && t.endTime.valueOf() - t.touchMoveTime < 30 ? ((s += 1) > 2 && (s += 1), 
                        s += s * (Math.abs(i) / this.thumbOuterWidth), this.$lgThumb.css("transition-duration", Math.min(s - 1, 2) + "settings"), 
                        i *= s, this.translateX = this.getPossibleTransformX(this.translateX - i), this.setTranslate(this.translateX)) : this.translateX = t.newTranslateX, 
                        Math.abs(t.cords.endX - t.cords.startX) < this.settings.thumbnailSwipeThreshold && (this.thumbClickable = !0), 
                        t;
                    }, o.prototype.getThumbHtml = function(t, e) {
                        var i, s = this.core.galleryItems[e].__slideVideoInfo || {};
                        return i = s.youtube && this.settings.loadYouTubeThumbnail ? "//img.youtube.com/vi/" + s.youtube[1] + "/" + this.settings.youTubeThumbSize + ".jpg" : t, 
                        '<div data-lg-item-id="' + e + '" class="lg-thumb-item ' + (e === this.core.index ? " active" : "") + '" \n        style="width:' + this.settings.thumbWidth + "px; height: " + this.settings.thumbHeight + ";\n            margin-right: " + this.settings.thumbMargin + 'px;">\n            <img data-lg-item-id="' + e + '" src="' + i + '" />\n        </div>';
                    }, o.prototype.getThumbItemHtml = function(t) {
                        for (var e = "", i = 0; i < t.length; i++) e += this.getThumbHtml(t[i].thumb, i);
                        return e;
                    }, o.prototype.setThumbItemHtml = function(t) {
                        var e = this.getThumbItemHtml(t);
                        this.$lgThumb.html(e);
                    }, o.prototype.setAnimateThumbStyles = function() {
                        this.settings.animateThumb && this.core.outer.addClass("lg-animate-thumb");
                    }, o.prototype.manageActiveClassOnSlideChange = function() {
                        var t = this;
                        this.core.LGel.on(n + ".thumb", (function(e) {
                            var i = t.core.outer.find(".lg-thumb-item"), s = e.detail.index;
                            i.removeClass("active"), i.eq(s).addClass("active");
                        }));
                    }, o.prototype.toggleThumbBar = function() {
                        var t = this;
                        this.settings.toggleThumb && (this.core.outer.addClass("lg-can-toggle"), this.core.$toolbar.append('<button type="button" aria-label="' + this.settings.thumbnailPluginStrings.toggleThumbnails + '" class="lg-toggle-thumb lg-icon"></button>'), 
                        this.core.outer.find(".lg-toggle-thumb").first().on("click.lg", (function() {
                            t.core.outer.toggleClass("lg-components-open");
                        })));
                    }, o.prototype.thumbKeyPress = function() {
                        var t = this;
                        this.$LG(window).on("keydown.lg.thumb.global" + this.core.lgId, (function(e) {
                            t.core.lgOpened && t.settings.toggleThumb && (38 === e.keyCode ? (e.preventDefault(), 
                            t.core.outer.addClass("lg-components-open")) : 40 === e.keyCode && (e.preventDefault(), 
                            t.core.outer.removeClass("lg-components-open")));
                        }));
                    }, o.prototype.destroy = function() {
                        this.settings.thumbnail && (this.$LG(window).off(".lg.thumb.global" + this.core.lgId), 
                        this.core.LGel.off(".lg.thumb"), this.core.LGel.off(".thumb"), this.$thumbOuter.remove(), 
                        this.core.outer.removeClass("lg-has-thumb"));
                    }, o;
                }();
            }));
        },
        5086: function(module) {
            /**
 * lightgallery | 2.4.0 | January 29th 2022
 * http://www.lightgalleryjs.com/
 * Copyright (c) 2020 Sachin Neravath;
 * @license GPLv3
 */
            !function(t, e) {
                true ? module.exports = e() : 0;
            }(0, (function() {
                "use strict";
                var t = function() {
                    return (t = Object.assign || function(t) {
                        for (var e, o = 1, i = arguments.length; o < i; o++) for (var s in e = arguments[o]) Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
                        return t;
                    }).apply(this, arguments);
                }, e = {
                    scale: 1,
                    zoom: !0,
                    actualSize: !0,
                    showZoomInOutIcons: !1,
                    actualSizeIcons: {
                        zoomIn: "lg-zoom-in",
                        zoomOut: "lg-zoom-out"
                    },
                    enableZoomAfter: 300,
                    zoomPluginStrings: {
                        zoomIn: "Zoom in",
                        zoomOut: "Zoom out",
                        viewActualSize: "View actual size"
                    }
                }, o = "lgContainerResize", i = "lgBeforeOpen", s = "lgAfterOpen", a = "lgSlideItemLoad", r = "lgAfterSlide", n = "lgRotateLeft", l = "lgRotateRight", g = "lgFlipHorizontal", c = "lgFlipVertical";
                return function() {
                    function h(o, i) {
                        return this.core = o, this.$LG = i, this.settings = t(t({}, e), this.core.settings), 
                        this;
                    }
                    return h.prototype.buildTemplates = function() {
                        var t = this.settings.showZoomInOutIcons ? '<button id="' + this.core.getIdName("lg-zoom-in") + '" type="button" aria-label="' + this.settings.zoomPluginStrings.zoomIn + '" class="lg-zoom-in lg-icon"></button><button id="' + this.core.getIdName("lg-zoom-out") + '" type="button" aria-label="' + this.settings.zoomPluginStrings.zoomIn + '" class="lg-zoom-out lg-icon"></button>' : "";
                        this.settings.actualSize && (t += '<button id="' + this.core.getIdName("lg-actual-size") + '" type="button" aria-label="' + this.settings.zoomPluginStrings.viewActualSize + '" class="' + this.settings.actualSizeIcons.zoomIn + ' lg-icon"></button>'), 
                        this.core.outer.addClass("lg-use-transition-for-zoom"), this.core.$toolbar.first().append(t);
                    }, h.prototype.enableZoom = function(t) {
                        var e = this, o = this.settings.enableZoomAfter + t.detail.delay;
                        this.$LG("body").first().hasClass("lg-from-hash") && t.detail.delay ? o = 0 : this.$LG("body").first().removeClass("lg-from-hash"), 
                        this.zoomableTimeout = setTimeout((function() {
                            e.isImageSlide() && (e.core.getSlideItem(t.detail.index).addClass("lg-zoomable"), 
                            t.detail.index === e.core.index && e.setZoomEssentials());
                        }), o + 30);
                    }, h.prototype.enableZoomOnSlideItemLoad = function() {
                        this.core.LGel.on(a + ".zoom", this.enableZoom.bind(this));
                    }, h.prototype.getModifier = function(t, e, o) {
                        var i = t;
                        t = Math.abs(t);
                        var s = this.getCurrentTransform(o);
                        if (!s) return 1;
                        var a = 1;
                        if ("X" === e) {
                            var r = Math.sign(parseFloat(s[0]));
                            0 === t || 180 === t ? a = 1 : 90 === t && (a = -90 === i && 1 === r || 90 === i && -1 === r ? -1 : 1), 
                            a *= r;
                        } else {
                            var n = Math.sign(parseFloat(s[3]));
                            if (0 === t || 180 === t) a = 1; else if (90 === t) {
                                var l = parseFloat(s[1]), g = parseFloat(s[2]);
                                a = Math.sign(l * g * i * n);
                            }
                            a *= n;
                        }
                        return a;
                    }, h.prototype.getImageSize = function(t, e, o) {
                        return 90 === Math.abs(e) && (o = "x" === o ? "y" : "x"), t[{
                            y: "offsetHeight",
                            x: "offsetWidth"
                        }[o]];
                    }, h.prototype.getDragCords = function(t, e) {
                        return 90 === e ? {
                            x: t.pageY,
                            y: t.pageX
                        } : {
                            x: t.pageX,
                            y: t.pageY
                        };
                    }, h.prototype.getSwipeCords = function(t, e) {
                        var o = t.targetTouches[0].pageX, i = t.targetTouches[0].pageY;
                        return 90 === e ? {
                            x: i,
                            y: o
                        } : {
                            x: o,
                            y: i
                        };
                    }, h.prototype.getDragAllowedAxises = function(t, e) {
                        e = e || this.scale || 1;
                        var o = this.imageYSize * e > this.containerRect.height, i = this.imageXSize * e > this.containerRect.width;
                        return 90 === t ? {
                            allowX: o,
                            allowY: i
                        } : {
                            allowX: i,
                            allowY: o
                        };
                    }, h.prototype.getCurrentTransform = function(t) {
                        if (t) {
                            var e = window.getComputedStyle(t, null), o = e.getPropertyValue("-webkit-transform") || e.getPropertyValue("-moz-transform") || e.getPropertyValue("-ms-transform") || e.getPropertyValue("-o-transform") || e.getPropertyValue("transform") || "none";
                            return "none" !== o ? o.split("(")[1].split(")")[0].split(",") : void 0;
                        }
                    }, h.prototype.getCurrentRotation = function(t) {
                        if (!t) return 0;
                        var e = this.getCurrentTransform(t);
                        return e ? Math.round(Math.atan2(parseFloat(e[1]), parseFloat(e[0])) * (180 / Math.PI)) : 0;
                    }, h.prototype.setZoomEssentials = function() {
                        var t = this.core.getSlideItem(this.core.index).find(".lg-image").first(), e = this.core.getSlideItem(this.core.index).find(".lg-img-rotate").first().get();
                        this.rotateValue = this.getCurrentRotation(e), this.imageYSize = this.getImageSize(t.get(), this.rotateValue, "y"), 
                        this.imageXSize = this.getImageSize(t.get(), this.rotateValue, "x"), this.containerRect = this.core.outer.get().getBoundingClientRect(), 
                        this.modifierX = this.getModifier(this.rotateValue, "X", e), this.modifierY = this.getModifier(this.rotateValue, "Y", e);
                    }, h.prototype.zoomImage = function(t) {
                        var e, o, i = (this.containerRect.width - this.imageXSize) / 2 + this.containerRect.left, s = this.core.mediaContainerPosition, a = s.top, r = s.bottom, n = Math.abs(a - r) / 2, l = (this.containerRect.height - this.imageYSize - n * this.modifierX) / 2 + this.scrollTop + this.containerRect.top;
                        1 === t && (this.positionChanged = !1);
                        var g = this.getDragAllowedAxises(Math.abs(this.rotateValue), t), c = g.allowY, h = g.allowX;
                        this.positionChanged && (e = this.left / (this.scale - 1), o = this.top / (this.scale - 1), 
                        this.pageX = Math.abs(e) + i, this.pageY = Math.abs(o) + l, this.positionChanged = !1);
                        var m = this.getPossibleSwipeDragCords(this.rotateValue, t), u = (t - 1) * (i - this.pageX), d = (t - 1) * (l - this.pageY);
                        h ? this.isBeyondPossibleLeft(u, m.minX) ? u = m.minX : this.isBeyondPossibleRight(u, m.maxX) && (u = m.maxX) : t > 1 && (u < m.minX ? u = m.minX : u > m.maxX && (u = m.maxX)), 
                        c ? this.isBeyondPossibleTop(d, m.minY) ? d = m.minY : this.isBeyondPossibleBottom(d, m.maxY) && (d = m.maxY) : t > 1 && (d < m.minY ? d = m.minY : d > m.maxY && (d = m.maxY)), 
                        this.setZoomStyles({
                            x: u,
                            y: d,
                            scale: t
                        });
                    }, h.prototype.setZoomStyles = function(t) {
                        var e = this.core.getSlideItem(this.core.index).find(".lg-image").first(), o = this.core.outer.find(".lg-current .lg-dummy-img").first(), i = e.parent();
                        this.scale = t.scale, e.css("transform", "scale3d(" + t.scale + ", " + t.scale + ", 1)"), 
                        o.css("transform", "scale3d(" + t.scale + ", " + t.scale + ", 1)");
                        var s = "translate3d(" + t.x + "px, " + t.y + "px, 0)";
                        i.css("transform", s), this.left = t.x, this.top = t.y;
                    }, h.prototype.setActualSize = function(t, e) {
                        var o = this;
                        if (this.isImageSlide() && !this.core.outer.hasClass("lg-first-slide-loading")) {
                            var i = this.getCurrentImageActualSizeScale();
                            this.core.outer.hasClass("lg-zoomed") ? this.scale = 1 : this.scale = this.getScale(i), 
                            this.setPageCords(e), this.beginZoom(this.scale), this.zoomImage(this.scale), setTimeout((function() {
                                o.core.outer.removeClass("lg-grabbing").addClass("lg-grab");
                            }), 10);
                        }
                    }, h.prototype.getNaturalWidth = function(t) {
                        var e = this.core.getSlideItem(t).find(".lg-image").first(), o = this.core.galleryItems[t].width;
                        return o ? parseFloat(o) : e.get().naturalWidth;
                    }, h.prototype.getActualSizeScale = function(t, e) {
                        return t > e ? t / e || 2 : 1;
                    }, h.prototype.getCurrentImageActualSizeScale = function() {
                        var t = this.core.getSlideItem(this.core.index).find(".lg-image").first().get().offsetWidth, e = this.getNaturalWidth(this.core.index) || t;
                        return this.getActualSizeScale(e, t);
                    }, h.prototype.getPageCords = function(t) {
                        var e = {};
                        if (t) e.x = t.pageX || t.targetTouches[0].pageX, e.y = t.pageY || t.targetTouches[0].pageY; else {
                            var o = this.core.outer.get().getBoundingClientRect();
                            e.x = o.width / 2 + o.left, e.y = o.height / 2 + this.scrollTop + o.top;
                        }
                        return e;
                    }, h.prototype.setPageCords = function(t) {
                        var e = this.getPageCords(t);
                        this.pageX = e.x, this.pageY = e.y;
                    }, h.prototype.beginZoom = function(t) {
                        (this.core.outer.removeClass("lg-zoom-drag-transition lg-zoom-dragging"), t > 1) ? (this.core.outer.addClass("lg-zoomed"), 
                        this.core.getElementById("lg-actual-size").removeClass(this.settings.actualSizeIcons.zoomIn).addClass(this.settings.actualSizeIcons.zoomOut)) : this.resetZoom();
                        return t > 1;
                    }, h.prototype.getScale = function(t) {
                        var e = this.getCurrentImageActualSizeScale();
                        return t < 1 ? t = 1 : t > e && (t = e), t;
                    }, h.prototype.init = function() {
                        var t = this;
                        if (this.settings.zoom) {
                            this.buildTemplates(), this.enableZoomOnSlideItemLoad();
                            var e = null;
                            this.core.outer.on("dblclick.lg", (function(e) {
                                t.$LG(e.target).hasClass("lg-image") && t.setActualSize(t.core.index, e);
                            })), this.core.outer.on("touchstart.lg", (function(o) {
                                var i = t.$LG(o.target);
                                1 === o.targetTouches.length && i.hasClass("lg-image") && (e ? (clearTimeout(e), 
                                e = null, o.preventDefault(), t.setActualSize(t.core.index, o)) : e = setTimeout((function() {
                                    e = null;
                                }), 300));
                            })), this.core.LGel.on(o + ".zoom " + l + ".zoom " + n + ".zoom " + g + ".zoom " + c + ".zoom", (function() {
                                t.core.lgOpened && t.isImageSlide() && (t.setPageCords(), t.setZoomEssentials(), 
                                t.zoomImage(t.scale));
                            })), this.$LG(window).on("scroll.lg.zoom.global" + this.core.lgId, (function() {
                                t.core.lgOpened && (t.scrollTop = t.$LG(window).scrollTop());
                            })), this.core.getElementById("lg-zoom-out").on("click.lg", (function() {
                                t.core.outer.find(".lg-current .lg-image").get() && (t.scale -= t.settings.scale, 
                                t.scale = t.getScale(t.scale), t.beginZoom(t.scale), t.zoomImage(t.scale));
                            })), this.core.getElementById("lg-zoom-in").on("click.lg", (function() {
                                t.zoomIn();
                            })), this.core.getElementById("lg-actual-size").on("click.lg", (function() {
                                t.setActualSize(t.core.index);
                            })), this.core.LGel.on(i + ".zoom", (function() {
                                t.core.outer.find(".lg-item").removeClass("lg-zoomable");
                            })), this.core.LGel.on(s + ".zoom", (function() {
                                t.scrollTop = t.$LG(window).scrollTop(), t.pageX = t.core.outer.width() / 2, t.pageY = t.core.outer.height() / 2 + t.scrollTop, 
                                t.scale = 1;
                            })), this.core.LGel.on(r + ".zoom", (function(e) {
                                var o = e.detail.prevIndex;
                                t.scale = 1, t.positionChanged = !1, t.resetZoom(o), t.isImageSlide() && t.setZoomEssentials();
                            })), this.zoomDrag(), this.pinchZoom(), this.zoomSwipe(), this.zoomableTimeout = !1, 
                            this.positionChanged = !1;
                        }
                    }, h.prototype.zoomIn = function(t) {
                        this.isImageSlide() && (t ? this.scale = t : this.scale += this.settings.scale, 
                        this.scale = this.getScale(this.scale), this.beginZoom(this.scale), this.zoomImage(this.scale));
                    }, h.prototype.resetZoom = function(t) {
                        this.core.outer.removeClass("lg-zoomed lg-zoom-drag-transition");
                        var e = this.core.getElementById("lg-actual-size"), o = this.core.getSlideItem(void 0 !== t ? t : this.core.index);
                        e.removeClass(this.settings.actualSizeIcons.zoomOut).addClass(this.settings.actualSizeIcons.zoomIn), 
                        o.find(".lg-img-wrap").first().removeAttr("style"), o.find(".lg-image").first().removeAttr("style"), 
                        this.scale = 1, this.left = 0, this.top = 0, this.setPageCords();
                    }, h.prototype.getTouchDistance = function(t) {
                        return Math.sqrt((t.targetTouches[0].pageX - t.targetTouches[1].pageX) * (t.targetTouches[0].pageX - t.targetTouches[1].pageX) + (t.targetTouches[0].pageY - t.targetTouches[1].pageY) * (t.targetTouches[0].pageY - t.targetTouches[1].pageY));
                    }, h.prototype.pinchZoom = function() {
                        var t = this, e = 0, o = !1, i = 1, s = this.core.getSlideItem(this.core.index);
                        this.core.$inner.on("touchstart.lg", (function(o) {
                            s = t.core.getSlideItem(t.core.index), t.isImageSlide() && (2 !== o.targetTouches.length || t.core.outer.hasClass("lg-first-slide-loading") || !t.$LG(o.target).hasClass("lg-item") && !s.get().contains(o.target) || (i = t.scale || 1, 
                            t.core.outer.removeClass("lg-zoom-drag-transition lg-zoom-dragging"), t.core.touchAction = "pinch", 
                            e = t.getTouchDistance(o)));
                        })), this.core.$inner.on("touchmove.lg", (function(a) {
                            if (2 === a.targetTouches.length && "pinch" === t.core.touchAction && (t.$LG(a.target).hasClass("lg-item") || s.get().contains(a.target))) {
                                a.preventDefault();
                                var r = t.getTouchDistance(a), n = e - r;
                                !o && Math.abs(n) > 5 && (o = !0), o && (t.scale = Math.max(1, i + .008 * -n), t.zoomImage(t.scale));
                            }
                        })), this.core.$inner.on("touchend.lg", (function(i) {
                            "pinch" === t.core.touchAction && (t.$LG(i.target).hasClass("lg-item") || s.get().contains(i.target)) && (o = !1, 
                            e = 0, t.scale <= 1 ? t.resetZoom() : (t.scale = t.getScale(t.scale), t.zoomImage(t.scale), 
                            t.core.outer.addClass("lg-zoomed")), t.core.touchAction = void 0);
                        }));
                    }, h.prototype.touchendZoom = function(t, e, o, i, s, a) {
                        var r = e.x - t.x, n = e.y - t.y, l = Math.abs(r) / s + 1, g = Math.abs(n) / s + 1;
                        l > 2 && (l += 1), g > 2 && (g += 1), r *= l, n *= g;
                        var c = this.core.getSlideItem(this.core.index).find(".lg-img-wrap").first(), h = {};
                        h.x = this.left + r * this.modifierX, h.y = this.top + n * this.modifierY;
                        var m = this.getPossibleSwipeDragCords(a);
                        (Math.abs(r) > 15 || Math.abs(n) > 15) && (i && (this.isBeyondPossibleTop(h.y, m.minY) ? h.y = m.minY : this.isBeyondPossibleBottom(h.y, m.maxY) && (h.y = m.maxY)), 
                        o && (this.isBeyondPossibleLeft(h.x, m.minX) ? h.x = m.minX : this.isBeyondPossibleRight(h.x, m.maxX) && (h.x = m.maxX)), 
                        i ? this.top = h.y : h.y = this.top, o ? this.left = h.x : h.x = this.left, this.setZoomSwipeStyles(c, h), 
                        this.positionChanged = !0);
                    }, h.prototype.getZoomSwipeCords = function(t, e, o, i, s) {
                        var a = {};
                        if (i) {
                            if (a.y = this.top + (e.y - t.y) * this.modifierY, this.isBeyondPossibleTop(a.y, s.minY)) {
                                var r = s.minY - a.y;
                                a.y = s.minY - r / 6;
                            } else if (this.isBeyondPossibleBottom(a.y, s.maxY)) {
                                var n = a.y - s.maxY;
                                a.y = s.maxY + n / 6;
                            }
                        } else a.y = this.top;
                        if (o) {
                            if (a.x = this.left + (e.x - t.x) * this.modifierX, this.isBeyondPossibleLeft(a.x, s.minX)) {
                                var l = s.minX - a.x;
                                a.x = s.minX - l / 6;
                            } else if (this.isBeyondPossibleRight(a.x, s.maxX)) {
                                var g = a.x - s.maxX;
                                a.x = s.maxX + g / 6;
                            }
                        } else a.x = this.left;
                        return a;
                    }, h.prototype.isBeyondPossibleLeft = function(t, e) {
                        return t >= e;
                    }, h.prototype.isBeyondPossibleRight = function(t, e) {
                        return t <= e;
                    }, h.prototype.isBeyondPossibleTop = function(t, e) {
                        return t >= e;
                    }, h.prototype.isBeyondPossibleBottom = function(t, e) {
                        return t <= e;
                    }, h.prototype.isImageSlide = function() {
                        var t = this.core.galleryItems[this.core.index];
                        return "image" === this.core.getSlideType(t);
                    }, h.prototype.getPossibleSwipeDragCords = function(t, e) {
                        var o = e || this.scale || 1, i = Math.abs(o), s = this.core.mediaContainerPosition, a = s.top, r = s.bottom, n = Math.abs(a - r) / 2, l = (this.imageYSize - this.containerRect.height) / 2 + n * this.modifierX, g = this.containerRect.height - this.imageYSize * i + l, c = (this.imageXSize - this.containerRect.width) / 2, h = this.containerRect.width - this.imageXSize * i + c, m = {
                            minY: l,
                            maxY: g,
                            minX: c,
                            maxX: h
                        };
                        return 90 === Math.abs(t) && (m = {
                            minY: c,
                            maxY: h,
                            minX: l,
                            maxX: g
                        }), m;
                    }, h.prototype.setZoomSwipeStyles = function(t, e) {
                        t.css("transform", "translate3d(" + e.x + "px, " + e.y + "px, 0)");
                    }, h.prototype.zoomSwipe = function() {
                        var t, e, o = this, i = {}, s = {}, a = !1, r = !1, n = !1, l = new Date, g = (new Date, 
                        this.core.getSlideItem(this.core.index));
                        this.core.$inner.on("touchstart.lg", (function(s) {
                            if (o.isImageSlide() && (g = o.core.getSlideItem(o.core.index), (o.$LG(s.target).hasClass("lg-item") || g.get().contains(s.target)) && 1 === s.targetTouches.length && o.core.outer.hasClass("lg-zoomed"))) {
                                s.preventDefault(), l = new Date, o.core.touchAction = "zoomSwipe", e = o.core.getSlideItem(o.core.index).find(".lg-img-wrap").first();
                                var a = o.getDragAllowedAxises(Math.abs(o.rotateValue));
                                n = a.allowY, ((r = a.allowX) || n) && (i = o.getSwipeCords(s, Math.abs(o.rotateValue))), 
                                t = o.getPossibleSwipeDragCords(o.rotateValue), o.core.outer.addClass("lg-zoom-dragging lg-zoom-drag-transition");
                            }
                        })), this.core.$inner.on("touchmove.lg", (function(l) {
                            if (1 === l.targetTouches.length && "zoomSwipe" === o.core.touchAction && (o.$LG(l.target).hasClass("lg-item") || g.get().contains(l.target))) {
                                l.preventDefault(), o.core.touchAction = "zoomSwipe", s = o.getSwipeCords(l, Math.abs(o.rotateValue));
                                var c = o.getZoomSwipeCords(i, s, r, n, t);
                                (Math.abs(s.x - i.x) > 15 || Math.abs(s.y - i.y) > 15) && (a = !0, o.setZoomSwipeStyles(e, c));
                            }
                        })), this.core.$inner.on("touchend.lg", (function(t) {
                            if ("zoomSwipe" === o.core.touchAction && (o.$LG(t.target).hasClass("lg-item") || g.get().contains(t.target))) {
                                if (o.core.touchAction = void 0, o.core.outer.removeClass("lg-zoom-dragging"), !a) return;
                                a = !1;
                                var e = (new Date).valueOf() - l.valueOf();
                                o.touchendZoom(i, s, r, n, e, o.rotateValue);
                            }
                        }));
                    }, h.prototype.zoomDrag = function() {
                        var t, e, o, i, s = this, a = {}, r = {}, n = !1, l = !1, g = !1, c = !1;
                        this.core.outer.on("mousedown.lg.zoom", (function(e) {
                            if (s.isImageSlide()) {
                                var r = s.core.getSlideItem(s.core.index);
                                if (s.$LG(e.target).hasClass("lg-item") || r.get().contains(e.target)) {
                                    t = new Date, i = s.core.getSlideItem(s.core.index).find(".lg-img-wrap").first();
                                    var l = s.getDragAllowedAxises(Math.abs(s.rotateValue));
                                    c = l.allowY, g = l.allowX, s.core.outer.hasClass("lg-zoomed") && s.$LG(e.target).hasClass("lg-object") && (g || c) && (e.preventDefault(), 
                                    a = s.getDragCords(e, Math.abs(s.rotateValue)), o = s.getPossibleSwipeDragCords(s.rotateValue), 
                                    n = !0, s.core.outer.get().scrollLeft += 1, s.core.outer.get().scrollLeft -= 1, 
                                    s.core.outer.removeClass("lg-grab").addClass("lg-grabbing lg-zoom-drag-transition lg-zoom-dragging"));
                                }
                            }
                        })), this.$LG(window).on("mousemove.lg.zoom.global" + this.core.lgId, (function(t) {
                            if (n) {
                                l = !0, r = s.getDragCords(t, Math.abs(s.rotateValue));
                                var e = s.getZoomSwipeCords(a, r, g, c, o);
                                s.setZoomSwipeStyles(i, e);
                            }
                        })), this.$LG(window).on("mouseup.lg.zoom.global" + this.core.lgId, (function(o) {
                            if (n) {
                                if (e = new Date, n = !1, s.core.outer.removeClass("lg-zoom-dragging"), l && (a.x !== r.x || a.y !== r.y)) {
                                    r = s.getDragCords(o, Math.abs(s.rotateValue));
                                    var i = e.valueOf() - t.valueOf();
                                    s.touchendZoom(a, r, g, c, i, s.rotateValue);
                                }
                                l = !1;
                            }
                            s.core.outer.removeClass("lg-grabbing").addClass("lg-grab");
                        }));
                    }, h.prototype.closeGallery = function() {
                        this.resetZoom();
                    }, h.prototype.destroy = function() {
                        this.$LG(window).off(".lg.zoom.global" + this.core.lgId), this.core.LGel.off(".lg.zoom"), 
                        this.core.LGel.off(".zoom"), clearTimeout(this.zoomableTimeout), this.zoomableTimeout = !1;
                    }, h;
                }();
            }));
        },
        1296: (module, __unused_webpack_exports, __webpack_require__) => {
            var FUNC_ERROR_TEXT = "Expected a function";
            var NAN = 0 / 0;
            var symbolTag = "[object Symbol]";
            var reTrim = /^\s+|\s+$/g;
            var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
            var reIsBinary = /^0b[01]+$/i;
            var reIsOctal = /^0o[0-7]+$/i;
            var freeParseInt = parseInt;
            var freeGlobal = "object" == typeof __webpack_require__.g && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;
            var freeSelf = "object" == typeof self && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function("return this")();
            var objectProto = Object.prototype;
            var objectToString = objectProto.toString;
            var nativeMax = Math.max, nativeMin = Math.min;
            var now = function() {
                return root.Date.now();
            };
            function debounce(func, wait, options) {
                var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
                if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                wait = toNumber(wait) || 0;
                if (isObject(options)) {
                    leading = !!options.leading;
                    maxing = "maxWait" in options;
                    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                    trailing = "trailing" in options ? !!options.trailing : trailing;
                }
                function invokeFunc(time) {
                    var args = lastArgs, thisArg = lastThis;
                    lastArgs = lastThis = void 0;
                    lastInvokeTime = time;
                    result = func.apply(thisArg, args);
                    return result;
                }
                function leadingEdge(time) {
                    lastInvokeTime = time;
                    timerId = setTimeout(timerExpired, wait);
                    return leading ? invokeFunc(time) : result;
                }
                function remainingWait(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
                    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
                }
                function shouldInvoke(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                    return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                }
                function timerExpired() {
                    var time = now();
                    if (shouldInvoke(time)) return trailingEdge(time);
                    timerId = setTimeout(timerExpired, remainingWait(time));
                }
                function trailingEdge(time) {
                    timerId = void 0;
                    if (trailing && lastArgs) return invokeFunc(time);
                    lastArgs = lastThis = void 0;
                    return result;
                }
                function cancel() {
                    if (void 0 !== timerId) clearTimeout(timerId);
                    lastInvokeTime = 0;
                    lastArgs = lastCallTime = lastThis = timerId = void 0;
                }
                function flush() {
                    return void 0 === timerId ? result : trailingEdge(now());
                }
                function debounced() {
                    var time = now(), isInvoking = shouldInvoke(time);
                    lastArgs = arguments;
                    lastThis = this;
                    lastCallTime = time;
                    if (isInvoking) {
                        if (void 0 === timerId) return leadingEdge(lastCallTime);
                        if (maxing) {
                            timerId = setTimeout(timerExpired, wait);
                            return invokeFunc(lastCallTime);
                        }
                    }
                    if (void 0 === timerId) timerId = setTimeout(timerExpired, wait);
                    return result;
                }
                debounced.cancel = cancel;
                debounced.flush = flush;
                return debounced;
            }
            function isObject(value) {
                var type = typeof value;
                return !!value && ("object" == type || "function" == type);
            }
            function isObjectLike(value) {
                return !!value && "object" == typeof value;
            }
            function isSymbol(value) {
                return "symbol" == typeof value || isObjectLike(value) && objectToString.call(value) == symbolTag;
            }
            function toNumber(value) {
                if ("number" == typeof value) return value;
                if (isSymbol(value)) return NAN;
                if (isObject(value)) {
                    var other = "function" == typeof value.valueOf ? value.valueOf() : value;
                    value = isObject(other) ? other + "" : other;
                }
                if ("string" != typeof value) return 0 === value ? value : +value;
                value = value.replace(reTrim, "");
                var isBinary = reIsBinary.test(value);
                return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
            }
            module.exports = debounce;
        },
        3096: (module, __unused_webpack_exports, __webpack_require__) => {
            var FUNC_ERROR_TEXT = "Expected a function";
            var NAN = 0 / 0;
            var symbolTag = "[object Symbol]";
            var reTrim = /^\s+|\s+$/g;
            var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
            var reIsBinary = /^0b[01]+$/i;
            var reIsOctal = /^0o[0-7]+$/i;
            var freeParseInt = parseInt;
            var freeGlobal = "object" == typeof __webpack_require__.g && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;
            var freeSelf = "object" == typeof self && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function("return this")();
            var objectProto = Object.prototype;
            var objectToString = objectProto.toString;
            var nativeMax = Math.max, nativeMin = Math.min;
            var now = function() {
                return root.Date.now();
            };
            function debounce(func, wait, options) {
                var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
                if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                wait = toNumber(wait) || 0;
                if (isObject(options)) {
                    leading = !!options.leading;
                    maxing = "maxWait" in options;
                    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                    trailing = "trailing" in options ? !!options.trailing : trailing;
                }
                function invokeFunc(time) {
                    var args = lastArgs, thisArg = lastThis;
                    lastArgs = lastThis = void 0;
                    lastInvokeTime = time;
                    result = func.apply(thisArg, args);
                    return result;
                }
                function leadingEdge(time) {
                    lastInvokeTime = time;
                    timerId = setTimeout(timerExpired, wait);
                    return leading ? invokeFunc(time) : result;
                }
                function remainingWait(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
                    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
                }
                function shouldInvoke(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                    return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                }
                function timerExpired() {
                    var time = now();
                    if (shouldInvoke(time)) return trailingEdge(time);
                    timerId = setTimeout(timerExpired, remainingWait(time));
                }
                function trailingEdge(time) {
                    timerId = void 0;
                    if (trailing && lastArgs) return invokeFunc(time);
                    lastArgs = lastThis = void 0;
                    return result;
                }
                function cancel() {
                    if (void 0 !== timerId) clearTimeout(timerId);
                    lastInvokeTime = 0;
                    lastArgs = lastCallTime = lastThis = timerId = void 0;
                }
                function flush() {
                    return void 0 === timerId ? result : trailingEdge(now());
                }
                function debounced() {
                    var time = now(), isInvoking = shouldInvoke(time);
                    lastArgs = arguments;
                    lastThis = this;
                    lastCallTime = time;
                    if (isInvoking) {
                        if (void 0 === timerId) return leadingEdge(lastCallTime);
                        if (maxing) {
                            timerId = setTimeout(timerExpired, wait);
                            return invokeFunc(lastCallTime);
                        }
                    }
                    if (void 0 === timerId) timerId = setTimeout(timerExpired, wait);
                    return result;
                }
                debounced.cancel = cancel;
                debounced.flush = flush;
                return debounced;
            }
            function throttle(func, wait, options) {
                var leading = true, trailing = true;
                if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                if (isObject(options)) {
                    leading = "leading" in options ? !!options.leading : leading;
                    trailing = "trailing" in options ? !!options.trailing : trailing;
                }
                return debounce(func, wait, {
                    leading,
                    maxWait: wait,
                    trailing
                });
            }
            function isObject(value) {
                var type = typeof value;
                return !!value && ("object" == type || "function" == type);
            }
            function isObjectLike(value) {
                return !!value && "object" == typeof value;
            }
            function isSymbol(value) {
                return "symbol" == typeof value || isObjectLike(value) && objectToString.call(value) == symbolTag;
            }
            function toNumber(value) {
                if ("number" == typeof value) return value;
                if (isSymbol(value)) return NAN;
                if (isObject(value)) {
                    var other = "function" == typeof value.valueOf ? value.valueOf() : value;
                    value = isObject(other) ? other + "" : other;
                }
                if ("string" != typeof value) return 0 === value ? value : +value;
                value = value.replace(reTrim, "");
                var isBinary = reIsBinary.test(value);
                return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
            }
            module.exports = throttle;
        },
        845: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            __webpack_require__.d(__webpack_exports__, {
                default: () => __WEBPACK_DEFAULT_EXPORT__
            });
            var safeIsNaN = Number.isNaN || function ponyfill(value) {
                return "number" === typeof value && value !== value;
            };
            function isEqual(first, second) {
                if (first === second) return true;
                if (safeIsNaN(first) && safeIsNaN(second)) return true;
                return false;
            }
            function areInputsEqual(newInputs, lastInputs) {
                if (newInputs.length !== lastInputs.length) return false;
                for (var i = 0; i < newInputs.length; i++) if (!isEqual(newInputs[i], lastInputs[i])) return false;
                return true;
            }
            function memoizeOne(resultFn, isEqual) {
                if (void 0 === isEqual) isEqual = areInputsEqual;
                var lastThis;
                var lastArgs = [];
                var lastResult;
                var calledOnce = false;
                function memoized() {
                    var newArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) newArgs[_i] = arguments[_i];
                    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) return lastResult;
                    lastResult = resultFn.apply(this, newArgs);
                    calledOnce = true;
                    lastThis = this;
                    lastArgs = newArgs;
                    return lastResult;
                }
                return memoized;
            }
            const __WEBPACK_DEFAULT_EXPORT__ = memoizeOne;
        },
        4193: (module, __unused_webpack_exports, __webpack_require__) => {
            var wildcard = __webpack_require__(1898);
            var reMimePartSplit = /[\/\+\.]/;
            module.exports = function(target, pattern) {
                function test(pattern) {
                    var result = wildcard(pattern, target, reMimePartSplit);
                    return result && result.length >= 2;
                }
                return pattern ? test(pattern.split(";")[0]) : test;
            };
        },
        1898: module => {
            "use strict";
            function WildcardMatcher(text, separator) {
                this.text = text = text || "";
                this.hasWild = ~text.indexOf("*");
                this.separator = separator;
                this.parts = text.split(separator);
            }
            WildcardMatcher.prototype.match = function(input) {
                var matches = true;
                var parts = this.parts;
                var ii;
                var partsCount = parts.length;
                var testParts;
                if ("string" == typeof input || input instanceof String) if (!this.hasWild && this.text != input) matches = false; else {
                    testParts = (input || "").split(this.separator);
                    for (ii = 0; matches && ii < partsCount; ii++) if ("*" === parts[ii]) continue; else if (ii < testParts.length) matches = parts[ii] === testParts[ii]; else matches = false;
                    matches = matches && testParts;
                } else if ("function" == typeof input.splice) {
                    matches = [];
                    for (ii = input.length; ii--; ) if (this.match(input[ii])) matches[matches.length] = input[ii];
                } else if ("object" == typeof input) {
                    matches = {};
                    for (var key in input) if (this.match(key)) matches[key] = input[key];
                }
                return matches;
            };
            module.exports = function(text, test, separator) {
                var matcher = new WildcardMatcher(text, separator || /[\/\.]/);
                if ("undefined" != typeof test) return matcher.match(test);
                return matcher;
            };
        },
        4800: module => {
            module.exports = function createNamespaceEmitter() {
                var emitter = {};
                var _fns = emitter._fns = {};
                emitter.emit = function emit(event, arg1, arg2, arg3, arg4, arg5, arg6) {
                    var toEmit = getListeners(event);
                    if (toEmit.length) emitAll(event, toEmit, [ arg1, arg2, arg3, arg4, arg5, arg6 ]);
                };
                emitter.on = function on(event, fn) {
                    if (!_fns[event]) _fns[event] = [];
                    _fns[event].push(fn);
                };
                emitter.once = function once(event, fn) {
                    function one() {
                        fn.apply(this, arguments);
                        emitter.off(event, one);
                    }
                    this.on(event, one);
                };
                emitter.off = function off(event, fn) {
                    var keep = [];
                    if (event && fn) {
                        var fns = this._fns[event];
                        var i = 0;
                        var l = fns ? fns.length : 0;
                        for (i; i < l; i++) if (fns[i] !== fn) keep.push(fns[i]);
                    }
                    keep.length ? this._fns[event] = keep : delete this._fns[event];
                };
                function getListeners(e) {
                    var out = _fns[e] ? _fns[e] : [];
                    var idx = e.indexOf(":");
                    var args = -1 === idx ? [ e ] : [ e.substring(0, idx), e.substring(idx + 1) ];
                    var keys = Object.keys(_fns);
                    var i = 0;
                    var l = keys.length;
                    for (i; i < l; i++) {
                        var key = keys[i];
                        if ("*" === key) out = out.concat(_fns[key]);
                        if (2 === args.length && args[0] === key) {
                            out = out.concat(_fns[key]);
                            break;
                        }
                    }
                    return out;
                }
                function emitAll(e, fns, args) {
                    var i = 0;
                    var l = fns.length;
                    for (i; i < l; i++) {
                        if (!fns[i]) break;
                        fns[i].event = e;
                        fns[i].apply(fns[i], args);
                    }
                }
                return emitter;
            };
        },
        6400: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            __webpack_require__.d(__webpack_exports__, {
                Component: () => _,
                Fragment: () => d,
                cloneElement: () => B,
                createContext: () => D,
                createElement: () => v,
                createRef: () => p,
                h: () => v,
                hydrate: () => q,
                isValidElement: () => i,
                options: () => l,
                render: () => S,
                toChildArray: () => A
            });
            var n, l, u, i, t, o, r, f, e = {}, c = [], s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
            function a(n, l) {
                for (var u in l) n[u] = l[u];
                return n;
            }
            function h(n) {
                var l = n.parentNode;
                l && l.removeChild(n);
            }
            function v(l, u, i) {
                var t, o, r, f = {};
                for (r in u) "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
                if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), 
                "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) void 0 === f[r] && (f[r] = l.defaultProps[r]);
                return y(l, f, t, o, null);
            }
            function y(n, i, t, o, r) {
                var f = {
                    type: n,
                    props: i,
                    key: t,
                    ref: o,
                    __k: null,
                    __: null,
                    __b: 0,
                    __e: null,
                    __d: void 0,
                    __c: null,
                    __h: null,
                    constructor: void 0,
                    __v: null == r ? ++u : r
                };
                return null == r && null != l.vnode && l.vnode(f), f;
            }
            function p() {
                return {
                    current: null
                };
            }
            function d(n) {
                return n.children;
            }
            function _(n, l) {
                this.props = n, this.context = l;
            }
            function k(n, l) {
                if (null == l) return n.__ ? k(n.__, n.__.__k.indexOf(n) + 1) : null;
                for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
                return "function" == typeof n.type ? k(n) : null;
            }
            function b(n) {
                var l, u;
                if (null != (n = n.__) && null != n.__c) {
                    for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
                        n.__e = n.__c.base = u.__e;
                        break;
                    }
                    return b(n);
                }
            }
            function m(n) {
                (!n.__d && (n.__d = !0) && t.push(n) && !g.__r++ || r !== l.debounceRendering) && ((r = l.debounceRendering) || o)(g);
            }
            function g() {
                for (var n; g.__r = t.length; ) n = t.sort((function(n, l) {
                    return n.__v.__b - l.__v.__b;
                })), t = [], n.some((function(n) {
                    var l, u, i, t, o, r;
                    n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = a({}, t)).__v = t.__v + 1, 
                    j(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [ o ] : null, u, null == o ? k(t) : o, t.__h), 
                    z(u, t), t.__e != o && b(t)));
                }));
            }
            function w(n, l, u, i, t, o, r, f, s, a) {
                var h, v, p, _, b, m, g, w = i && i.__k || c, A = w.length;
                for (u.__k = [], h = 0; h < l.length; h++) if (null != (_ = u.__k[h] = null == (_ = l[h]) || "boolean" == typeof _ ? null : "string" == typeof _ || "number" == typeof _ || "bigint" == typeof _ ? y(null, _, null, null, _) : Array.isArray(_) ? y(d, {
                    children: _
                }, null, null, null) : _.__b > 0 ? y(_.type, _.props, _.key, null, _.__v) : _)) {
                    if (_.__ = u, _.__b = u.__b + 1, null === (p = w[h]) || p && _.key == p.key && _.type === p.type) w[h] = void 0; else for (v = 0; v < A; v++) {
                        if ((p = w[v]) && _.key == p.key && _.type === p.type) {
                            w[v] = void 0;
                            break;
                        }
                        p = null;
                    }
                    j(n, _, p = p || e, t, o, r, f, s, a), b = _.__e, (v = _.ref) && p.ref != v && (g || (g = []), 
                    p.ref && g.push(p.ref, null, _), g.push(v, _.__c || b, _)), null != b ? (null == m && (m = b), 
                    "function" == typeof _.type && _.__k === p.__k ? _.__d = s = x(_, s, n) : s = P(n, _, p, w, b, s), 
                    "function" == typeof u.type && (u.__d = s)) : s && p.__e == s && s.parentNode != n && (s = k(p));
                }
                for (u.__e = m, h = A; h--; ) null != w[h] && ("function" == typeof u.type && null != w[h].__e && w[h].__e == u.__d && (u.__d = k(i, h + 1)), 
                N(w[h], w[h]));
                if (g) for (h = 0; h < g.length; h++) M(g[h], g[++h], g[++h]);
            }
            function x(n, l, u) {
                for (var i, t = n.__k, o = 0; t && o < t.length; o++) (i = t[o]) && (i.__ = n, l = "function" == typeof i.type ? x(i, l, u) : P(u, i, i, t, i.__e, l));
                return l;
            }
            function A(n, l) {
                return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some((function(n) {
                    A(n, l);
                })) : l.push(n)), l;
            }
            function P(n, l, u, i, t, o) {
                var r, f, e;
                if (void 0 !== l.__d) r = l.__d, l.__d = void 0; else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), 
                r = null; else {
                    for (f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 2) if (f == t) break n;
                    n.insertBefore(t, o), r = o;
                }
                return void 0 !== r ? r : t.nextSibling;
            }
            function C(n, l, u, i, t) {
                var o;
                for (o in u) "children" === o || "key" === o || o in l || H(n, o, null, u[o], i);
                for (o in l) t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H(n, o, l[o], u[o], i);
            }
            function $(n, l, u) {
                "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || s.test(l) ? u : u + "px";
            }
            function H(n, l, u, i, t) {
                var o;
                n: if ("style" === l) if ("string" == typeof u) n.style.cssText = u; else {
                    if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) u && l in u || $(n.style, l, "");
                    if (u) for (l in u) i && u[l] === i[l] || $(n.style, l, u[l]);
                } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), 
                l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), 
                n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T : I, o) : n.removeEventListener(l, o ? T : I, o); else if ("dangerouslySetInnerHTML" !== l) {
                    if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s"); else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
                        n[l] = null == u ? "" : u;
                        break n;
                    } catch (n) {}
                    "function" == typeof u || (null != u && (!1 !== u || "a" === l[0] && "r" === l[1]) ? n.setAttribute(l, u) : n.removeAttribute(l));
                }
            }
            function I(n) {
                this.l[n.type + !1](l.event ? l.event(n) : n);
            }
            function T(n) {
                this.l[n.type + !0](l.event ? l.event(n) : n);
            }
            function j(n, u, i, t, o, r, f, e, c) {
                var s, h, v, y, p, k, b, m, g, x, A, P = u.type;
                if (void 0 !== u.constructor) return null;
                null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [ e ]), (s = l.__b) && s(u);
                try {
                    n: if ("function" == typeof P) {
                        if (m = u.props, g = (s = P.contextType) && t[s.__c], x = s ? g ? g.props.value : s.__ : t, 
                        i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in P && P.prototype.render ? u.__c = h = new P(m, x) : (u.__c = h = new _(m, x), 
                        h.constructor = P, h.render = O), g && g.sub(h), h.props = m, h.state || (h.state = {}), 
                        h.context = x, h.__n = t, v = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), 
                        null != P.getDerivedStateFromProps && (h.__s == h.state && (h.__s = a({}, h.__s)), 
                        a(h.__s, P.getDerivedStateFromProps(m, h.__s))), y = h.props, p = h.state, v) null == P.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), 
                        null != h.componentDidMount && h.__h.push(h.componentDidMount); else {
                            if (null == P.getDerivedStateFromProps && m !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(m, x), 
                            !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(m, h.__s, x) || u.__v === i.__v) {
                                h.props = m, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, 
                                u.__k = i.__k, u.__k.forEach((function(n) {
                                    n && (n.__ = u);
                                })), h.__h.length && f.push(h);
                                break n;
                            }
                            null != h.componentWillUpdate && h.componentWillUpdate(m, h.__s, x), null != h.componentDidUpdate && h.__h.push((function() {
                                h.componentDidUpdate(y, p, k);
                            }));
                        }
                        h.context = x, h.props = m, h.state = h.__s, (s = l.__r) && s(u), h.__d = !1, h.__v = u, 
                        h.__P = n, s = h.render(h.props, h.state, h.context), h.state = h.__s, null != h.getChildContext && (t = a(a({}, t), h.getChildContext())), 
                        v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, p)), 
                        A = null != s && s.type === d && null == s.key ? s.props.children : s, w(n, Array.isArray(A) ? A : [ A ], u, i, t, o, r, f, e, c), 
                        h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), 
                        h.__e = !1;
                    } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L(i.__e, u, i, t, o, r, f, c);
                    (s = l.diffed) && s(u);
                } catch (n) {
                    u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), 
                    l.__e(n, u, i);
                }
            }
            function z(n, u) {
                l.__c && l.__c(u, n), n.some((function(u) {
                    try {
                        n = u.__h, u.__h = [], n.some((function(n) {
                            n.call(u);
                        }));
                    } catch (n) {
                        l.__e(n, u.__v);
                    }
                }));
            }
            function L(l, u, i, t, o, r, f, c) {
                var s, a, v, y = i.props, p = u.props, d = u.type, _ = 0;
                if ("svg" === d && (o = !0), null != r) for (;_ < r.length; _++) if ((s = r[_]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
                    l = s, r[_] = null;
                    break;
                }
                if (null == l) {
                    if (null === d) return document.createTextNode(p);
                    l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), 
                    r = null, c = !1;
                }
                if (null === d) y === p || c && l.data === p || (l.data = p); else {
                    if (r = r && n.call(l.childNodes), a = (y = i.props || e).dangerouslySetInnerHTML, 
                    v = p.dangerouslySetInnerHTML, !c) {
                        if (null != r) for (y = {}, _ = 0; _ < l.attributes.length; _++) y[l.attributes[_].name] = l.attributes[_].value;
                        (v || a) && (v && (a && v.__html == a.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
                    }
                    if (C(l, p, y, o, c), v) u.__k = []; else if (_ = u.props.children, w(l, Array.isArray(_) ? _ : [ _ ], u, i, t, o && "foreignObject" !== d, r, f, r ? r[0] : i.__k && k(i, 0), c), 
                    null != r) for (_ = r.length; _--; ) null != r[_] && h(r[_]);
                    c || ("value" in p && void 0 !== (_ = p.value) && (_ !== l.value || "progress" === d && !_ || "option" === d && _ !== y.value) && H(l, "value", _, y.value, !1), 
                    "checked" in p && void 0 !== (_ = p.checked) && _ !== l.checked && H(l, "checked", _, y.checked, !1));
                }
                return l;
            }
            function M(n, u, i) {
                try {
                    "function" == typeof n ? n(u) : n.current = u;
                } catch (n) {
                    l.__e(n, i);
                }
            }
            function N(n, u, i) {
                var t, o;
                if (l.unmount && l.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M(t, null, u)), 
                null != (t = n.__c)) {
                    if (t.componentWillUnmount) try {
                        t.componentWillUnmount();
                    } catch (n) {
                        l.__e(n, u);
                    }
                    t.base = t.__P = null;
                }
                if (t = n.__k) for (o = 0; o < t.length; o++) t[o] && N(t[o], u, "function" != typeof n.type);
                i || null == n.__e || h(n.__e), n.__e = n.__d = void 0;
            }
            function O(n, l, u) {
                return this.constructor(n, u);
            }
            function S(u, i, t) {
                var o, r, f;
                l.__ && l.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, 
                f = [], j(i, u = (!o && t || i).__k = v(d, null, [ u ]), r || e, e, void 0 !== i.ownerSVGElement, !o && t ? [ t ] : r ? null : i.firstChild ? n.call(i.childNodes) : null, f, !o && t ? t : r ? r.__e : i.firstChild, o), 
                z(f, u);
            }
            function q(n, l) {
                S(n, l, q);
            }
            function B(l, u, i) {
                var t, o, r, f = a({}, l.props);
                for (r in u) "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
                return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), 
                y(l.type, f, t || l.key, o || l.ref, null);
            }
            function D(n, l) {
                var u = {
                    __c: l = "__cC" + f++,
                    __: n,
                    Consumer: function(n, l) {
                        return n.children(l);
                    },
                    Provider: function(n) {
                        var u, i;
                        return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function() {
                            return i;
                        }, this.shouldComponentUpdate = function(n) {
                            this.props.value !== n.value && u.some(m);
                        }, this.sub = function(n) {
                            u.push(n);
                            var l = n.componentWillUnmount;
                            n.componentWillUnmount = function() {
                                u.splice(u.indexOf(n), 1), l && l.call(n);
                            };
                        }), n.children;
                    }
                };
                return u.Provider.__ = u.Consumer.contextType = u;
            }
            n = c.slice, l = {
                __e: function(n, l, u, i) {
                    for (var t, o, r; l = l.__; ) if ((t = l.__c) && !t.__) try {
                        if ((o = t.constructor) && null != o.getDerivedStateFromError && (t.setState(o.getDerivedStateFromError(n)), 
                        r = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), r = t.__d), 
                        r) return t.__E = t;
                    } catch (l) {
                        n = l;
                    }
                    throw n;
                }
            }, u = 0, i = function(n) {
                return null != n && void 0 === n.constructor;
            }, _.prototype.setState = function(n, l) {
                var u;
                u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = a({}, this.state), 
                "function" == typeof n && (n = n(a({}, u), this.props)), n && a(u, n), null != n && this.__v && (l && this.__h.push(l), 
                m(this));
            }, _.prototype.forceUpdate = function(n) {
                this.__v && (this.__e = !0, n && this.__h.push(n), m(this));
            }, _.prototype.render = d, t = [], o = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, 
            g.__r = 0, f = 0;
        },
        7129: (__unused_webpack_module, exports) => {
            "use strict";
            var undef, has = Object.prototype.hasOwnProperty;
            function decode(input) {
                try {
                    return decodeURIComponent(input.replace(/\+/g, " "));
                } catch (e) {
                    return null;
                }
            }
            function encode(input) {
                try {
                    return encodeURIComponent(input);
                } catch (e) {
                    return null;
                }
            }
            function querystring(query) {
                var part, parser = /([^=?#&]+)=?([^&]*)/g, result = {};
                while (part = parser.exec(query)) {
                    var key = decode(part[1]), value = decode(part[2]);
                    if (null === key || null === value || key in result) continue;
                    result[key] = value;
                }
                return result;
            }
            function querystringify(obj, prefix) {
                prefix = prefix || "";
                var value, key, pairs = [];
                if ("string" !== typeof prefix) prefix = "?";
                for (key in obj) if (has.call(obj, key)) {
                    value = obj[key];
                    if (!value && (null === value || value === undef || isNaN(value))) value = "";
                    key = encode(key);
                    value = encode(value);
                    if (null === key || null === value) continue;
                    pairs.push(key + "=" + value);
                }
                return pairs.length ? prefix + pairs.join("&") : "";
            }
            exports.stringify = querystringify;
            exports.parse = querystring;
        },
        7418: module => {
            "use strict";
            module.exports = function required(port, protocol) {
                protocol = protocol.split(":")[0];
                port = +port;
                if (!port) return false;
                switch (protocol) {
                  case "http":
                  case "ws":
                    return 80 !== port;

                  case "https":
                  case "wss":
                    return 443 !== port;

                  case "ftp":
                    return 21 !== port;

                  case "gopher":
                    return 70 !== port;

                  case "file":
                    return false;
                }
                return 0 !== port;
            };
        },
        70: (module, __unused_webpack_exports, __webpack_require__) => {
            __webpack_require__(4319);
        },
        4319: () => {
            /**
 * Sticksy.js
 * A library for making cool things like fixed widgets.
 * Dependency-free. ES5 code.
 * -
 * @version 0.2.0
 * @url https://github.com/kovart/sticksy
 * @author Artem Kovalchuk <kovart.dev@gmail.com>
 * @license The MIT License (MIT)
 */
            window.Sticksy = function() {
                "use strict";
                var States = {
                    STATIC: "static",
                    FIXED: "fixed",
                    STUCK: "stuck"
                };
                function Sticksy(target, options) {
                    if (!target) throw new Error("You have to specify the target element");
                    if ("string" !== typeof target && !(target instanceof Element)) throw new Error("Expected a string or element, but got: " + Object.prototype.toString.call(target));
                    var targetEl = Utils.findElement(target);
                    if (!targetEl) throw new Error("Cannot find target element: " + target);
                    var containerEl = targetEl.parentNode;
                    if (!containerEl) throw new Error("Cannot find container of target element: " + target);
                    options = options || {};
                    this._props = {
                        containerEl,
                        targetEl,
                        topSpacing: options.topSpacing || 0,
                        enabled: options.enabled || true,
                        listen: options.listen || false
                    };
                    this.onStateChanged = null;
                    this.nodeRef = targetEl;
                    this._initialize();
                }
                Sticksy.instances = [];
                Sticksy.enabledInstances = [];
                Sticksy.prototype._initialize = function() {
                    var that = this;
                    this.state = States.STATIC;
                    this._stickyNodes = [];
                    this._dummyNodes = [];
                    var sibling = this._props.targetEl;
                    while (sibling) {
                        var clone = sibling.cloneNode(true);
                        clone.style.visibility = "hidden";
                        clone.style.pointerEvents = "none";
                        clone.className += " sticksy-dummy-node";
                        clone.removeAttribute("id");
                        this._props.targetEl.parentNode.insertBefore(clone, this._props.targetEl);
                        this._stickyNodes.push(sibling);
                        this._dummyNodes.push(clone);
                        sibling = sibling.nextElementSibling;
                    }
                    this._stickyNodesHeight = 0;
                    this._limits = {
                        top: 0,
                        bottom: 0
                    };
                    this._isListening = false;
                    this._props.containerEl.style.position = "relative";
                    this._shouldCollapseMargins = -1 === getComputedStyle(this._props.containerEl).display.indexOf("flex");
                    if (this._props.listen) {
                        this._mutationObserver = new MutationObserver((function() {
                            that.hardRefresh();
                        }));
                        this._startListen();
                    }
                    Sticksy.instances.push(this);
                    if (this._props.enabled) Sticksy.enabledInstances.push(this);
                    this.hardRefresh();
                };
                Sticksy.prototype._startListen = function() {
                    if (!this._props.listen || this._isListening) return;
                    this._mutationObserver.observe(this._props.containerEl, {
                        attributes: true,
                        characterData: true,
                        childList: true,
                        subtree: true
                    });
                    this._isListening = true;
                };
                Sticksy.prototype._stopListen = function() {
                    if (!this._props.listen || !this._isListening) return;
                    this._mutationObserver.disconnect();
                    this._isListening = false;
                };
                Sticksy.prototype._calcState = function(windowOffset) {
                    if (windowOffset < this._limits.top) return States.STATIC; else if (windowOffset >= this._limits.bottom) return States.STUCK;
                    return States.FIXED;
                };
                Sticksy.prototype._updateStickyNodesHeight = function() {
                    this._stickyNodesHeight = Utils.getComputedBox(this._stickyNodes[this._stickyNodes.length - 1]).bottomWithMargin - Utils.getComputedBox(this._stickyNodes[0]).topWithMargin;
                };
                Sticksy.prototype._updateLimits = function() {
                    var containerEl = this._props.containerEl, stickyNodes = this._stickyNodes;
                    var containerBox = Utils.getComputedBox(containerEl), topNodeBox = Utils.getComputedBox(stickyNodes[0]);
                    this._limits = {
                        top: topNodeBox.topWithMargin - this._props.topSpacing,
                        bottom: containerBox.bottom - containerBox.paddingBottom - this._props.topSpacing - this._stickyNodesHeight
                    };
                };
                Sticksy.prototype._applyState = function(state) {
                    if (state === States.STATIC) {
                        this._resetElements(this._stickyNodes);
                        this._disableElements(this._dummyNodes);
                    } else {
                        this._fixElementsSize(this._stickyNodes);
                        if (state === States.FIXED) this._fixElements(this._stickyNodes); else this._stuckElements(this._stickyNodes);
                        this._enableElements(this._dummyNodes);
                    }
                };
                Sticksy.prototype.refresh = function() {
                    var state = this._calcState(window.pageYOffset, this._limits);
                    if (state === this.state) return;
                    this.state = state;
                    this._stopListen();
                    this._applyState(state);
                    this._startListen();
                    if ("function" === typeof this.onStateChanged) this.onStateChanged(state);
                };
                Sticksy.prototype.hardRefresh = function() {
                    this._stopListen();
                    var oldState = this.state;
                    this.state = States.STATIC;
                    this._applyState(this.state);
                    this._fixElementsSize(this._stickyNodes);
                    this._updateStickyNodesHeight();
                    this._updateLimits();
                    this.state = this._calcState(window.pageYOffset, this._limits);
                    this._applyState(this.state);
                    this._startListen();
                    if ("function" === typeof this.onStateChanged && oldState !== this.state) this.onStateChanged(this.state);
                };
                Sticksy.prototype.enable = function() {
                    this._props.enabled = true;
                    Sticksy.enabledInstances.push(this);
                    this.hardRefresh();
                };
                Sticksy.prototype.disable = function() {
                    this._props.enabled = false;
                    this.state = States.STATIC;
                    this._applyState(this.state);
                    Sticksy.enabledInstances.splice(Sticksy.enabledInstances.indexOf(this), 1);
                };
                Sticksy.prototype._fixElements = function(elements) {
                    var previousMarginBottom = 0;
                    var offset = this._props.topSpacing;
                    for (var i = 0; i < elements.length; i++) {
                        var el = elements[i];
                        var box = Utils.getComputedBox(el);
                        var extraMarginTop = this._shouldCollapseMargins ? Math.max(0, previousMarginBottom - box.marginTop) : previousMarginBottom;
                        el.style.position = "fixed";
                        el.style.top = offset + extraMarginTop + "px";
                        el.style.bottom = "";
                        offset += box.height + box.marginTop + extraMarginTop;
                        previousMarginBottom = box.marginBottom;
                    }
                };
                Sticksy.prototype._stuckElements = function(elements) {
                    var previousMarginTop = 0;
                    var offset = Utils.getComputedBox(this._props.containerEl).paddingBottom;
                    for (var i = elements.length - 1; i >= 0; i--) {
                        var el = elements[i];
                        var box = Utils.getComputedBox(el);
                        var extraMarginBottom = this._shouldCollapseMargins ? Math.max(0, previousMarginTop - box.marginBottom) : previousMarginTop;
                        el.style.position = "absolute";
                        el.style.top = "auto";
                        el.style.bottom = offset + extraMarginBottom + "px";
                        offset += box.height + box.marginBottom + extraMarginBottom;
                        previousMarginTop = box.marginTop;
                    }
                };
                Sticksy.prototype._resetElements = function(elements) {
                    elements.forEach((function(el) {
                        el.style.position = "";
                        el.style.top = "";
                        el.style.bottom = "";
                        el.style.height = "";
                        el.style.width = "";
                    }));
                };
                Sticksy.prototype._disableElements = function(elements) {
                    elements.forEach((function(el) {
                        el.style.display = "none";
                    }));
                };
                Sticksy.prototype._enableElements = function(elements) {
                    for (var i = 0; i < elements.length; i++) elements[i].style.display = getComputedStyle(this._stickyNodes[i]).display;
                };
                Sticksy.prototype._fixElementsSize = function() {
                    for (var i = 0; i < this._stickyNodes.length; i++) {
                        var stickyNode = this._stickyNodes[i];
                        var style = getComputedStyle(stickyNode);
                        stickyNode.style.width = style.width;
                        stickyNode.style.height = style.height;
                    }
                };
                Sticksy.refreshAll = function() {
                    for (var i = 0; i < Sticksy.enabledInstances.length; i++) Sticksy.enabledInstances[i].refresh();
                };
                Sticksy.hardRefreshAll = function() {
                    for (var i = 0; i < Sticksy.enabledInstances.length; i++) Sticksy.enabledInstances[i].hardRefresh();
                };
                Sticksy.enableAll = function() {
                    Sticksy.enabledInstances = Sticksy.instances.slice();
                    this.hardRefreshAll();
                };
                Sticksy.disableAll = function() {
                    var copy = Sticksy.enabledInstances.slice();
                    for (var i = 0; i < copy.length; i++) Sticksy.enabledInstances[i].disable();
                    Sticksy.enabledInstances = [];
                };
                Sticksy.initializeAll = function(target, options, ignoreNothingFound) {
                    if ("undefined" === typeof target) throw new Error("'target' parameter is undefined");
                    var elements = [];
                    if (target instanceof Element) elements = [ target ]; else if ("undefined" !== typeof target.length && target.length > 0 && target[0] instanceof Element) elements = "function" === typeof target.get ? target.get() : target; else if ("string" === typeof target) elements = document.querySelectorAll(target) || [];
                    var parents = [];
                    var stickyElements = [];
                    elements.forEach((function(el) {
                        if (-1 !== parents.indexOf(el.parentNode)) return;
                        parents.push(el.parentNode);
                        stickyElements.push(el);
                    }));
                    if (!ignoreNothingFound && !stickyElements.length) throw new Error("There are no elements to initialize");
                    return stickyElements.map((function(el) {
                        return new Sticksy(el, options);
                    }));
                };
                window.addEventListener("scroll", Sticksy.refreshAll);
                window.addEventListener("resize", Sticksy.hardRefreshAll);
                var Utils = {
                    parseNumber: function(val) {
                        return parseFloat(val) || 0;
                    },
                    findElement: function(el, root) {
                        if (!root) root = document;
                        return "string" === typeof el ? root.querySelector(el) : el instanceof Element ? el : void 0;
                    },
                    getComputedBox: function(elem) {
                        var box = elem.getBoundingClientRect();
                        var style = getComputedStyle(elem);
                        return {
                            height: box.height,
                            width: box.width,
                            top: window.pageYOffset + box.top,
                            bottom: window.pageYOffset + box.bottom,
                            marginTop: Utils.parseNumber(style.marginTop),
                            marginBottom: Utils.parseNumber(style.marginBottom),
                            paddingTop: Utils.parseNumber(style.paddingTop),
                            paddingBottom: Utils.parseNumber(style.paddingBottom),
                            topWithMargin: window.pageYOffset + box.top - Utils.parseNumber(style.marginTop),
                            bottomWithMargin: window.pageYOffset + box.bottom + Utils.parseNumber(style.marginBottom)
                        };
                    }
                };
                return Sticksy;
            }();
            var jQueryPlugin = window.$ || window.jQuery || window.Zepto;
            if (jQueryPlugin) jQueryPlugin.fn.sticksy = function sticksyPlugin(opts) {
                return window.Sticksy.initializeAll(this, opts);
            };
        },
        7956: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            __webpack_require__.d(__webpack_exports__, {
                HttpStack: () => XHRHttpStack,
                Upload: () => Upload,
                canStoreURLs: () => canStoreURLs,
                defaultOptions: () => browser_defaultOptions,
                enableDebugLog: () => enableDebugLog,
                isSupported: () => isSupported
            });
            var base64 = __webpack_require__(9575);
            var url_parse = __webpack_require__(4564);
            var url_parse_default = __webpack_require__.n(url_parse);
            function _typeof(obj) {
                "@babel/helpers - typeof";
                if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) _typeof = function _typeof(obj) {
                    return typeof obj;
                }; else _typeof = function _typeof(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
                return _typeof(obj);
            }
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function _inherits(subClass, superClass) {
                if ("function" !== typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) _setPrototypeOf(subClass, superClass);
            }
            function _createSuper(Derived) {
                var hasNativeReflectConstruct = _isNativeReflectConstruct();
                return function _createSuperInternal() {
                    var result, Super = _getPrototypeOf(Derived);
                    if (hasNativeReflectConstruct) {
                        var NewTarget = _getPrototypeOf(this).constructor;
                        result = Reflect.construct(Super, arguments, NewTarget);
                    } else result = Super.apply(this, arguments);
                    return _possibleConstructorReturn(this, result);
                };
            }
            function _possibleConstructorReturn(self, call) {
                if (call && ("object" === _typeof(call) || "function" === typeof call)) return call;
                return _assertThisInitialized(self);
            }
            function _assertThisInitialized(self) {
                if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return self;
            }
            function _wrapNativeSuper(Class) {
                var _cache = "function" === typeof Map ? new Map : void 0;
                _wrapNativeSuper = function _wrapNativeSuper(Class) {
                    if (null === Class || !_isNativeFunction(Class)) return Class;
                    if ("function" !== typeof Class) throw new TypeError("Super expression must either be null or a function");
                    if ("undefined" !== typeof _cache) {
                        if (_cache.has(Class)) return _cache.get(Class);
                        _cache.set(Class, Wrapper);
                    }
                    function Wrapper() {
                        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                    }
                    Wrapper.prototype = Object.create(Class.prototype, {
                        constructor: {
                            value: Wrapper,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                    return _setPrototypeOf(Wrapper, Class);
                };
                return _wrapNativeSuper(Class);
            }
            function _construct(Parent, args, Class) {
                if (_isNativeReflectConstruct()) _construct = Reflect.construct; else _construct = function _construct(Parent, args, Class) {
                    var a = [ null ];
                    a.push.apply(a, args);
                    var Constructor = Function.bind.apply(Parent, a);
                    var instance = new Constructor;
                    if (Class) _setPrototypeOf(instance, Class.prototype);
                    return instance;
                };
                return _construct.apply(null, arguments);
            }
            function _isNativeReflectConstruct() {
                if ("undefined" === typeof Reflect || !Reflect.construct) return false;
                if (Reflect.construct.sham) return false;
                if ("function" === typeof Proxy) return true;
                try {
                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
                    return true;
                } catch (e) {
                    return false;
                }
            }
            function _isNativeFunction(fn) {
                return -1 !== Function.toString.call(fn).indexOf("[native code]");
            }
            function _setPrototypeOf(o, p) {
                _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                    o.__proto__ = p;
                    return o;
                };
                return _setPrototypeOf(o, p);
            }
            function _getPrototypeOf(o) {
                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                    return o.__proto__ || Object.getPrototypeOf(o);
                };
                return _getPrototypeOf(o);
            }
            var DetailedError = function(_Error) {
                _inherits(DetailedError, _Error);
                var _super = _createSuper(DetailedError);
                function DetailedError(message) {
                    var _this;
                    var causingErr = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                    var req = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                    var res = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                    _classCallCheck(this, DetailedError);
                    _this = _super.call(this, message);
                    _this.originalRequest = req;
                    _this.originalResponse = res;
                    _this.causingError = causingErr;
                    if (null != causingErr) message += ", caused by ".concat(causingErr.toString());
                    if (null != req) {
                        var requestId = req.getHeader("X-Request-ID") || "n/a";
                        var method = req.getMethod();
                        var url = req.getURL();
                        var status = res ? res.getStatus() : "n/a";
                        var body = res ? res.getBody() || "" : "n/a";
                        message += ", originated from request (method: ".concat(method, ", url: ").concat(url, ", response code: ").concat(status, ", response text: ").concat(body, ", request id: ").concat(requestId, ")");
                    }
                    _this.message = message;
                    return _this;
                }
                return DetailedError;
            }(_wrapNativeSuper(Error));
            const error = DetailedError;
            var isEnabled = false;
            function enableDebugLog() {
                isEnabled = true;
            }
            function log(msg) {
                if (!isEnabled) return;
                console.log(msg);
            }
            function uuid() {
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(c) {
                    var r = 16 * Math.random() | 0;
                    var v = "x" == c ? r : 3 & r | 8;
                    return v.toString(16);
                }));
            }
            function ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);
                if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);
                    if (enumerableOnly) symbols = symbols.filter((function(sym) {
                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                    }));
                    keys.push.apply(keys, symbols);
                }
                return keys;
            }
            function _objectSpread(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = null != arguments[i] ? arguments[i] : {};
                    if (i % 2) ownKeys(Object(source), true).forEach((function(key) {
                        _defineProperty(target, key, source[key]);
                    })); else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); else ownKeys(Object(source)).forEach((function(key) {
                        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                    }));
                }
                return target;
            }
            function _defineProperty(obj, key, value) {
                if (key in obj) Object.defineProperty(obj, key, {
                    value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                }); else obj[key] = value;
                return obj;
            }
            function upload_classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                if (staticProps) _defineProperties(Constructor, staticProps);
                return Constructor;
            }
            var defaultOptions = {
                endpoint: null,
                uploadUrl: null,
                metadata: {},
                fingerprint: null,
                uploadSize: null,
                onProgress: null,
                onChunkComplete: null,
                onSuccess: null,
                onError: null,
                _onUploadUrlAvailable: null,
                overridePatchMethod: false,
                headers: {},
                addRequestId: false,
                onBeforeRequest: null,
                onAfterResponse: null,
                onShouldRetry: null,
                chunkSize: 1 / 0,
                retryDelays: [ 0, 1e3, 3e3, 5e3 ],
                parallelUploads: 1,
                storeFingerprintForResuming: true,
                removeFingerprintOnSuccess: false,
                uploadLengthDeferred: false,
                uploadDataDuringCreation: false,
                urlStorage: null,
                fileReader: null,
                httpStack: null
            };
            var BaseUpload = function() {
                function BaseUpload(file, options) {
                    upload_classCallCheck(this, BaseUpload);
                    if ("resume" in options) console.log("tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead.");
                    this.options = options;
                    this.options.chunkSize = +this.options.chunkSize;
                    this._urlStorage = this.options.urlStorage;
                    this.file = file;
                    this.url = null;
                    this._req = null;
                    this._fingerprint = null;
                    this._urlStorageKey = null;
                    this._offset = null;
                    this._aborted = false;
                    this._size = null;
                    this._source = null;
                    this._retryAttempt = 0;
                    this._retryTimeout = null;
                    this._offsetBeforeRetry = 0;
                    this._parallelUploads = null;
                    this._parallelUploadUrls = null;
                }
                _createClass(BaseUpload, [ {
                    key: "findPreviousUploads",
                    value: function findPreviousUploads() {
                        var _this = this;
                        return this.options.fingerprint(this.file, this.options).then((function(fingerprint) {
                            return _this._urlStorage.findUploadsByFingerprint(fingerprint);
                        }));
                    }
                }, {
                    key: "resumeFromPreviousUpload",
                    value: function resumeFromPreviousUpload(previousUpload) {
                        this.url = previousUpload.uploadUrl || null;
                        this._parallelUploadUrls = previousUpload.parallelUploadUrls || null;
                        this._urlStorageKey = previousUpload.urlStorageKey;
                    }
                }, {
                    key: "start",
                    value: function start() {
                        var _this2 = this;
                        var file = this.file;
                        if (!file) {
                            this._emitError(new Error("tus: no file or stream to upload provided"));
                            return;
                        }
                        if (!this.options.endpoint && !this.options.uploadUrl) {
                            this._emitError(new Error("tus: neither an endpoint or an upload URL is provided"));
                            return;
                        }
                        var retryDelays = this.options.retryDelays;
                        if (null != retryDelays && "[object Array]" !== Object.prototype.toString.call(retryDelays)) {
                            this._emitError(new Error("tus: the `retryDelays` option must either be an array or null"));
                            return;
                        }
                        if (this.options.parallelUploads > 1) [ "uploadUrl", "uploadSize", "uploadLengthDeferred" ].forEach((function(optionName) {
                            if (_this2.options[optionName]) _this2._emitError(new Error("tus: cannot use the ".concat(optionName, " option when parallelUploads is enabled")));
                        }));
                        this.options.fingerprint(file, this.options).then((function(fingerprint) {
                            if (null == fingerprint) log("No fingerprint was calculated meaning that the upload cannot be stored in the URL storage."); else log("Calculated fingerprint: ".concat(fingerprint));
                            _this2._fingerprint = fingerprint;
                            if (_this2._source) return _this2._source;
                            return _this2.options.fileReader.openFile(file, _this2.options.chunkSize);
                        })).then((function(source) {
                            _this2._source = source;
                            if (_this2.options.parallelUploads > 1 || null != _this2._parallelUploadUrls) _this2._startParallelUpload(); else _this2._startSingleUpload();
                        }))["catch"]((function(err) {
                            _this2._emitError(err);
                        }));
                    }
                }, {
                    key: "_startParallelUpload",
                    value: function _startParallelUpload() {
                        var _this3 = this;
                        var totalSize = this._size = this._source.size;
                        var totalProgress = 0;
                        this._parallelUploads = [];
                        var partCount = null != this._parallelUploadUrls ? this._parallelUploadUrls.length : this.options.parallelUploads;
                        var parts = splitSizeIntoParts(this._source.size, partCount, this._parallelUploadUrls);
                        this._parallelUploadUrls = new Array(parts.length);
                        var uploads = parts.map((function(part, index) {
                            var lastPartProgress = 0;
                            return _this3._source.slice(part.start, part.end).then((function(_ref) {
                                var value = _ref.value;
                                return new Promise((function(resolve, reject) {
                                    var options = _objectSpread(_objectSpread({}, _this3.options), {}, {
                                        uploadUrl: part.uploadUrl || null,
                                        storeFingerprintForResuming: false,
                                        removeFingerprintOnSuccess: false,
                                        parallelUploads: 1,
                                        metadata: {},
                                        headers: _objectSpread(_objectSpread({}, _this3.options.headers), {}, {
                                            "Upload-Concat": "partial"
                                        }),
                                        onSuccess: resolve,
                                        onError: reject,
                                        onProgress: function onProgress(newPartProgress) {
                                            totalProgress = totalProgress - lastPartProgress + newPartProgress;
                                            lastPartProgress = newPartProgress;
                                            _this3._emitProgress(totalProgress, totalSize);
                                        },
                                        _onUploadUrlAvailable: function _onUploadUrlAvailable() {
                                            _this3._parallelUploadUrls[index] = upload.url;
                                            if (_this3._parallelUploadUrls.filter((function(u) {
                                                return !!u;
                                            })).length === parts.length) _this3._saveUploadInUrlStorage();
                                        }
                                    });
                                    var upload = new BaseUpload(value, options);
                                    upload.start();
                                    _this3._parallelUploads.push(upload);
                                }));
                            }));
                        }));
                        var req;
                        Promise.all(uploads).then((function() {
                            req = _this3._openRequest("POST", _this3.options.endpoint);
                            req.setHeader("Upload-Concat", "final;".concat(_this3._parallelUploadUrls.join(" ")));
                            var metadata = encodeMetadata(_this3.options.metadata);
                            if ("" !== metadata) req.setHeader("Upload-Metadata", metadata);
                            return _this3._sendRequest(req, null);
                        })).then((function(res) {
                            if (!inStatusCategory(res.getStatus(), 200)) {
                                _this3._emitHttpError(req, res, "tus: unexpected response while creating upload");
                                return;
                            }
                            var location = res.getHeader("Location");
                            if (null == location) {
                                _this3._emitHttpError(req, res, "tus: invalid or missing Location header");
                                return;
                            }
                            _this3.url = resolveUrl(_this3.options.endpoint, location);
                            log("Created upload at ".concat(_this3.url));
                            _this3._emitSuccess();
                        }))["catch"]((function(err) {
                            _this3._emitError(err);
                        }));
                    }
                }, {
                    key: "_startSingleUpload",
                    value: function _startSingleUpload() {
                        if (this.options.uploadLengthDeferred) this._size = null; else if (null != this.options.uploadSize) {
                            this._size = +this.options.uploadSize;
                            if (isNaN(this._size)) {
                                this._emitError(new Error("tus: cannot convert `uploadSize` option into a number"));
                                return;
                            }
                        } else {
                            this._size = this._source.size;
                            if (null == this._size) {
                                this._emitError(new Error("tus: cannot automatically derive upload's size from input. Specify it manually using the `uploadSize` option or use the `uploadLengthDeferred` option"));
                                return;
                            }
                        }
                        this._aborted = false;
                        if (null != this.url) {
                            log("Resuming upload from previous URL: ".concat(this.url));
                            this._resumeUpload();
                            return;
                        }
                        if (null != this.options.uploadUrl) {
                            log("Resuming upload from provided URL: ".concat(this.options.uploadUrl));
                            this.url = this.options.uploadUrl;
                            this._resumeUpload();
                            return;
                        }
                        log("Creating a new upload");
                        this._createUpload();
                    }
                }, {
                    key: "abort",
                    value: function abort(shouldTerminate) {
                        var _this4 = this;
                        if (arguments.length > 1 && "function" === typeof arguments[1]) throw new Error("tus: the abort function does not accept a callback since v2 anymore; please use the returned Promise instead");
                        if (null != this._parallelUploads) this._parallelUploads.forEach((function(upload) {
                            upload.abort(shouldTerminate);
                        }));
                        if (null !== this._req) {
                            this._req.abort();
                            this._source.close();
                        }
                        this._aborted = true;
                        if (null != this._retryTimeout) {
                            clearTimeout(this._retryTimeout);
                            this._retryTimeout = null;
                        }
                        if (!shouldTerminate || null == this.url) return Promise.resolve();
                        return BaseUpload.terminate(this.url, this.options).then((function() {
                            return _this4._removeFromUrlStorage();
                        }));
                    }
                }, {
                    key: "_emitHttpError",
                    value: function _emitHttpError(req, res, message, causingErr) {
                        this._emitError(new error(message, causingErr, req, res));
                    }
                }, {
                    key: "_emitError",
                    value: function _emitError(err) {
                        var _this5 = this;
                        if (this._aborted) return;
                        if (null != this.options.retryDelays) {
                            var shouldResetDelays = null != this._offset && this._offset > this._offsetBeforeRetry;
                            if (shouldResetDelays) this._retryAttempt = 0;
                            if (shouldRetry(err, this._retryAttempt, this.options)) {
                                var delay = this.options.retryDelays[this._retryAttempt++];
                                this._offsetBeforeRetry = this._offset;
                                this._retryTimeout = setTimeout((function() {
                                    _this5.start();
                                }), delay);
                                return;
                            }
                        }
                        if ("function" === typeof this.options.onError) this.options.onError(err); else throw err;
                    }
                }, {
                    key: "_emitSuccess",
                    value: function _emitSuccess() {
                        if (this.options.removeFingerprintOnSuccess) this._removeFromUrlStorage();
                        if ("function" === typeof this.options.onSuccess) this.options.onSuccess();
                    }
                }, {
                    key: "_emitProgress",
                    value: function _emitProgress(bytesSent, bytesTotal) {
                        if ("function" === typeof this.options.onProgress) this.options.onProgress(bytesSent, bytesTotal);
                    }
                }, {
                    key: "_emitChunkComplete",
                    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {
                        if ("function" === typeof this.options.onChunkComplete) this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);
                    }
                }, {
                    key: "_createUpload",
                    value: function _createUpload() {
                        var _this6 = this;
                        if (!this.options.endpoint) {
                            this._emitError(new Error("tus: unable to create upload because no endpoint is provided"));
                            return;
                        }
                        var req = this._openRequest("POST", this.options.endpoint);
                        if (this.options.uploadLengthDeferred) req.setHeader("Upload-Defer-Length", 1); else req.setHeader("Upload-Length", this._size);
                        var metadata = encodeMetadata(this.options.metadata);
                        if ("" !== metadata) req.setHeader("Upload-Metadata", metadata);
                        var promise;
                        if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {
                            this._offset = 0;
                            promise = this._addChunkToRequest(req);
                        } else promise = this._sendRequest(req, null);
                        promise.then((function(res) {
                            if (!inStatusCategory(res.getStatus(), 200)) {
                                _this6._emitHttpError(req, res, "tus: unexpected response while creating upload");
                                return;
                            }
                            var location = res.getHeader("Location");
                            if (null == location) {
                                _this6._emitHttpError(req, res, "tus: invalid or missing Location header");
                                return;
                            }
                            _this6.url = resolveUrl(_this6.options.endpoint, location);
                            log("Created upload at ".concat(_this6.url));
                            if ("function" === typeof _this6.options._onUploadUrlAvailable) _this6.options._onUploadUrlAvailable();
                            if (0 === _this6._size) {
                                _this6._emitSuccess();
                                _this6._source.close();
                                return;
                            }
                            _this6._saveUploadInUrlStorage();
                            if (_this6.options.uploadDataDuringCreation) _this6._handleUploadResponse(req, res); else {
                                _this6._offset = 0;
                                _this6._performUpload();
                            }
                        }))["catch"]((function(err) {
                            _this6._emitHttpError(req, null, "tus: failed to create upload", err);
                        }));
                    }
                }, {
                    key: "_resumeUpload",
                    value: function _resumeUpload() {
                        var _this7 = this;
                        var req = this._openRequest("HEAD", this.url);
                        var promise = this._sendRequest(req, null);
                        promise.then((function(res) {
                            var status = res.getStatus();
                            if (!inStatusCategory(status, 200)) {
                                if (inStatusCategory(status, 400)) _this7._removeFromUrlStorage();
                                if (423 === status) {
                                    _this7._emitHttpError(req, res, "tus: upload is currently locked; retry later");
                                    return;
                                }
                                if (!_this7.options.endpoint) {
                                    _this7._emitHttpError(req, res, "tus: unable to resume upload (new upload cannot be created without an endpoint)");
                                    return;
                                }
                                _this7.url = null;
                                _this7._createUpload();
                                return;
                            }
                            var offset = parseInt(res.getHeader("Upload-Offset"), 10);
                            if (isNaN(offset)) {
                                _this7._emitHttpError(req, res, "tus: invalid or missing offset value");
                                return;
                            }
                            var length = parseInt(res.getHeader("Upload-Length"), 10);
                            if (isNaN(length) && !_this7.options.uploadLengthDeferred) {
                                _this7._emitHttpError(req, res, "tus: invalid or missing length value");
                                return;
                            }
                            if ("function" === typeof _this7.options._onUploadUrlAvailable) _this7.options._onUploadUrlAvailable();
                            if (offset === length) {
                                _this7._emitProgress(length, length);
                                _this7._emitSuccess();
                                return;
                            }
                            _this7._offset = offset;
                            _this7._performUpload();
                        }))["catch"]((function(err) {
                            _this7._emitHttpError(req, null, "tus: failed to resume upload", err);
                        }));
                    }
                }, {
                    key: "_performUpload",
                    value: function _performUpload() {
                        var _this8 = this;
                        if (this._aborted) return;
                        var req;
                        if (this.options.overridePatchMethod) {
                            req = this._openRequest("POST", this.url);
                            req.setHeader("X-HTTP-Method-Override", "PATCH");
                        } else req = this._openRequest("PATCH", this.url);
                        req.setHeader("Upload-Offset", this._offset);
                        var promise = this._addChunkToRequest(req);
                        promise.then((function(res) {
                            if (!inStatusCategory(res.getStatus(), 200)) {
                                _this8._emitHttpError(req, res, "tus: unexpected response while uploading chunk");
                                return;
                            }
                            _this8._handleUploadResponse(req, res);
                        }))["catch"]((function(err) {
                            if (_this8._aborted) return;
                            _this8._emitHttpError(req, null, "tus: failed to upload chunk at offset ".concat(_this8._offset), err);
                        }));
                    }
                }, {
                    key: "_addChunkToRequest",
                    value: function _addChunkToRequest(req) {
                        var _this9 = this;
                        var start = this._offset;
                        var end = this._offset + this.options.chunkSize;
                        req.setProgressHandler((function(bytesSent) {
                            _this9._emitProgress(start + bytesSent, _this9._size);
                        }));
                        req.setHeader("Content-Type", "application/offset+octet-stream");
                        if ((end === 1 / 0 || end > this._size) && !this.options.uploadLengthDeferred) end = this._size;
                        return this._source.slice(start, end).then((function(_ref2) {
                            var value = _ref2.value, done = _ref2.done;
                            if (_this9.options.uploadLengthDeferred && done) {
                                _this9._size = _this9._offset + (value && value.size ? value.size : 0);
                                req.setHeader("Upload-Length", _this9._size);
                            }
                            if (null === value) return _this9._sendRequest(req);
                            _this9._emitProgress(_this9._offset, _this9._size);
                            return _this9._sendRequest(req, value);
                        }));
                    }
                }, {
                    key: "_handleUploadResponse",
                    value: function _handleUploadResponse(req, res) {
                        var offset = parseInt(res.getHeader("Upload-Offset"), 10);
                        if (isNaN(offset)) {
                            this._emitHttpError(req, res, "tus: invalid or missing offset value");
                            return;
                        }
                        this._emitProgress(offset, this._size);
                        this._emitChunkComplete(offset - this._offset, offset, this._size);
                        this._offset = offset;
                        if (offset == this._size) {
                            this._emitSuccess();
                            this._source.close();
                            return;
                        }
                        this._performUpload();
                    }
                }, {
                    key: "_openRequest",
                    value: function _openRequest(method, url) {
                        var req = openRequest(method, url, this.options);
                        this._req = req;
                        return req;
                    }
                }, {
                    key: "_removeFromUrlStorage",
                    value: function _removeFromUrlStorage() {
                        var _this10 = this;
                        if (!this._urlStorageKey) return;
                        this._urlStorage.removeUpload(this._urlStorageKey)["catch"]((function(err) {
                            _this10._emitError(err);
                        }));
                        this._urlStorageKey = null;
                    }
                }, {
                    key: "_saveUploadInUrlStorage",
                    value: function _saveUploadInUrlStorage() {
                        var _this11 = this;
                        if (!this.options.storeFingerprintForResuming || !this._fingerprint) return;
                        var storedUpload = {
                            size: this._size,
                            metadata: this.options.metadata,
                            creationTime: (new Date).toString()
                        };
                        if (this._parallelUploads) storedUpload.parallelUploadUrls = this._parallelUploadUrls; else storedUpload.uploadUrl = this.url;
                        this._urlStorage.addUpload(this._fingerprint, storedUpload).then((function(urlStorageKey) {
                            return _this11._urlStorageKey = urlStorageKey;
                        }))["catch"]((function(err) {
                            _this11._emitError(err);
                        }));
                    }
                }, {
                    key: "_sendRequest",
                    value: function _sendRequest(req) {
                        var body = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                        return sendRequest(req, body, this.options);
                    }
                } ], [ {
                    key: "terminate",
                    value: function terminate(url, options) {
                        if (arguments.length > 1 && "function" === typeof arguments[arguments.length - 1]) throw new Error("tus: the terminate function does not accept a callback since v2 anymore; please use the returned Promise instead");
                        if (void 0 === options) options = {};
                        var req = openRequest("DELETE", url, options);
                        return sendRequest(req, null, options).then((function(res) {
                            if (204 === res.getStatus()) return;
                            throw new error("tus: unexpected response while terminating upload", null, req, res);
                        }))["catch"]((function(err) {
                            if (!(err instanceof error)) err = new error("tus: failed to terminate upload", err, req, null);
                            if (!shouldRetry(err, 0, options)) throw err;
                            var delay = options.retryDelays[0];
                            var remainingDelays = options.retryDelays.slice(1);
                            var newOptions = _objectSpread(_objectSpread({}, options), {}, {
                                retryDelays: remainingDelays
                            });
                            return new Promise((function(resolve) {
                                return setTimeout(resolve, delay);
                            })).then((function() {
                                return BaseUpload.terminate(url, newOptions);
                            }));
                        }));
                    }
                } ]);
                return BaseUpload;
            }();
            function encodeMetadata(metadata) {
                var encoded = [];
                for (var key in metadata) encoded.push("".concat(key, " ").concat(base64.Base64.encode(metadata[key])));
                return encoded.join(",");
            }
            function inStatusCategory(status, category) {
                return status >= category && status < category + 100;
            }
            function openRequest(method, url, options) {
                var req = options.httpStack.createRequest(method, url);
                req.setHeader("Tus-Resumable", "1.0.0");
                var headers = options.headers || {};
                for (var name in headers) req.setHeader(name, headers[name]);
                if (options.addRequestId) {
                    var requestId = uuid();
                    req.setHeader("X-Request-ID", requestId);
                }
                return req;
            }
            function sendRequest(req, body, options) {
                var onBeforeRequestPromise = "function" === typeof options.onBeforeRequest ? Promise.resolve(options.onBeforeRequest(req)) : Promise.resolve();
                return onBeforeRequestPromise.then((function() {
                    return req.send(body).then((function(res) {
                        var onAfterResponsePromise = "function" === typeof options.onAfterResponse ? Promise.resolve(options.onAfterResponse(req, res)) : Promise.resolve();
                        return onAfterResponsePromise.then((function() {
                            return res;
                        }));
                    }));
                }));
            }
            function isOnline() {
                var online = true;
                if ("undefined" !== typeof window && "navigator" in window && false === window.navigator.onLine) online = false;
                return online;
            }
            function shouldRetry(err, retryAttempt, options) {
                if (null == options.retryDelays || retryAttempt >= options.retryDelays.length || null == err.originalRequest) return false;
                if (options && "function" === typeof options.onShouldRetry) return options.onShouldRetry(err, retryAttempt, options);
                var status = err.originalResponse ? err.originalResponse.getStatus() : 0;
                return (!inStatusCategory(status, 400) || 409 === status || 423 === status) && isOnline();
            }
            function resolveUrl(origin, link) {
                return new (url_parse_default())(link, origin).toString();
            }
            function splitSizeIntoParts(totalSize, partCount, previousUrls) {
                var partSize = Math.floor(totalSize / partCount);
                var parts = [];
                for (var i = 0; i < partCount; i++) parts.push({
                    start: partSize * i,
                    end: partSize * (i + 1)
                });
                parts[partCount - 1].end = totalSize;
                if (previousUrls) parts.forEach((function(part, index) {
                    part.uploadUrl = previousUrls[index] || null;
                }));
                return parts;
            }
            BaseUpload.defaultOptions = defaultOptions;
            const upload = BaseUpload;
            function noopUrlStorage_classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function noopUrlStorage_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            function noopUrlStorage_createClass(Constructor, protoProps, staticProps) {
                if (protoProps) noopUrlStorage_defineProperties(Constructor.prototype, protoProps);
                if (staticProps) noopUrlStorage_defineProperties(Constructor, staticProps);
                return Constructor;
            }
            var NoopUrlStorage = function() {
                function NoopUrlStorage() {
                    noopUrlStorage_classCallCheck(this, NoopUrlStorage);
                }
                noopUrlStorage_createClass(NoopUrlStorage, [ {
                    key: "listAllUploads",
                    value: function listAllUploads() {
                        return Promise.resolve([]);
                    }
                }, {
                    key: "findUploadsByFingerprint",
                    value: function findUploadsByFingerprint(fingerprint) {
                        return Promise.resolve([]);
                    }
                }, {
                    key: "removeUpload",
                    value: function removeUpload(urlStorageKey) {
                        return Promise.resolve();
                    }
                }, {
                    key: "addUpload",
                    value: function addUpload(fingerprint, upload) {
                        return Promise.resolve(null);
                    }
                } ]);
                return NoopUrlStorage;
            }();
            function urlStorage_classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function urlStorage_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            function urlStorage_createClass(Constructor, protoProps, staticProps) {
                if (protoProps) urlStorage_defineProperties(Constructor.prototype, protoProps);
                if (staticProps) urlStorage_defineProperties(Constructor, staticProps);
                return Constructor;
            }
            var hasStorage = false;
            try {
                hasStorage = "localStorage" in window;
                var key = "tusSupport";
                localStorage.setItem(key, localStorage.getItem(key));
            } catch (e) {
                if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) hasStorage = false; else throw e;
            }
            var canStoreURLs = hasStorage;
            var WebStorageUrlStorage = function() {
                function WebStorageUrlStorage() {
                    urlStorage_classCallCheck(this, WebStorageUrlStorage);
                }
                urlStorage_createClass(WebStorageUrlStorage, [ {
                    key: "findAllUploads",
                    value: function findAllUploads() {
                        var results = this._findEntries("tus::");
                        return Promise.resolve(results);
                    }
                }, {
                    key: "findUploadsByFingerprint",
                    value: function findUploadsByFingerprint(fingerprint) {
                        var results = this._findEntries("tus::".concat(fingerprint, "::"));
                        return Promise.resolve(results);
                    }
                }, {
                    key: "removeUpload",
                    value: function removeUpload(urlStorageKey) {
                        localStorage.removeItem(urlStorageKey);
                        return Promise.resolve();
                    }
                }, {
                    key: "addUpload",
                    value: function addUpload(fingerprint, upload) {
                        var id = Math.round(1e12 * Math.random());
                        var key = "tus::".concat(fingerprint, "::").concat(id);
                        localStorage.setItem(key, JSON.stringify(upload));
                        return Promise.resolve(key);
                    }
                }, {
                    key: "_findEntries",
                    value: function _findEntries(prefix) {
                        var results = [];
                        for (var i = 0; i < localStorage.length; i++) {
                            var _key = localStorage.key(i);
                            if (0 !== _key.indexOf(prefix)) continue;
                            try {
                                var upload = JSON.parse(localStorage.getItem(_key));
                                upload.urlStorageKey = _key;
                                results.push(upload);
                            } catch (e) {}
                        }
                        return results;
                    }
                } ]);
                return WebStorageUrlStorage;
            }();
            function httpStack_classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function httpStack_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            function httpStack_createClass(Constructor, protoProps, staticProps) {
                if (protoProps) httpStack_defineProperties(Constructor.prototype, protoProps);
                if (staticProps) httpStack_defineProperties(Constructor, staticProps);
                return Constructor;
            }
            var XHRHttpStack = function() {
                function XHRHttpStack() {
                    httpStack_classCallCheck(this, XHRHttpStack);
                }
                httpStack_createClass(XHRHttpStack, [ {
                    key: "createRequest",
                    value: function createRequest(method, url) {
                        return new Request(method, url);
                    }
                }, {
                    key: "getName",
                    value: function getName() {
                        return "XHRHttpStack";
                    }
                } ]);
                return XHRHttpStack;
            }();
            var Request = function() {
                function Request(method, url) {
                    httpStack_classCallCheck(this, Request);
                    this._xhr = new XMLHttpRequest;
                    this._xhr.open(method, url, true);
                    this._method = method;
                    this._url = url;
                    this._headers = {};
                }
                httpStack_createClass(Request, [ {
                    key: "getMethod",
                    value: function getMethod() {
                        return this._method;
                    }
                }, {
                    key: "getURL",
                    value: function getURL() {
                        return this._url;
                    }
                }, {
                    key: "setHeader",
                    value: function setHeader(header, value) {
                        this._xhr.setRequestHeader(header, value);
                        this._headers[header] = value;
                    }
                }, {
                    key: "getHeader",
                    value: function getHeader(header) {
                        return this._headers[header];
                    }
                }, {
                    key: "setProgressHandler",
                    value: function setProgressHandler(progressHandler) {
                        if (!("upload" in this._xhr)) return;
                        this._xhr.upload.onprogress = function(e) {
                            if (!e.lengthComputable) return;
                            progressHandler(e.loaded);
                        };
                    }
                }, {
                    key: "send",
                    value: function send() {
                        var _this = this;
                        var body = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                        return new Promise((function(resolve, reject) {
                            _this._xhr.onload = function() {
                                resolve(new Response(_this._xhr));
                            };
                            _this._xhr.onerror = function(err) {
                                reject(err);
                            };
                            _this._xhr.send(body);
                        }));
                    }
                }, {
                    key: "abort",
                    value: function abort() {
                        this._xhr.abort();
                        return Promise.resolve();
                    }
                }, {
                    key: "getUnderlyingObject",
                    value: function getUnderlyingObject() {
                        return this._xhr;
                    }
                } ]);
                return Request;
            }();
            var Response = function() {
                function Response(xhr) {
                    httpStack_classCallCheck(this, Response);
                    this._xhr = xhr;
                }
                httpStack_createClass(Response, [ {
                    key: "getStatus",
                    value: function getStatus() {
                        return this._xhr.status;
                    }
                }, {
                    key: "getHeader",
                    value: function getHeader(header) {
                        return this._xhr.getResponseHeader(header);
                    }
                }, {
                    key: "getBody",
                    value: function getBody() {
                        return this._xhr.responseText;
                    }
                }, {
                    key: "getUnderlyingObject",
                    value: function getUnderlyingObject() {
                        return this._xhr;
                    }
                } ]);
                return Response;
            }();
            var isReactNative = function isReactNative() {
                return "undefined" !== typeof navigator && "string" === typeof navigator.product && "reactnative" === navigator.product.toLowerCase();
            };
            const browser_isReactNative = isReactNative;
            function uriToBlob(uri) {
                return new Promise((function(resolve, reject) {
                    var xhr = new XMLHttpRequest;
                    xhr.responseType = "blob";
                    xhr.onload = function() {
                        var blob = xhr.response;
                        resolve(blob);
                    };
                    xhr.onerror = function(err) {
                        reject(err);
                    };
                    xhr.open("GET", uri);
                    xhr.send();
                }));
            }
            var isCordova = function isCordova() {
                return "undefined" != typeof window && ("undefined" != typeof window.PhoneGap || "undefined" != typeof window.Cordova || "undefined" != typeof window.cordova);
            };
            const sources_isCordova = isCordova;
            function readAsByteArray(chunk) {
                return new Promise((function(resolve, reject) {
                    var reader = new FileReader;
                    reader.onload = function() {
                        var value = new Uint8Array(reader.result);
                        resolve({
                            value
                        });
                    };
                    reader.onerror = function(err) {
                        reject(err);
                    };
                    reader.readAsArrayBuffer(chunk);
                }));
            }
            function FileSource_classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function FileSource_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            function FileSource_createClass(Constructor, protoProps, staticProps) {
                if (protoProps) FileSource_defineProperties(Constructor.prototype, protoProps);
                if (staticProps) FileSource_defineProperties(Constructor, staticProps);
                return Constructor;
            }
            var FileSource = function() {
                function FileSource(file) {
                    FileSource_classCallCheck(this, FileSource);
                    this._file = file;
                    this.size = file.size;
                }
                FileSource_createClass(FileSource, [ {
                    key: "slice",
                    value: function slice(start, end) {
                        if (sources_isCordova()) return readAsByteArray(this._file.slice(start, end));
                        var value = this._file.slice(start, end);
                        return Promise.resolve({
                            value
                        });
                    }
                }, {
                    key: "close",
                    value: function close() {}
                } ]);
                return FileSource;
            }();
            function StreamSource_classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function StreamSource_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            function StreamSource_createClass(Constructor, protoProps, staticProps) {
                if (protoProps) StreamSource_defineProperties(Constructor.prototype, protoProps);
                if (staticProps) StreamSource_defineProperties(Constructor, staticProps);
                return Constructor;
            }
            function len(blobOrArray) {
                if (void 0 === blobOrArray) return 0;
                if (void 0 !== blobOrArray.size) return blobOrArray.size;
                return blobOrArray.length;
            }
            function concat(a, b) {
                if (a.concat) return a.concat(b);
                if (a instanceof Blob) return new Blob([ a, b ], {
                    type: a.type
                });
                if (a.set) {
                    var c = new a.constructor(a.length + b.length);
                    c.set(a);
                    c.set(b, a.length);
                    return c;
                }
                throw new Error("Unknown data type");
            }
            var StreamSource = function() {
                function StreamSource(reader, chunkSize) {
                    StreamSource_classCallCheck(this, StreamSource);
                    this._chunkSize = chunkSize;
                    this._buffer = void 0;
                    this._bufferOffset = 0;
                    this._reader = reader;
                    this._done = false;
                }
                StreamSource_createClass(StreamSource, [ {
                    key: "slice",
                    value: function slice(start, end) {
                        if (start < this._bufferOffset) return Promise.reject(new Error("Requested data is before the reader's current offset"));
                        return this._readUntilEnoughDataOrDone(start, end);
                    }
                }, {
                    key: "_readUntilEnoughDataOrDone",
                    value: function _readUntilEnoughDataOrDone(start, end) {
                        var _this = this;
                        var hasEnoughData = end <= this._bufferOffset + len(this._buffer);
                        if (this._done || hasEnoughData) {
                            var value = this._getDataFromBuffer(start, end);
                            var done = null == value ? this._done : false;
                            return Promise.resolve({
                                value,
                                done
                            });
                        }
                        return this._reader.read().then((function(_ref) {
                            var value = _ref.value, done = _ref.done;
                            if (done) _this._done = true; else if (void 0 === _this._buffer) _this._buffer = value; else _this._buffer = concat(_this._buffer, value);
                            return _this._readUntilEnoughDataOrDone(start, end);
                        }));
                    }
                }, {
                    key: "_getDataFromBuffer",
                    value: function _getDataFromBuffer(start, end) {
                        if (start > this._bufferOffset) {
                            this._buffer = this._buffer.slice(start - this._bufferOffset);
                            this._bufferOffset = start;
                        }
                        var hasAllDataBeenRead = 0 === len(this._buffer);
                        if (this._done && hasAllDataBeenRead) return null;
                        return this._buffer.slice(0, end - start);
                    }
                }, {
                    key: "close",
                    value: function close() {
                        if (this._reader.cancel) this._reader.cancel();
                    }
                } ]);
                return StreamSource;
            }();
            function fileReader_classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function fileReader_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            function fileReader_createClass(Constructor, protoProps, staticProps) {
                if (protoProps) fileReader_defineProperties(Constructor.prototype, protoProps);
                if (staticProps) fileReader_defineProperties(Constructor, staticProps);
                return Constructor;
            }
            var fileReader_FileReader = function() {
                function FileReader() {
                    fileReader_classCallCheck(this, FileReader);
                }
                fileReader_createClass(FileReader, [ {
                    key: "openFile",
                    value: function openFile(input, chunkSize) {
                        if (browser_isReactNative() && input && "undefined" !== typeof input.uri) return uriToBlob(input.uri).then((function(blob) {
                            return new FileSource(blob);
                        }))["catch"]((function(err) {
                            throw new Error("tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. ".concat(err));
                        }));
                        if ("function" === typeof input.slice && "undefined" !== typeof input.size) return Promise.resolve(new FileSource(input));
                        if ("function" === typeof input.read) {
                            chunkSize = +chunkSize;
                            if (!isFinite(chunkSize)) return Promise.reject(new Error("cannot create source for stream without a finite value for the `chunkSize` option"));
                            return Promise.resolve(new StreamSource(input, chunkSize));
                        }
                        return Promise.reject(new Error("source object may only be an instance of File, Blob, or Reader in this environment"));
                    }
                } ]);
                return FileReader;
            }();
            function fingerprint(file, options) {
                if (browser_isReactNative()) return Promise.resolve(reactNativeFingerprint(file, options));
                return Promise.resolve([ "tus-br", file.name, file.type, file.size, file.lastModified, options.endpoint ].join("-"));
            }
            function reactNativeFingerprint(file, options) {
                var exifHash = file.exif ? hashCode(JSON.stringify(file.exif)) : "noexif";
                return [ "tus-rn", file.name || "noname", file.size || "nosize", exifHash, options.endpoint ].join("/");
            }
            function hashCode(str) {
                var hash = 0;
                if (0 === str.length) return hash;
                for (var i = 0; i < str.length; i++) {
                    var _char = str.charCodeAt(i);
                    hash = (hash << 5) - hash + _char;
                    hash &= hash;
                }
                return hash;
            }
            function browser_typeof(obj) {
                "@babel/helpers - typeof";
                if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) browser_typeof = function _typeof(obj) {
                    return typeof obj;
                }; else browser_typeof = function _typeof(obj) {
                    return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
                return browser_typeof(obj);
            }
            function browser_classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function browser_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            function browser_createClass(Constructor, protoProps, staticProps) {
                if (protoProps) browser_defineProperties(Constructor.prototype, protoProps);
                if (staticProps) browser_defineProperties(Constructor, staticProps);
                return Constructor;
            }
            function browser_inherits(subClass, superClass) {
                if ("function" !== typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) browser_setPrototypeOf(subClass, superClass);
            }
            function browser_setPrototypeOf(o, p) {
                browser_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                    o.__proto__ = p;
                    return o;
                };
                return browser_setPrototypeOf(o, p);
            }
            function browser_createSuper(Derived) {
                var hasNativeReflectConstruct = browser_isNativeReflectConstruct();
                return function _createSuperInternal() {
                    var result, Super = browser_getPrototypeOf(Derived);
                    if (hasNativeReflectConstruct) {
                        var NewTarget = browser_getPrototypeOf(this).constructor;
                        result = Reflect.construct(Super, arguments, NewTarget);
                    } else result = Super.apply(this, arguments);
                    return browser_possibleConstructorReturn(this, result);
                };
            }
            function browser_possibleConstructorReturn(self, call) {
                if (call && ("object" === browser_typeof(call) || "function" === typeof call)) return call;
                return browser_assertThisInitialized(self);
            }
            function browser_assertThisInitialized(self) {
                if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return self;
            }
            function browser_isNativeReflectConstruct() {
                if ("undefined" === typeof Reflect || !Reflect.construct) return false;
                if (Reflect.construct.sham) return false;
                if ("function" === typeof Proxy) return true;
                try {
                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
                    return true;
                } catch (e) {
                    return false;
                }
            }
            function browser_getPrototypeOf(o) {
                browser_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                    return o.__proto__ || Object.getPrototypeOf(o);
                };
                return browser_getPrototypeOf(o);
            }
            function browser_ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);
                if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);
                    if (enumerableOnly) symbols = symbols.filter((function(sym) {
                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                    }));
                    keys.push.apply(keys, symbols);
                }
                return keys;
            }
            function browser_objectSpread(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = null != arguments[i] ? arguments[i] : {};
                    if (i % 2) browser_ownKeys(Object(source), true).forEach((function(key) {
                        browser_defineProperty(target, key, source[key]);
                    })); else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); else browser_ownKeys(Object(source)).forEach((function(key) {
                        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                    }));
                }
                return target;
            }
            function browser_defineProperty(obj, key, value) {
                if (key in obj) Object.defineProperty(obj, key, {
                    value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                }); else obj[key] = value;
                return obj;
            }
            var browser_defaultOptions = browser_objectSpread(browser_objectSpread({}, upload.defaultOptions), {}, {
                httpStack: new XHRHttpStack,
                fileReader: new fileReader_FileReader,
                urlStorage: canStoreURLs ? new WebStorageUrlStorage : new NoopUrlStorage,
                fingerprint
            });
            var Upload = function(_BaseUpload) {
                browser_inherits(Upload, _BaseUpload);
                var _super = browser_createSuper(Upload);
                function Upload() {
                    var file = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                    var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    browser_classCallCheck(this, Upload);
                    options = browser_objectSpread(browser_objectSpread({}, browser_defaultOptions), options);
                    return _super.call(this, file, options);
                }
                browser_createClass(Upload, null, [ {
                    key: "terminate",
                    value: function terminate(url, options, cb) {
                        options = browser_objectSpread(browser_objectSpread({}, browser_defaultOptions), options);
                        return upload.terminate(url, options, cb);
                    }
                } ]);
                return Upload;
            }(upload);
            var _window = window, browser_XMLHttpRequest = _window.XMLHttpRequest, browser_Blob = _window.Blob;
            var isSupported = browser_XMLHttpRequest && browser_Blob && "function" === typeof browser_Blob.prototype.slice;
        },
        4564: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var required = __webpack_require__(7418), qs = __webpack_require__(7129), controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, CRHTLF = /[\n\r\t]/g, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//, port = /:\d+$/, protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i, windowsDriveLetter = /^[a-zA-Z]:/;
            function trimLeft(str) {
                return (str ? str : "").toString().replace(controlOrWhitespace, "");
            }
            var rules = [ [ "#", "hash" ], [ "?", "query" ], function sanitize(address, url) {
                return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
            }, [ "/", "pathname" ], [ "@", "auth", 1 ], [ NaN, "host", void 0, 1, 1 ], [ /:(\d*)$/, "port", void 0, 1 ], [ NaN, "hostname", void 0, 1, 1 ] ];
            var ignore = {
                hash: 1,
                query: 1
            };
            function lolcation(loc) {
                var globalVar;
                if ("undefined" !== typeof window) globalVar = window; else if ("undefined" !== typeof __webpack_require__.g) globalVar = __webpack_require__.g; else if ("undefined" !== typeof self) globalVar = self; else globalVar = {};
                var location = globalVar.location || {};
                loc = loc || location;
                var key, finaldestination = {}, type = typeof loc;
                if ("blob:" === loc.protocol) finaldestination = new Url(unescape(loc.pathname), {}); else if ("string" === type) {
                    finaldestination = new Url(loc, {});
                    for (key in ignore) delete finaldestination[key];
                } else if ("object" === type) {
                    for (key in loc) {
                        if (key in ignore) continue;
                        finaldestination[key] = loc[key];
                    }
                    if (void 0 === finaldestination.slashes) finaldestination.slashes = slashes.test(loc.href);
                }
                return finaldestination;
            }
            function isSpecial(scheme) {
                return "file:" === scheme || "ftp:" === scheme || "http:" === scheme || "https:" === scheme || "ws:" === scheme || "wss:" === scheme;
            }
            function extractProtocol(address, location) {
                address = trimLeft(address);
                address = address.replace(CRHTLF, "");
                location = location || {};
                var match = protocolre.exec(address);
                var protocol = match[1] ? match[1].toLowerCase() : "";
                var forwardSlashes = !!match[2];
                var otherSlashes = !!match[3];
                var slashesCount = 0;
                var rest;
                if (forwardSlashes) if (otherSlashes) {
                    rest = match[2] + match[3] + match[4];
                    slashesCount = match[2].length + match[3].length;
                } else {
                    rest = match[2] + match[4];
                    slashesCount = match[2].length;
                } else if (otherSlashes) {
                    rest = match[3] + match[4];
                    slashesCount = match[3].length;
                } else rest = match[4];
                if ("file:" === protocol) {
                    if (slashesCount >= 2) rest = rest.slice(2);
                } else if (isSpecial(protocol)) rest = match[4]; else if (protocol) {
                    if (forwardSlashes) rest = rest.slice(2);
                } else if (slashesCount >= 2 && isSpecial(location.protocol)) rest = match[4];
                return {
                    protocol,
                    slashes: forwardSlashes || isSpecial(protocol),
                    slashesCount,
                    rest
                };
            }
            function resolve(relative, base) {
                if ("" === relative) return base;
                var path = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path.length, last = path[i - 1], unshift = false, up = 0;
                while (i--) if ("." === path[i]) path.splice(i, 1); else if (".." === path[i]) {
                    path.splice(i, 1);
                    up++;
                } else if (up) {
                    if (0 === i) unshift = true;
                    path.splice(i, 1);
                    up--;
                }
                if (unshift) path.unshift("");
                if ("." === last || ".." === last) path.push("");
                return path.join("/");
            }
            function Url(address, location, parser) {
                address = trimLeft(address);
                address = address.replace(CRHTLF, "");
                if (!(this instanceof Url)) return new Url(address, location, parser);
                var relative, extracted, parse, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;
                if ("object" !== type && "string" !== type) {
                    parser = location;
                    location = null;
                }
                if (parser && "function" !== typeof parser) parser = qs.parse;
                location = lolcation(location);
                extracted = extractProtocol(address || "", location);
                relative = !extracted.protocol && !extracted.slashes;
                url.slashes = extracted.slashes || relative && location.slashes;
                url.protocol = extracted.protocol || location.protocol || "";
                address = extracted.rest;
                if ("file:" === extracted.protocol && (2 !== extracted.slashesCount || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) instructions[3] = [ /(.*)/, "pathname" ];
                for (;i < instructions.length; i++) {
                    instruction = instructions[i];
                    if ("function" === typeof instruction) {
                        address = instruction(address, url);
                        continue;
                    }
                    parse = instruction[0];
                    key = instruction[1];
                    if (parse !== parse) url[key] = address; else if ("string" === typeof parse) {
                        index = "@" === parse ? address.lastIndexOf(parse) : address.indexOf(parse);
                        if (~index) if ("number" === typeof instruction[2]) {
                            url[key] = address.slice(0, index);
                            address = address.slice(index + instruction[2]);
                        } else {
                            url[key] = address.slice(index);
                            address = address.slice(0, index);
                        }
                    } else if (index = parse.exec(address)) {
                        url[key] = index[1];
                        address = address.slice(0, index.index);
                    }
                    url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
                    if (instruction[4]) url[key] = url[key].toLowerCase();
                }
                if (parser) url.query = parser(url.query);
                if (relative && location.slashes && "/" !== url.pathname.charAt(0) && ("" !== url.pathname || "" !== location.pathname)) url.pathname = resolve(url.pathname, location.pathname);
                if ("/" !== url.pathname.charAt(0) && isSpecial(url.protocol)) url.pathname = "/" + url.pathname;
                if (!required(url.port, url.protocol)) {
                    url.host = url.hostname;
                    url.port = "";
                }
                url.username = url.password = "";
                if (url.auth) {
                    index = url.auth.indexOf(":");
                    if (~index) {
                        url.username = url.auth.slice(0, index);
                        url.username = encodeURIComponent(decodeURIComponent(url.username));
                        url.password = url.auth.slice(index + 1);
                        url.password = encodeURIComponent(decodeURIComponent(url.password));
                    } else url.username = encodeURIComponent(decodeURIComponent(url.auth));
                    url.auth = url.password ? url.username + ":" + url.password : url.username;
                }
                url.origin = "file:" !== url.protocol && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
                url.href = url.toString();
            }
            function set(part, value, fn) {
                var url = this;
                switch (part) {
                  case "query":
                    if ("string" === typeof value && value.length) value = (fn || qs.parse)(value);
                    url[part] = value;
                    break;

                  case "port":
                    url[part] = value;
                    if (!required(value, url.protocol)) {
                        url.host = url.hostname;
                        url[part] = "";
                    } else if (value) url.host = url.hostname + ":" + value;
                    break;

                  case "hostname":
                    url[part] = value;
                    if (url.port) value += ":" + url.port;
                    url.host = value;
                    break;

                  case "host":
                    url[part] = value;
                    if (port.test(value)) {
                        value = value.split(":");
                        url.port = value.pop();
                        url.hostname = value.join(":");
                    } else {
                        url.hostname = value;
                        url.port = "";
                    }
                    break;

                  case "protocol":
                    url.protocol = value.toLowerCase();
                    url.slashes = !fn;
                    break;

                  case "pathname":
                  case "hash":
                    if (value) {
                        var char = "pathname" === part ? "/" : "#";
                        url[part] = value.charAt(0) !== char ? char + value : value;
                    } else url[part] = value;
                    break;

                  case "username":
                  case "password":
                    url[part] = encodeURIComponent(value);
                    break;

                  case "auth":
                    var index = value.indexOf(":");
                    if (~index) {
                        url.username = value.slice(0, index);
                        url.username = encodeURIComponent(decodeURIComponent(url.username));
                        url.password = value.slice(index + 1);
                        url.password = encodeURIComponent(decodeURIComponent(url.password));
                    } else url.username = encodeURIComponent(decodeURIComponent(value));
                }
                for (var i = 0; i < rules.length; i++) {
                    var ins = rules[i];
                    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
                }
                url.auth = url.password ? url.username + ":" + url.password : url.username;
                url.origin = "file:" !== url.protocol && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
                url.href = url.toString();
                return url;
            }
            function toString(stringify) {
                if (!stringify || "function" !== typeof stringify) stringify = qs.stringify;
                var query, url = this, host = url.host, protocol = url.protocol;
                if (protocol && ":" !== protocol.charAt(protocol.length - 1)) protocol += ":";
                var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
                if (url.username) {
                    result += url.username;
                    if (url.password) result += ":" + url.password;
                    result += "@";
                } else if (url.password) {
                    result += ":" + url.password;
                    result += "@";
                } else if ("file:" !== url.protocol && isSpecial(url.protocol) && !host && "/" !== url.pathname) result += "@";
                if (":" === host[host.length - 1] || port.test(url.hostname) && !url.port) host += ":";
                result += host + url.pathname;
                query = "object" === typeof url.query ? stringify(url.query) : url.query;
                if (query) result += "?" !== query.charAt(0) ? "?" + query : query;
                if (url.hash) result += url.hash;
                return result;
            }
            Url.prototype = {
                set,
                toString
            };
            Url.extractProtocol = extractProtocol;
            Url.location = lolcation;
            Url.trimLeft = trimLeft;
            Url.qs = qs;
            module.exports = Url;
        },
        2961: module => {
            let urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
            let customAlphabet = (alphabet, defaultSize = 21) => (size = defaultSize) => {
                let id = "";
                let i = size;
                while (i--) id += alphabet[Math.random() * alphabet.length | 0];
                return id;
            };
            let nanoid = (size = 21) => {
                let id = "";
                let i = size;
                while (i--) id += urlAlphabet[64 * Math.random() | 0];
                return id;
            };
            module.exports = {
                nanoid,
                customAlphabet
            };
        }
    };
    var __webpack_module_cache__ = {};
    function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (void 0 !== cachedModule) return cachedModule.exports;
        var module = __webpack_module_cache__[moduleId] = {
            exports: {}
        };
        __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        return module.exports;
    }
    (() => {
        __webpack_require__.n = module => {
            var getter = module && module.__esModule ? () => module["default"] : () => module;
            __webpack_require__.d(getter, {
                a: getter
            });
            return getter;
        };
    })();
    (() => {
        __webpack_require__.d = (exports, definition) => {
            for (var key in definition) if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) Object.defineProperty(exports, key, {
                enumerable: true,
                get: definition[key]
            });
        };
    })();
    (() => {
        __webpack_require__.g = function() {
            if ("object" === typeof globalThis) return globalThis;
            try {
                return this || new Function("return this")();
            } catch (e) {
                if ("object" === typeof window) return window;
            }
        }();
    })();
    (() => {
        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    })();
    (() => {
        __webpack_require__.r = exports => {
            if ("undefined" !== typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports, Symbol.toStringTag, {
                value: "Module"
            });
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
        };
    })();
    (() => {
        "use strict";
        var lib_namespaceObject = {};
        __webpack_require__.r(lib_namespaceObject);
        __webpack_require__.d(lib_namespaceObject, {
            afterMain: () => afterMain,
            afterRead: () => afterRead,
            afterWrite: () => afterWrite,
            applyStyles: () => modifiers_applyStyles,
            arrow: () => modifiers_arrow,
            auto: () => auto,
            basePlacements: () => basePlacements,
            beforeMain: () => beforeMain,
            beforeRead: () => beforeRead,
            beforeWrite: () => beforeWrite,
            bottom: () => bottom,
            clippingParents: () => clippingParents,
            computeStyles: () => modifiers_computeStyles,
            createPopper: () => popper_createPopper,
            createPopperBase: () => createPopper,
            createPopperLite: () => popper_lite_createPopper,
            detectOverflow: () => detectOverflow,
            end: () => end,
            eventListeners: () => eventListeners,
            flip: () => modifiers_flip,
            hide: () => modifiers_hide,
            left: () => left,
            main: () => main,
            modifierPhases: () => modifierPhases,
            offset: () => modifiers_offset,
            placements: () => enums_placements,
            popper: () => popper,
            popperGenerator: () => popperGenerator,
            popperOffsets: () => modifiers_popperOffsets,
            preventOverflow: () => modifiers_preventOverflow,
            read: () => read,
            reference: () => reference,
            right: () => right,
            start: () => start,
            top: () => enums_top,
            variationPlacements: () => variationPlacements,
            viewport: () => viewport,
            write: () => write
        });
        const modules_flsModules = {};
        function isWebp() {
            function testWebP(callback) {
                let webP = new Image;
                webP.onload = webP.onerror = function() {
                    callback(2 == webP.height);
                };
                webP.src = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA";
            }
            testWebP((function(support) {
                let className = true === support ? "webp" : "no-webp";
                document.documentElement.classList.add(className);
            }));
        }
        function functions_getHash() {
            if (location.hash) return location.hash.replace("#", "");
        }
        function setHash(hash) {
            hash = hash ? `#${hash}` : window.location.href.split("#")[0];
            history.pushState("", "", hash);
        }
        let _slideUp = (target, duration = 500, showmore = 0) => {
            if (!target.classList.contains("_slide")) {
                target.classList.add("_slide");
                target.style.transitionProperty = "height, margin, padding";
                target.style.transitionDuration = duration + "ms";
                target.style.height = `${target.offsetHeight}px`;
                target.offsetHeight;
                target.style.overflow = "hidden";
                target.style.height = showmore ? `${showmore}px` : `0px`;
                target.style.paddingTop = 0;
                target.style.paddingBottom = 0;
                target.style.marginTop = 0;
                target.style.marginBottom = 0;
                window.setTimeout((() => {
                    target.hidden = !showmore ? true : false;
                    !showmore ? target.style.removeProperty("height") : null;
                    target.style.removeProperty("padding-top");
                    target.style.removeProperty("padding-bottom");
                    target.style.removeProperty("margin-top");
                    target.style.removeProperty("margin-bottom");
                    !showmore ? target.style.removeProperty("overflow") : null;
                    target.style.removeProperty("transition-duration");
                    target.style.removeProperty("transition-property");
                    target.classList.remove("_slide");
                    document.dispatchEvent(new CustomEvent("slideUpDone", {
                        detail: {
                            target
                        }
                    }));
                }), duration);
            }
        };
        let _slideDown = (target, duration = 500, showmore = 0) => {
            if (!target.classList.contains("_slide")) {
                target.classList.add("_slide");
                target.hidden = target.hidden ? false : null;
                showmore ? target.style.removeProperty("height") : null;
                let height = target.offsetHeight;
                target.style.overflow = "hidden";
                target.style.height = showmore ? `${showmore}px` : `0px`;
                target.style.paddingTop = 0;
                target.style.paddingBottom = 0;
                target.style.marginTop = 0;
                target.style.marginBottom = 0;
                target.offsetHeight;
                target.style.transitionProperty = "height, margin, padding";
                target.style.transitionDuration = duration + "ms";
                target.style.height = height + "px";
                target.style.removeProperty("padding-top");
                target.style.removeProperty("padding-bottom");
                target.style.removeProperty("margin-top");
                target.style.removeProperty("margin-bottom");
                window.setTimeout((() => {
                    target.style.removeProperty("height");
                    target.style.removeProperty("overflow");
                    target.style.removeProperty("transition-duration");
                    target.style.removeProperty("transition-property");
                    target.classList.remove("_slide");
                    document.dispatchEvent(new CustomEvent("slideDownDone", {
                        detail: {
                            target
                        }
                    }));
                }), duration);
            }
        };
        let _slideToggle = (target, duration = 500) => {
            if (target.hidden) return _slideDown(target, duration); else return _slideUp(target, duration);
        };
        let bodyLockStatus = true;
        let bodyUnlock = (delay = 500) => {
            let body = document.querySelector("body");
            if (bodyLockStatus) {
                let lock_padding = document.querySelectorAll("[data-lp]");
                setTimeout((() => {
                    for (let index = 0; index < lock_padding.length; index++) {
                        const el = lock_padding[index];
                        el.style.paddingRight = "0px";
                    }
                    body.style.paddingRight = "0px";
                    document.documentElement.classList.remove("lock");
                }), delay);
                bodyLockStatus = false;
                setTimeout((function() {
                    bodyLockStatus = true;
                }), delay);
            }
        };
        let bodyLock = (delay = 500) => {
            let body = document.querySelector("body");
            if (bodyLockStatus) {
                let lock_padding = document.querySelectorAll("[data-lp]");
                for (let index = 0; index < lock_padding.length; index++) {
                    const el = lock_padding[index];
                    el.style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px";
                }
                body.style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px";
                document.documentElement.classList.add("lock");
                bodyLockStatus = false;
                setTimeout((function() {
                    bodyLockStatus = true;
                }), delay);
            }
        };
        function tabs() {
            const tabs = document.querySelectorAll("[data-tabs]");
            let tabsActiveHash = [];
            if (tabs.length > 0) {
                const hash = functions_getHash();
                if (hash && hash.startsWith("tab-")) tabsActiveHash = hash.replace("tab-", "").split("-");
                tabs.forEach(((tabsBlock, index) => {
                    tabsBlock.classList.add("_tab-init");
                    tabsBlock.setAttribute("data-tabs-index", index);
                    tabsBlock.addEventListener("click", setTabsAction);
                    initTabs(tabsBlock);
                }));
                let mdQueriesArray = dataMediaQueries(tabs, "tabs");
                if (mdQueriesArray && mdQueriesArray.length) mdQueriesArray.forEach((mdQueriesItem => {
                    mdQueriesItem.matchMedia.addEventListener("change", (function() {
                        setTitlePosition(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
                    }));
                    setTitlePosition(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
                }));
            }
            function setTitlePosition(tabsMediaArray, matchMedia) {
                tabsMediaArray.forEach((tabsMediaItem => {
                    tabsMediaItem = tabsMediaItem.item;
                    let tabsTitles = tabsMediaItem.querySelector("[data-tabs-titles]");
                    let tabsTitleItems = tabsMediaItem.querySelectorAll("[data-tabs-title]");
                    let tabsContent = tabsMediaItem.querySelector("[data-tabs-body]");
                    let tabsContentItems = tabsMediaItem.querySelectorAll("[data-tabs-item]");
                    tabsTitleItems = Array.from(tabsTitleItems).filter((item => item.closest("[data-tabs]") === tabsMediaItem));
                    tabsContentItems = Array.from(tabsContentItems).filter((item => item.closest("[data-tabs]") === tabsMediaItem));
                    tabsContentItems.forEach(((tabsContentItem, index) => {
                        if (matchMedia.matches) {
                            tabsContent.append(tabsTitleItems[index]);
                            tabsContent.append(tabsContentItem);
                            tabsMediaItem.classList.add("_tab-spoller");
                        } else {
                            tabsTitles.append(tabsTitleItems[index]);
                            tabsMediaItem.classList.remove("_tab-spoller");
                        }
                    }));
                }));
            }
            function initTabs(tabsBlock) {
                let tabsTitles = tabsBlock.querySelectorAll("[data-tabs-titles]>*");
                let tabsContent = tabsBlock.querySelectorAll("[data-tabs-body]>*");
                const tabsBlockIndex = tabsBlock.dataset.tabsIndex;
                const tabsActiveHashBlock = tabsActiveHash[0] == tabsBlockIndex;
                if (tabsActiveHashBlock) {
                    const tabsActiveTitle = tabsBlock.querySelector("[data-tabs-titles]>._tab-active");
                    tabsActiveTitle ? tabsActiveTitle.classList.remove("_tab-active") : null;
                }
                if (tabsContent.length) {
                    tabsContent = Array.from(tabsContent).filter((item => item.closest("[data-tabs]") === tabsBlock));
                    tabsTitles = Array.from(tabsTitles).filter((item => item.closest("[data-tabs]") === tabsBlock));
                    tabsContent.forEach(((tabsContentItem, index) => {
                        tabsTitles[index].setAttribute("data-tabs-title", "");
                        tabsContentItem.setAttribute("data-tabs-item", "");
                        if (tabsActiveHashBlock && index == tabsActiveHash[1]) tabsTitles[index].classList.add("_tab-active");
                        tabsContentItem.hidden = !tabsTitles[index].classList.contains("_tab-active");
                    }));
                }
            }
            function setTabsStatus(tabsBlock) {
                let tabsTitles = tabsBlock.querySelectorAll("[data-tabs-title]");
                let tabsContent = tabsBlock.querySelectorAll("[data-tabs-item]");
                const tabsBlockIndex = tabsBlock.dataset.tabsIndex;
                function isTabsAnamate(tabsBlock) {
                    if (tabsBlock.hasAttribute("data-tabs-animate")) return tabsBlock.dataset.tabsAnimate > 0 ? Number(tabsBlock.dataset.tabsAnimate) : 500;
                }
                const tabsBlockAnimate = isTabsAnamate(tabsBlock);
                if (tabsContent.length > 0) {
                    const isHash = tabsBlock.hasAttribute("data-tabs-hash");
                    tabsContent = Array.from(tabsContent).filter((item => item.closest("[data-tabs]") === tabsBlock));
                    tabsTitles = Array.from(tabsTitles).filter((item => item.closest("[data-tabs]") === tabsBlock));
                    tabsContent.forEach(((tabsContentItem, index) => {
                        if (tabsTitles[index].classList.contains("_tab-active")) {
                            if (tabsBlockAnimate) _slideDown(tabsContentItem, tabsBlockAnimate); else tabsContentItem.hidden = false;
                            if (isHash && !tabsContentItem.closest(".popup")) setHash(`tab-${tabsBlockIndex}-${index}`);
                        } else if (tabsBlockAnimate) _slideUp(tabsContentItem, tabsBlockAnimate); else tabsContentItem.hidden = true;
                    }));
                }
            }
            function setTabsAction(e) {
                const el = e.target;
                if (el.closest("[data-tabs-title]")) {
                    const tabTitle = el.closest("[data-tabs-title]");
                    const tabsBlock = tabTitle.closest("[data-tabs]");
                    if (!tabTitle.classList.contains("_tab-active") && !tabsBlock.querySelector("._slide")) {
                        let tabActiveTitle = tabsBlock.querySelectorAll("[data-tabs-title]._tab-active");
                        tabActiveTitle.length ? tabActiveTitle = Array.from(tabActiveTitle).filter((item => item.closest("[data-tabs]") === tabsBlock)) : null;
                        tabActiveTitle.length ? tabActiveTitle[0].classList.remove("_tab-active") : null;
                        tabTitle.classList.add("_tab-active");
                        setTabsStatus(tabsBlock);
                    }
                    e.preventDefault();
                }
            }
        }
        function functions_FLS(message) {
            setTimeout((() => {
                if (window.FLS) console.log(message);
            }), 0);
        }
        function uniqArray(array) {
            return array.filter((function(item, index, self) {
                return self.indexOf(item) === index;
            }));
        }
        function dataMediaQueries(array, dataSetValue) {
            const media = Array.from(array).filter((function(item, index, self) {
                if (item.dataset[dataSetValue]) return item.dataset[dataSetValue].split(",")[0];
            }));
            if (media.length) {
                const breakpointsArray = [];
                media.forEach((item => {
                    const params = item.dataset[dataSetValue];
                    const breakpoint = {};
                    const paramsArray = params.split(",");
                    breakpoint.value = paramsArray[0];
                    breakpoint.type = paramsArray[1] ? paramsArray[1].trim() : "max";
                    breakpoint.item = item;
                    breakpointsArray.push(breakpoint);
                }));
                let mdQueries = breakpointsArray.map((function(item) {
                    return "(" + item.type + "-width: " + item.value + "px)," + item.value + "," + item.type;
                }));
                mdQueries = uniqArray(mdQueries);
                const mdQueriesArray = [];
                if (mdQueries.length) {
                    mdQueries.forEach((breakpoint => {
                        const paramsArray = breakpoint.split(",");
                        const mediaBreakpoint = paramsArray[1];
                        const mediaType = paramsArray[2];
                        const matchMedia = window.matchMedia(paramsArray[0]);
                        const itemsArray = breakpointsArray.filter((function(item) {
                            if (item.value === mediaBreakpoint && item.type === mediaType) return true;
                        }));
                        mdQueriesArray.push({
                            itemsArray,
                            matchMedia
                        });
                    }));
                    return mdQueriesArray;
                }
            }
        }
        class Popup {
            constructor(options) {
                let config = {
                    logging: true,
                    init: true,
                    attributeOpenButton: "data-popup",
                    attributeCloseButton: "data-close",
                    fixElementSelector: "[data-lp]",
                    youtubeAttribute: "data-popup-youtube",
                    youtubePlaceAttribute: "data-popup-youtube-place",
                    setAutoplayYoutube: true,
                    classes: {
                        popup: "popup",
                        popupContent: "popup__content",
                        popupActive: "popup_show",
                        bodyActive: "popup-show"
                    },
                    focusCatch: true,
                    closeEsc: true,
                    bodyLock: true,
                    hashSettings: {
                        location: true,
                        goHash: true
                    },
                    on: {
                        beforeOpen: function() {},
                        afterOpen: function() {},
                        beforeClose: function() {},
                        afterClose: function() {}
                    }
                };
                this.youTubeCode;
                this.isOpen = false;
                this.targetOpen = {
                    selector: false,
                    element: false
                };
                this.previousOpen = {
                    selector: false,
                    element: false
                };
                this.lastClosed = {
                    selector: false,
                    element: false
                };
                this._dataValue = false;
                this.hash = false;
                this._reopen = false;
                this._selectorOpen = false;
                this.lastFocusEl = false;
                this._focusEl = [ "a[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "button:not([disabled]):not([aria-hidden])", "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "area[href]", "iframe", "object", "embed", "[contenteditable]", '[tabindex]:not([tabindex^="-"])' ];
                this.options = {
                    ...config,
                    ...options,
                    classes: {
                        ...config.classes,
                        ...options?.classes
                    },
                    hashSettings: {
                        ...config.hashSettings,
                        ...options?.hashSettings
                    },
                    on: {
                        ...config.on,
                        ...options?.on
                    }
                };
                this.bodyLock = false;
                this.options.init ? this.initPopups() : null;
            }
            initPopups() {
                this.popupLogging(`Проснулся`);
                this.eventsPopup();
            }
            eventsPopup() {
                document.addEventListener("click", function(e) {
                    const buttonOpen = e.target.closest(`[${this.options.attributeOpenButton}]`);
                    if (buttonOpen) {
                        e.preventDefault();
                        this._dataValue = buttonOpen.getAttribute(this.options.attributeOpenButton) ? buttonOpen.getAttribute(this.options.attributeOpenButton) : "error";
                        this.youTubeCode = buttonOpen.getAttribute(this.options.youtubeAttribute) ? buttonOpen.getAttribute(this.options.youtubeAttribute) : null;
                        if ("error" !== this._dataValue) {
                            if (!this.isOpen) this.lastFocusEl = buttonOpen;
                            this.targetOpen.selector = `${this._dataValue}`;
                            this._selectorOpen = true;
                            this.open();
                            return;
                        } else this.popupLogging(`Ой ой, не заполнен атрибут у ${buttonOpen.classList}`);
                        return;
                    }
                    const buttonClose = e.target.closest(`[${this.options.attributeCloseButton}]`);
                    if (buttonClose || !e.target.closest(`.${this.options.classes.popupContent}`) && this.isOpen) {
                        e.preventDefault();
                        this.close();
                        return;
                    }
                }.bind(this));
                document.addEventListener("keydown", function(e) {
                    if (this.options.closeEsc && 27 == e.which && "Escape" === e.code && this.isOpen) {
                        e.preventDefault();
                        this.close();
                        return;
                    }
                    if (this.options.focusCatch && 9 == e.which && this.isOpen) {
                        this._focusCatch(e);
                        return;
                    }
                }.bind(this));
                if (this.options.hashSettings.goHash) {
                    window.addEventListener("hashchange", function() {
                        if (window.location.hash) this._openToHash(); else this.close(this.targetOpen.selector);
                    }.bind(this));
                    window.addEventListener("load", function() {
                        if (window.location.hash) this._openToHash();
                    }.bind(this));
                }
            }
            open(selectorValue) {
                if (bodyLockStatus) {
                    this.bodyLock = document.documentElement.classList.contains("lock") ? true : false;
                    if (selectorValue && "string" === typeof selectorValue && "" !== selectorValue.trim()) {
                        this.targetOpen.selector = selectorValue;
                        this._selectorOpen = true;
                    }
                    if (this.isOpen) {
                        this._reopen = true;
                        this.close();
                    }
                    if (!this._selectorOpen) this.targetOpen.selector = this.lastClosed.selector;
                    if (!this._reopen) this.previousActiveElement = document.activeElement;
                    this.targetOpen.element = document.querySelector(this.targetOpen.selector);
                    if (this.targetOpen.element) {
                        if (this.youTubeCode) {
                            const codeVideo = this.youTubeCode;
                            const urlVideo = `https://www.youtube.com/embed/${codeVideo}?rel=0&showinfo=0&autoplay=1`;
                            const iframe = document.createElement("iframe");
                            iframe.setAttribute("allowfullscreen", "");
                            const autoplay = this.options.setAutoplayYoutube ? "autoplay;" : "";
                            iframe.setAttribute("allow", `${autoplay}; encrypted-media`);
                            iframe.setAttribute("src", urlVideo);
                            if (!this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) {
                                this.targetOpen.element.querySelector(".popup__text").setAttribute(`${this.options.youtubePlaceAttribute}`, "");
                            }
                            this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).appendChild(iframe);
                        }
                        if (this.options.hashSettings.location) {
                            this._getHash();
                            this._setHash();
                        }
                        this.options.on.beforeOpen(this);
                        document.dispatchEvent(new CustomEvent("beforePopupOpen", {
                            detail: {
                                popup: this
                            }
                        }));
                        this.targetOpen.element.classList.add(this.options.classes.popupActive);
                        document.documentElement.classList.add(this.options.classes.bodyActive);
                        if (!this._reopen) !this.bodyLock ? bodyLock() : null; else this._reopen = false;
                        this.targetOpen.element.setAttribute("aria-hidden", "false");
                        this.previousOpen.selector = this.targetOpen.selector;
                        this.previousOpen.element = this.targetOpen.element;
                        this._selectorOpen = false;
                        this.isOpen = true;
                        setTimeout((() => {
                            this._focusTrap();
                        }), 50);
                        this.options.on.afterOpen(this);
                        document.dispatchEvent(new CustomEvent("afterPopupOpen", {
                            detail: {
                                popup: this
                            }
                        }));
                        this.popupLogging(`Открыл попап`);
                    } else this.popupLogging(`Ой ой, такого попапа нет.Проверьте корректность ввода. `);
                }
            }
            close(selectorValue) {
                if (selectorValue && "string" === typeof selectorValue && "" !== selectorValue.trim()) this.previousOpen.selector = selectorValue;
                if (!this.isOpen || !bodyLockStatus) return;
                this.options.on.beforeClose(this);
                document.dispatchEvent(new CustomEvent("beforePopupClose", {
                    detail: {
                        popup: this
                    }
                }));
                if (this.youTubeCode) if (this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).innerHTML = "";
                this.previousOpen.element.classList.remove(this.options.classes.popupActive);
                this.previousOpen.element.setAttribute("aria-hidden", "true");
                if (!this._reopen) {
                    document.documentElement.classList.remove(this.options.classes.bodyActive);
                    !this.bodyLock ? bodyUnlock() : null;
                    this.isOpen = false;
                }
                this._removeHash();
                if (this._selectorOpen) {
                    this.lastClosed.selector = this.previousOpen.selector;
                    this.lastClosed.element = this.previousOpen.element;
                }
                this.options.on.afterClose(this);
                document.dispatchEvent(new CustomEvent("afterPopupClose", {
                    detail: {
                        popup: this
                    }
                }));
                setTimeout((() => {
                    this._focusTrap();
                }), 50);
                this.popupLogging(`Закрыл попап`);
            }
            _getHash() {
                if (this.options.hashSettings.location) this.hash = this.targetOpen.selector.includes("#") ? this.targetOpen.selector : this.targetOpen.selector.replace(".", "#");
            }
            _openToHash() {
                let classInHash = document.querySelector(`.${window.location.hash.replace("#", "")}`) ? `.${window.location.hash.replace("#", "")}` : document.querySelector(`${window.location.hash}`) ? `${window.location.hash}` : null;
                const buttons = document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash}"]`) ? document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash}"]`) : document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash.replace(".", "#")}"]`);
                if (buttons && classInHash) this.open(classInHash);
            }
            _setHash() {
                history.pushState("", "", this.hash);
            }
            _removeHash() {
                history.pushState("", "", window.location.href.split("#")[0]);
            }
            _focusCatch(e) {
                const focusable = this.targetOpen.element.querySelectorAll(this._focusEl);
                const focusArray = Array.prototype.slice.call(focusable);
                const focusedIndex = focusArray.indexOf(document.activeElement);
                if (e.shiftKey && 0 === focusedIndex) {
                    focusArray[focusArray.length - 1].focus();
                    e.preventDefault();
                }
                if (!e.shiftKey && focusedIndex === focusArray.length - 1) {
                    focusArray[0].focus();
                    e.preventDefault();
                }
            }
            _focusTrap() {
                const focusable = this.previousOpen.element.querySelectorAll(this._focusEl);
                if (!this.isOpen && this.lastFocusEl) this.lastFocusEl.focus(); else focusable[0].focus();
            }
            popupLogging(message) {
                this.options.logging ? functions_FLS(`[Попапос]: ${message}`) : null;
            }
        }
        modules_flsModules.popup = new Popup({});
        let formValidate = {
            getErrors(form) {
                let error = 0;
                let formRequiredItems = form.querySelectorAll("*[data-required]");
                if (formRequiredItems.length) formRequiredItems.forEach((formRequiredItem => {
                    if ((null !== formRequiredItem.offsetParent || "SELECT" === formRequiredItem.tagName) && !formRequiredItem.disabled) error += this.validateInput(formRequiredItem);
                }));
                return error;
            },
            validateInput(formRequiredItem) {
                let error = 0;
                if ("email" === formRequiredItem.dataset.required) {
                    formRequiredItem.value = formRequiredItem.value.replace(" ", "");
                    if (this.emailTest(formRequiredItem)) {
                        this.addError(formRequiredItem);
                        error++;
                    } else this.removeError(formRequiredItem);
                } else if ("checkbox" === formRequiredItem.type && !formRequiredItem.checked) {
                    this.addError(formRequiredItem);
                    error++;
                } else if (!formRequiredItem.value) {
                    this.addError(formRequiredItem);
                    error++;
                } else this.removeError(formRequiredItem);
                return error;
            },
            addError(formRequiredItem) {
                formRequiredItem.classList.add("_form-error");
                formRequiredItem.parentElement.classList.add("_form-error");
                let inputError = formRequiredItem.parentElement.querySelector(".form__error");
                if (inputError) formRequiredItem.parentElement.removeChild(inputError);
                if (formRequiredItem.dataset.error) formRequiredItem.parentElement.insertAdjacentHTML("beforeend", `<div class="form__error">${formRequiredItem.dataset.error}</div>`);
            },
            removeError(formRequiredItem) {
                formRequiredItem.classList.remove("_form-error");
                formRequiredItem.parentElement.classList.remove("_form-error");
                if (formRequiredItem.parentElement.querySelector(".form__error")) formRequiredItem.parentElement.removeChild(formRequiredItem.parentElement.querySelector(".form__error"));
            },
            formClean(form) {
                form.reset();
                setTimeout((() => {
                    let inputs = form.querySelectorAll("input,textarea");
                    for (let index = 0; index < inputs.length; index++) {
                        const el = inputs[index];
                        el.parentElement.classList.remove("_form-focus");
                        el.classList.remove("_form-focus");
                        formValidate.removeError(el);
                    }
                    let checkboxes = form.querySelectorAll(".checkbox__input");
                    if (checkboxes.length > 0) for (let index = 0; index < checkboxes.length; index++) {
                        const checkbox = checkboxes[index];
                        checkbox.checked = false;
                    }
                    if (modules_flsModules.select) {
                        let selects = form.querySelectorAll(".select");
                        if (selects.length) for (let index = 0; index < selects.length; index++) {
                            const select = selects[index].querySelector("select");
                            modules_flsModules.select.selectBuild(select);
                        }
                    }
                }), 0);
            },
            emailTest(formRequiredItem) {
                return !/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,8})+$/.test(formRequiredItem.value);
            }
        };
        function formQuantity() {
            document.addEventListener("click", (function(e) {
                let targetElement = e.target;
                if (targetElement.closest(".quantity__button")) {
                    let value = parseInt(targetElement.closest(".quantity").querySelector("input").value);
                    if (targetElement.classList.contains("quantity__button_plus")) value++; else {
                        --value;
                        if (value < 1) value = 1;
                    }
                    targetElement.closest(".quantity").querySelector("input").value = value;
                }
            }));
        }
        class SelectConstructor {
            constructor(props, data = null) {
                let defaultConfig = {
                    init: true,
                    logging: true
                };
                this.config = Object.assign(defaultConfig, props);
                this.selectClasses = {
                    classSelect: "select",
                    classSelectBody: "select__body",
                    classSelectTitle: "select__title",
                    classSelectValue: "select__value",
                    classSelectLabel: "select__label",
                    classSelectInput: "select__input",
                    classSelectText: "select__text",
                    classSelectLink: "select__link",
                    classSelectOptions: "select__options",
                    classSelectOptionsScroll: "select__scroll",
                    classSelectOption: "select__option",
                    classSelectContent: "select__content",
                    classSelectRow: "select__row",
                    classSelectData: "select__asset",
                    classSelectDisabled: "_select-disabled",
                    classSelectTag: "_select-tag",
                    classSelectOpen: "_select-open",
                    classSelectActive: "_select-active",
                    classSelectFocus: "_select-focus",
                    classSelectMultiple: "_select-multiple",
                    classSelectCheckBox: "_select-checkbox",
                    classSelectOptionSelected: "_select-selected",
                    classSelectPseudoLabel: "_select-pseudo-label"
                };
                this._this = this;
                if (this.config.init) {
                    const selectItems = data ? document.querySelectorAll(data) : document.querySelectorAll("select");
                    if (selectItems.length) {
                        this.selectsInit(selectItems);
                        this.setLogging(`Проснулся, построил селектов: (${selectItems.length})`);
                    } else this.setLogging("Сплю, нет ни одного select zzZZZzZZz");
                }
            }
            getSelectClass(className) {
                return `.${className}`;
            }
            getSelectElement(selectItem, className) {
                return {
                    originalSelect: selectItem.querySelector("select"),
                    selectElement: selectItem.querySelector(this.getSelectClass(className))
                };
            }
            selectsInit(selectItems) {
                selectItems.forEach(((originalSelect, index) => {
                    this.selectInit(originalSelect, index + 1);
                }));
                document.addEventListener("click", function(e) {
                    this.selectsActions(e);
                }.bind(this));
                document.addEventListener("keydown", function(e) {
                    this.selectsActions(e);
                }.bind(this));
                document.addEventListener("focusin", function(e) {
                    this.selectsActions(e);
                }.bind(this));
                document.addEventListener("focusout", function(e) {
                    this.selectsActions(e);
                }.bind(this));
            }
            selectInit(originalSelect, index) {
                const _this = this;
                let selectItem = document.createElement("div");
                selectItem.classList.add(this.selectClasses.classSelect);
                originalSelect.parentNode.insertBefore(selectItem, originalSelect);
                selectItem.appendChild(originalSelect);
                originalSelect.hidden = true;
                index ? originalSelect.dataset.id = index : null;
                if (this.getSelectPlaceholder(originalSelect)) {
                    originalSelect.dataset.placeholder = this.getSelectPlaceholder(originalSelect).value;
                    if (this.getSelectPlaceholder(originalSelect).label.show) {
                        const selectItemTitle = this.getSelectElement(selectItem, this.selectClasses.classSelectTitle).selectElement;
                        selectItemTitle.insertAdjacentHTML("afterbegin", `<span class="${this.selectClasses.classSelectLabel}">${this.getSelectPlaceholder(originalSelect).label.text ? this.getSelectPlaceholder(originalSelect).label.text : this.getSelectPlaceholder(originalSelect).value}</span>`);
                    }
                }
                selectItem.insertAdjacentHTML("beforeend", `<div class="${this.selectClasses.classSelectBody}"><div hidden class="${this.selectClasses.classSelectOptions}"></div></div>`);
                this.selectBuild(originalSelect);
                originalSelect.dataset.speed = originalSelect.dataset.speed ? originalSelect.dataset.speed : "150";
                originalSelect.addEventListener("change", (function(e) {
                    _this.selectChange(e);
                }));
            }
            selectBuild(originalSelect) {
                const selectItem = originalSelect.parentElement;
                selectItem.dataset.id = originalSelect.dataset.id;
                selectItem.classList.add(originalSelect.getAttribute("class") ? `select_${originalSelect.getAttribute("class")}` : "");
                originalSelect.multiple ? selectItem.classList.add(this.selectClasses.classSelectMultiple) : selectItem.classList.remove(this.selectClasses.classSelectMultiple);
                originalSelect.hasAttribute("data-checkbox") && originalSelect.multiple ? selectItem.classList.add(this.selectClasses.classSelectCheckBox) : selectItem.classList.remove(this.selectClasses.classSelectCheckBox);
                this.setSelectTitleValue(selectItem, originalSelect);
                this.setOptions(selectItem, originalSelect);
                originalSelect.hasAttribute("data-search") ? this.searchActions(selectItem) : null;
                originalSelect.hasAttribute("data-open") ? this.selectAction(selectItem) : null;
                this.selectDisabled(selectItem, originalSelect);
            }
            selectsActions(e) {
                const targetElement = e.target;
                const targetType = e.type;
                if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelect)) || targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTag))) {
                    const selectItem = targetElement.closest(".select") ? targetElement.closest(".select") : document.querySelector(`.${this.selectClasses.classSelect}[data-id="${targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTag)).dataset.selectId}"]`);
                    const originalSelect = this.getSelectElement(selectItem).originalSelect;
                    if ("click" === targetType) {
                        if (!originalSelect.disabled) if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTag))) {
                            const targetTag = targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTag));
                            const optionItem = document.querySelector(`.${this.selectClasses.classSelect}[data-id="${targetTag.dataset.selectId}"] .select__option[data-value="${targetTag.dataset.value}"]`);
                            this.optionAction(selectItem, originalSelect, optionItem);
                        } else if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelectTitle))) this.selectAction(selectItem); else if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelectOption))) {
                            const optionItem = targetElement.closest(this.getSelectClass(this.selectClasses.classSelectOption));
                            this.optionAction(selectItem, originalSelect, optionItem);
                        }
                    } else if ("focusin" === targetType || "focusout" === targetType) {
                        if (targetElement.closest(this.getSelectClass(this.selectClasses.classSelect))) "focusin" === targetType ? selectItem.classList.add(this.selectClasses.classSelectFocus) : selectItem.classList.remove(this.selectClasses.classSelectFocus);
                    } else if ("keydown" === targetType && "Escape" === e.code) this.selectsСlose();
                } else this.selectsСlose();
            }
            selectsСlose(selectOneGroup) {
                const selectsGroup = selectOneGroup ? selectOneGroup : document;
                const selectActiveItems = selectsGroup.querySelectorAll(`${this.getSelectClass(this.selectClasses.classSelect)}${this.getSelectClass(this.selectClasses.classSelectOpen)}`);
                if (selectActiveItems.length) selectActiveItems.forEach((selectActiveItem => {
                    this.selectСlose(selectActiveItem);
                }));
            }
            selectСlose(selectItem) {
                const originalSelect = this.getSelectElement(selectItem).originalSelect;
                const selectOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                if (!selectOptions.classList.contains("_slide")) {
                    selectItem.classList.remove(this.selectClasses.classSelectOpen);
                    _slideUp(selectOptions, originalSelect.dataset.speed);
                }
            }
            selectAction(selectItem) {
                const originalSelect = this.getSelectElement(selectItem).originalSelect;
                const selectOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                if (originalSelect.closest("[data-one-select]")) {
                    const selectOneGroup = originalSelect.closest("[data-one-select]");
                    this.selectsСlose(selectOneGroup);
                }
                if (!selectOptions.classList.contains("_slide")) {
                    selectItem.classList.toggle(this.selectClasses.classSelectOpen);
                    _slideToggle(selectOptions, originalSelect.dataset.speed);
                }
            }
            setSelectTitleValue(selectItem, originalSelect) {
                const selectItemBody = this.getSelectElement(selectItem, this.selectClasses.classSelectBody).selectElement;
                const selectItemTitle = this.getSelectElement(selectItem, this.selectClasses.classSelectTitle).selectElement;
                if (selectItemTitle) selectItemTitle.remove();
                selectItemBody.insertAdjacentHTML("afterbegin", this.getSelectTitleValue(selectItem, originalSelect));
            }
            getSelectTitleValue(selectItem, originalSelect) {
                let selectTitleValue = this.getSelectedOptionsData(originalSelect, 2).html;
                if (originalSelect.multiple && originalSelect.hasAttribute("data-tags")) {
                    selectTitleValue = this.getSelectedOptionsData(originalSelect).elements.map((option => `<span role="button" data-select-id="${selectItem.dataset.id}" data-value="${option.value}" class="_select-tag">${this.getSelectElementContent(option)}</span>`)).join("");
                    if (originalSelect.dataset.tags && document.querySelector(originalSelect.dataset.tags)) {
                        document.querySelector(originalSelect.dataset.tags).innerHTML = selectTitleValue;
                        if (originalSelect.hasAttribute("data-search")) selectTitleValue = false;
                    }
                }
                selectTitleValue = selectTitleValue.length ? selectTitleValue : originalSelect.dataset.placeholder ? originalSelect.dataset.placeholder : "";
                let pseudoAttribute = "";
                let pseudoAttributeClass = "";
                if (originalSelect.hasAttribute("data-pseudo-label")) {
                    pseudoAttribute = originalSelect.dataset.pseudoLabel ? ` data-pseudo-label="${originalSelect.dataset.pseudoLabel}"` : ` data-pseudo-label="Заполните атрибут"`;
                    pseudoAttributeClass = ` ${this.selectClasses.classSelectPseudoLabel}`;
                }
                this.getSelectedOptionsData(originalSelect).values.length ? selectItem.classList.add(this.selectClasses.classSelectActive) : selectItem.classList.remove(this.selectClasses.classSelectActive);
                if (originalSelect.hasAttribute("data-search")) return `<div class="${this.selectClasses.classSelectTitle}"><span${pseudoAttribute} class="${this.selectClasses.classSelectValue}"><input autocomplete="off" type="text" placeholder="${selectTitleValue}" data-placeholder="${selectTitleValue}" class="${this.selectClasses.classSelectInput}"></span></div>`; else {
                    const customClass = this.getSelectedOptionsData(originalSelect).elements.length && this.getSelectedOptionsData(originalSelect).elements[0].dataset.class ? ` ${this.getSelectedOptionsData(originalSelect).elements[0].dataset.class}` : "";
                    return `<button type="button" class="${this.selectClasses.classSelectTitle}"><span${pseudoAttribute} class="${this.selectClasses.classSelectValue}${pseudoAttributeClass}"><span class="${this.selectClasses.classSelectContent}${customClass}">${selectTitleValue}</span></span></button>`;
                }
            }
            getSelectElementContent(selectOption) {
                const selectOptionData = selectOption.dataset.asset ? `${selectOption.dataset.asset}` : "";
                const selectOptionDataHTML = selectOptionData.indexOf("img") >= 0 ? `<img src="${selectOptionData}" alt="">` : selectOptionData;
                let selectOptionContentHTML = ``;
                selectOptionContentHTML += selectOptionData ? `<span class="${this.selectClasses.classSelectRow}">` : "";
                selectOptionContentHTML += selectOptionData ? `<span class="${this.selectClasses.classSelectData}">` : "";
                selectOptionContentHTML += selectOptionData ? selectOptionDataHTML : "";
                selectOptionContentHTML += selectOptionData ? `</span>` : "";
                selectOptionContentHTML += selectOptionData ? `<span class="${this.selectClasses.classSelectText}">` : "";
                selectOptionContentHTML += selectOption.textContent;
                selectOptionContentHTML += selectOptionData ? `</span>` : "";
                selectOptionContentHTML += selectOptionData ? `</span>` : "";
                return selectOptionContentHTML;
            }
            getSelectPlaceholder(originalSelect) {
                const selectPlaceholder = Array.from(originalSelect.options).find((option => !option.value));
                if (selectPlaceholder) return {
                    value: selectPlaceholder.textContent,
                    show: selectPlaceholder.hasAttribute("data-show"),
                    label: {
                        show: selectPlaceholder.hasAttribute("data-label"),
                        text: selectPlaceholder.dataset.label
                    }
                };
            }
            getSelectedOptionsData(originalSelect, type) {
                let selectedOptions = [];
                if (originalSelect.multiple) selectedOptions = Array.from(originalSelect.options).filter((option => option.value)).filter((option => option.selected)); else selectedOptions.push(originalSelect.options[originalSelect.selectedIndex]);
                return {
                    elements: selectedOptions.map((option => option)),
                    values: selectedOptions.filter((option => option.value)).map((option => option.value)),
                    html: selectedOptions.map((option => this.getSelectElementContent(option)))
                };
            }
            getOptions(originalSelect) {
                let selectOptionsScroll = originalSelect.hasAttribute("data-scroll") ? `data-simplebar` : "";
                let selectOptionsScrollHeight = originalSelect.dataset.scroll ? `style="max-height:${originalSelect.dataset.scroll}px"` : "";
                let selectOptions = Array.from(originalSelect.options);
                if (selectOptions.length > 0) {
                    let selectOptionsHTML = ``;
                    if (this.getSelectPlaceholder(originalSelect) && !this.getSelectPlaceholder(originalSelect).show || originalSelect.multiple) selectOptions = selectOptions.filter((option => option.value));
                    selectOptionsHTML += selectOptionsScroll ? `<div ${selectOptionsScroll} ${selectOptionsScrollHeight} class="${this.selectClasses.classSelectOptionsScroll}">` : "";
                    selectOptions.forEach((selectOption => {
                        selectOptionsHTML += this.getOption(selectOption, originalSelect);
                    }));
                    selectOptionsHTML += selectOptionsScroll ? `</div>` : "";
                    return selectOptionsHTML;
                }
            }
            getOption(selectOption, originalSelect) {
                const selectOptionSelected = selectOption.selected && originalSelect.multiple ? ` ${this.selectClasses.classSelectOptionSelected}` : "";
                const selectOptionHide = selectOption.selected && !originalSelect.hasAttribute("data-show-selected") && !originalSelect.multiple ? `hidden` : ``;
                const selectOptionClass = selectOption.dataset.class ? ` ${selectOption.dataset.class}` : "";
                const selectOptionLink = selectOption.dataset.href ? selectOption.dataset.href : false;
                const selectOptionLinkTarget = selectOption.hasAttribute("data-href-blank") ? `target="_blank"` : "";
                let selectOptionHTML = ``;
                selectOptionHTML += selectOptionLink ? `<a ${selectOptionLinkTarget} ${selectOptionHide} href="${selectOptionLink}" data-value="${selectOption.value}" class="${this.selectClasses.classSelectOption}${selectOptionClass}${selectOptionSelected}">` : `<button ${selectOptionHide} class="${this.selectClasses.classSelectOption}${selectOptionClass}${selectOptionSelected}" data-value="${selectOption.value}" type="button">`;
                selectOptionHTML += this.getSelectElementContent(selectOption);
                selectOptionHTML += selectOptionLink ? `</a>` : `</button>`;
                return selectOptionHTML;
            }
            setOptions(selectItem, originalSelect) {
                const selectItemOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                selectItemOptions.innerHTML = this.getOptions(originalSelect);
            }
            optionAction(selectItem, originalSelect, optionItem) {
                if (originalSelect.multiple) {
                    optionItem.classList.toggle(this.selectClasses.classSelectOptionSelected);
                    const originalSelectSelectedItems = this.getSelectedOptionsData(originalSelect).elements;
                    originalSelectSelectedItems.forEach((originalSelectSelectedItem => {
                        originalSelectSelectedItem.removeAttribute("selected");
                    }));
                    const selectSelectedItems = selectItem.querySelectorAll(this.getSelectClass(this.selectClasses.classSelectOptionSelected));
                    selectSelectedItems.forEach((selectSelectedItems => {
                        originalSelect.querySelector(`option[value="${selectSelectedItems.dataset.value}"]`).setAttribute("selected", "selected");
                    }));
                } else {
                    if (!originalSelect.hasAttribute("data-show-selected")) {
                        if (selectItem.querySelector(`${this.getSelectClass(this.selectClasses.classSelectOption)}[hidden]`)) selectItem.querySelector(`${this.getSelectClass(this.selectClasses.classSelectOption)}[hidden]`).hidden = false;
                        optionItem.hidden = true;
                    }
                    originalSelect.value = optionItem.hasAttribute("data-value") ? optionItem.dataset.value : optionItem.textContent;
                    this.selectAction(selectItem);
                }
                this.setSelectTitleValue(selectItem, originalSelect);
                this.setSelectChange(originalSelect);
            }
            selectChange(e) {
                const originalSelect = e.target;
                this.selectBuild(originalSelect);
                this.setSelectChange(originalSelect);
            }
            setSelectChange(originalSelect) {
                if (originalSelect.hasAttribute("data-validate")) formValidate.validateInput(originalSelect);
                if (originalSelect.hasAttribute("data-submit") && originalSelect.value) {
                    let tempButton = document.createElement("button");
                    tempButton.type = "submit";
                    originalSelect.closest("form").append(tempButton);
                    tempButton.click();
                    tempButton.remove();
                }
                const selectItem = originalSelect.parentElement;
                this.selectCallback(selectItem, originalSelect);
            }
            selectDisabled(selectItem, originalSelect) {
                if (originalSelect.disabled) {
                    selectItem.classList.add(this.selectClasses.classSelectDisabled);
                    this.getSelectElement(selectItem, this.selectClasses.classSelectTitle).selectElement.disabled = true;
                } else {
                    selectItem.classList.remove(this.selectClasses.classSelectDisabled);
                    this.getSelectElement(selectItem, this.selectClasses.classSelectTitle).selectElement.disabled = false;
                }
            }
            searchActions(selectItem) {
                this.getSelectElement(selectItem).originalSelect;
                const selectInput = this.getSelectElement(selectItem, this.selectClasses.classSelectInput).selectElement;
                const selectOptions = this.getSelectElement(selectItem, this.selectClasses.classSelectOptions).selectElement;
                const selectOptionsItems = selectOptions.querySelectorAll(`.${this.selectClasses.classSelectOption}`);
                const _this = this;
                selectInput.addEventListener("input", (function() {
                    selectOptionsItems.forEach((selectOptionsItem => {
                        if (selectOptionsItem.textContent.toUpperCase().indexOf(selectInput.value.toUpperCase()) >= 0) selectOptionsItem.hidden = false; else selectOptionsItem.hidden = true;
                    }));
                    true === selectOptions.hidden ? _this.selectAction(selectItem) : null;
                }));
            }
            selectCallback(selectItem, originalSelect) {
                document.dispatchEvent(new CustomEvent("selectCallback", {
                    detail: {
                        select: originalSelect
                    }
                }));
            }
            setLogging(message) {
                this.config.logging ? functions_FLS(`[select]: ${message}`) : null;
            }
        }
        modules_flsModules.select = new SelectConstructor({});
        __webpack_require__(125);
        const inputMasksPhone = document.querySelectorAll(".phone-js");
        const inputMasksCards = document.querySelectorAll(".card-js");
        const inputMasksCode = document.querySelectorAll(".code-js");
        const inputMasksDate = document.querySelectorAll(".data-js");
        if (inputMasksPhone.length) modules_flsModules.inputMasksPhone = Inputmask({
            mask: "+7(999) 999-99-99"
        }).mask(inputMasksPhone);
        if (inputMasksCards.length) modules_flsModules.inputMasksCards = Inputmask({
            mask: "9999 9999 9999 9999"
        }).mask(inputMasksCards);
        if (inputMasksCode.length) modules_flsModules.inputMasksCode = Inputmask({
            mask: "999"
        }).mask(inputMasksCode);
        if (inputMasksDate.length) modules_flsModules.inputMasksDate = Inputmask({
            mask: "99/99"
        }).mask(inputMasksDate);
        if (inputMasksDate.length) modules_flsModules.inputMasksDate = Inputmask({
            mask: "99/99"
        }).mask(inputMasksDate);
        function ssr_window_esm_isObject(obj) {
            return null !== obj && "object" === typeof obj && "constructor" in obj && obj.constructor === Object;
        }
        function extend(target = {}, src = {}) {
            Object.keys(src).forEach((key => {
                if ("undefined" === typeof target[key]) target[key] = src[key]; else if (ssr_window_esm_isObject(src[key]) && ssr_window_esm_isObject(target[key]) && Object.keys(src[key]).length > 0) extend(target[key], src[key]);
            }));
        }
        const ssrDocument = {
            body: {},
            addEventListener() {},
            removeEventListener() {},
            activeElement: {
                blur() {},
                nodeName: ""
            },
            querySelector() {
                return null;
            },
            querySelectorAll() {
                return [];
            },
            getElementById() {
                return null;
            },
            createEvent() {
                return {
                    initEvent() {}
                };
            },
            createElement() {
                return {
                    children: [],
                    childNodes: [],
                    style: {},
                    setAttribute() {},
                    getElementsByTagName() {
                        return [];
                    }
                };
            },
            createElementNS() {
                return {};
            },
            importNode() {
                return null;
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            }
        };
        function ssr_window_esm_getDocument() {
            const doc = "undefined" !== typeof document ? document : {};
            extend(doc, ssrDocument);
            return doc;
        }
        const ssrWindow = {
            document: ssrDocument,
            navigator: {
                userAgent: ""
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            },
            history: {
                replaceState() {},
                pushState() {},
                go() {},
                back() {}
            },
            CustomEvent: function CustomEvent() {
                return this;
            },
            addEventListener() {},
            removeEventListener() {},
            getComputedStyle() {
                return {
                    getPropertyValue() {
                        return "";
                    }
                };
            },
            Image() {},
            Date() {},
            screen: {},
            setTimeout() {},
            clearTimeout() {},
            matchMedia() {
                return {};
            },
            requestAnimationFrame(callback) {
                if ("undefined" === typeof setTimeout) {
                    callback();
                    return null;
                }
                return setTimeout(callback, 0);
            },
            cancelAnimationFrame(id) {
                if ("undefined" === typeof setTimeout) return;
                clearTimeout(id);
            }
        };
        function ssr_window_esm_getWindow() {
            const win = "undefined" !== typeof window ? window : {};
            extend(win, ssrWindow);
            return win;
        }
        function makeReactive(obj) {
            const proto = obj.__proto__;
            Object.defineProperty(obj, "__proto__", {
                get() {
                    return proto;
                },
                set(value) {
                    proto.__proto__ = value;
                }
            });
        }
        class Dom7 extends Array {
            constructor(items) {
                if ("number" === typeof items) super(items); else {
                    super(...items || []);
                    makeReactive(this);
                }
            }
        }
        function arrayFlat(arr = []) {
            const res = [];
            arr.forEach((el => {
                if (Array.isArray(el)) res.push(...arrayFlat(el)); else res.push(el);
            }));
            return res;
        }
        function arrayFilter(arr, callback) {
            return Array.prototype.filter.call(arr, callback);
        }
        function arrayUnique(arr) {
            const uniqueArray = [];
            for (let i = 0; i < arr.length; i += 1) if (-1 === uniqueArray.indexOf(arr[i])) uniqueArray.push(arr[i]);
            return uniqueArray;
        }
        function qsa(selector, context) {
            if ("string" !== typeof selector) return [ selector ];
            const a = [];
            const res = context.querySelectorAll(selector);
            for (let i = 0; i < res.length; i += 1) a.push(res[i]);
            return a;
        }
        function dom7_esm_$(selector, context) {
            const window = ssr_window_esm_getWindow();
            const document = ssr_window_esm_getDocument();
            let arr = [];
            if (!context && selector instanceof Dom7) return selector;
            if (!selector) return new Dom7(arr);
            if ("string" === typeof selector) {
                const html = selector.trim();
                if (html.indexOf("<") >= 0 && html.indexOf(">") >= 0) {
                    let toCreate = "div";
                    if (0 === html.indexOf("<li")) toCreate = "ul";
                    if (0 === html.indexOf("<tr")) toCreate = "tbody";
                    if (0 === html.indexOf("<td") || 0 === html.indexOf("<th")) toCreate = "tr";
                    if (0 === html.indexOf("<tbody")) toCreate = "table";
                    if (0 === html.indexOf("<option")) toCreate = "select";
                    const tempParent = document.createElement(toCreate);
                    tempParent.innerHTML = html;
                    for (let i = 0; i < tempParent.childNodes.length; i += 1) arr.push(tempParent.childNodes[i]);
                } else arr = qsa(selector.trim(), context || document);
            } else if (selector.nodeType || selector === window || selector === document) arr.push(selector); else if (Array.isArray(selector)) {
                if (selector instanceof Dom7) return selector;
                arr = selector;
            }
            return new Dom7(arrayUnique(arr));
        }
        dom7_esm_$.fn = Dom7.prototype;
        function addClass(...classes) {
            const classNames = arrayFlat(classes.map((c => c.split(" "))));
            this.forEach((el => {
                el.classList.add(...classNames);
            }));
            return this;
        }
        function removeClass(...classes) {
            const classNames = arrayFlat(classes.map((c => c.split(" "))));
            this.forEach((el => {
                el.classList.remove(...classNames);
            }));
            return this;
        }
        function toggleClass(...classes) {
            const classNames = arrayFlat(classes.map((c => c.split(" "))));
            this.forEach((el => {
                classNames.forEach((className => {
                    el.classList.toggle(className);
                }));
            }));
        }
        function hasClass(...classes) {
            const classNames = arrayFlat(classes.map((c => c.split(" "))));
            return arrayFilter(this, (el => classNames.filter((className => el.classList.contains(className))).length > 0)).length > 0;
        }
        function attr(attrs, value) {
            if (1 === arguments.length && "string" === typeof attrs) {
                if (this[0]) return this[0].getAttribute(attrs);
                return;
            }
            for (let i = 0; i < this.length; i += 1) if (2 === arguments.length) this[i].setAttribute(attrs, value); else for (const attrName in attrs) {
                this[i][attrName] = attrs[attrName];
                this[i].setAttribute(attrName, attrs[attrName]);
            }
            return this;
        }
        function removeAttr(attr) {
            for (let i = 0; i < this.length; i += 1) this[i].removeAttribute(attr);
            return this;
        }
        function transform(transform) {
            for (let i = 0; i < this.length; i += 1) this[i].style.transform = transform;
            return this;
        }
        function transition(duration) {
            for (let i = 0; i < this.length; i += 1) this[i].style.transitionDuration = "string" !== typeof duration ? `${duration}ms` : duration;
            return this;
        }
        function on(...args) {
            let [eventType, targetSelector, listener, capture] = args;
            if ("function" === typeof args[1]) {
                [eventType, listener, capture] = args;
                targetSelector = void 0;
            }
            if (!capture) capture = false;
            function handleLiveEvent(e) {
                const target = e.target;
                if (!target) return;
                const eventData = e.target.dom7EventData || [];
                if (eventData.indexOf(e) < 0) eventData.unshift(e);
                if (dom7_esm_$(target).is(targetSelector)) listener.apply(target, eventData); else {
                    const parents = dom7_esm_$(target).parents();
                    for (let k = 0; k < parents.length; k += 1) if (dom7_esm_$(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
                }
            }
            function handleEvent(e) {
                const eventData = e && e.target ? e.target.dom7EventData || [] : [];
                if (eventData.indexOf(e) < 0) eventData.unshift(e);
                listener.apply(this, eventData);
            }
            const events = eventType.split(" ");
            let j;
            for (let i = 0; i < this.length; i += 1) {
                const el = this[i];
                if (!targetSelector) for (j = 0; j < events.length; j += 1) {
                    const event = events[j];
                    if (!el.dom7Listeners) el.dom7Listeners = {};
                    if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
                    el.dom7Listeners[event].push({
                        listener,
                        proxyListener: handleEvent
                    });
                    el.addEventListener(event, handleEvent, capture);
                } else for (j = 0; j < events.length; j += 1) {
                    const event = events[j];
                    if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
                    if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
                    el.dom7LiveListeners[event].push({
                        listener,
                        proxyListener: handleLiveEvent
                    });
                    el.addEventListener(event, handleLiveEvent, capture);
                }
            }
            return this;
        }
        function off(...args) {
            let [eventType, targetSelector, listener, capture] = args;
            if ("function" === typeof args[1]) {
                [eventType, listener, capture] = args;
                targetSelector = void 0;
            }
            if (!capture) capture = false;
            const events = eventType.split(" ");
            for (let i = 0; i < events.length; i += 1) {
                const event = events[i];
                for (let j = 0; j < this.length; j += 1) {
                    const el = this[j];
                    let handlers;
                    if (!targetSelector && el.dom7Listeners) handlers = el.dom7Listeners[event]; else if (targetSelector && el.dom7LiveListeners) handlers = el.dom7LiveListeners[event];
                    if (handlers && handlers.length) for (let k = handlers.length - 1; k >= 0; k -= 1) {
                        const handler = handlers[k];
                        if (listener && handler.listener === listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        } else if (!listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        }
                    }
                }
            }
            return this;
        }
        function trigger(...args) {
            const window = ssr_window_esm_getWindow();
            const events = args[0].split(" ");
            const eventData = args[1];
            for (let i = 0; i < events.length; i += 1) {
                const event = events[i];
                for (let j = 0; j < this.length; j += 1) {
                    const el = this[j];
                    if (window.CustomEvent) {
                        const evt = new window.CustomEvent(event, {
                            detail: eventData,
                            bubbles: true,
                            cancelable: true
                        });
                        el.dom7EventData = args.filter(((data, dataIndex) => dataIndex > 0));
                        el.dispatchEvent(evt);
                        el.dom7EventData = [];
                        delete el.dom7EventData;
                    }
                }
            }
            return this;
        }
        function transitionEnd(callback) {
            const dom = this;
            function fireCallBack(e) {
                if (e.target !== this) return;
                callback.call(this, e);
                dom.off("transitionend", fireCallBack);
            }
            if (callback) dom.on("transitionend", fireCallBack);
            return this;
        }
        function dom7_esm_outerWidth(includeMargins) {
            if (this.length > 0) {
                if (includeMargins) {
                    const styles = this.styles();
                    return this[0].offsetWidth + parseFloat(styles.getPropertyValue("margin-right")) + parseFloat(styles.getPropertyValue("margin-left"));
                }
                return this[0].offsetWidth;
            }
            return null;
        }
        function dom7_esm_outerHeight(includeMargins) {
            if (this.length > 0) {
                if (includeMargins) {
                    const styles = this.styles();
                    return this[0].offsetHeight + parseFloat(styles.getPropertyValue("margin-top")) + parseFloat(styles.getPropertyValue("margin-bottom"));
                }
                return this[0].offsetHeight;
            }
            return null;
        }
        function offset() {
            if (this.length > 0) {
                const window = ssr_window_esm_getWindow();
                const document = ssr_window_esm_getDocument();
                const el = this[0];
                const box = el.getBoundingClientRect();
                const body = document.body;
                const clientTop = el.clientTop || body.clientTop || 0;
                const clientLeft = el.clientLeft || body.clientLeft || 0;
                const scrollTop = el === window ? window.scrollY : el.scrollTop;
                const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
                return {
                    top: box.top + scrollTop - clientTop,
                    left: box.left + scrollLeft - clientLeft
                };
            }
            return null;
        }
        function styles() {
            const window = ssr_window_esm_getWindow();
            if (this[0]) return window.getComputedStyle(this[0], null);
            return {};
        }
        function css(props, value) {
            const window = ssr_window_esm_getWindow();
            let i;
            if (1 === arguments.length) if ("string" === typeof props) {
                if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
            } else {
                for (i = 0; i < this.length; i += 1) for (const prop in props) this[i].style[prop] = props[prop];
                return this;
            }
            if (2 === arguments.length && "string" === typeof props) {
                for (i = 0; i < this.length; i += 1) this[i].style[props] = value;
                return this;
            }
            return this;
        }
        function each(callback) {
            if (!callback) return this;
            this.forEach(((el, index) => {
                callback.apply(el, [ el, index ]);
            }));
            return this;
        }
        function filter(callback) {
            const result = arrayFilter(this, callback);
            return dom7_esm_$(result);
        }
        function html(html) {
            if ("undefined" === typeof html) return this[0] ? this[0].innerHTML : null;
            for (let i = 0; i < this.length; i += 1) this[i].innerHTML = html;
            return this;
        }
        function dom7_esm_text(text) {
            if ("undefined" === typeof text) return this[0] ? this[0].textContent.trim() : null;
            for (let i = 0; i < this.length; i += 1) this[i].textContent = text;
            return this;
        }
        function is(selector) {
            const window = ssr_window_esm_getWindow();
            const document = ssr_window_esm_getDocument();
            const el = this[0];
            let compareWith;
            let i;
            if (!el || "undefined" === typeof selector) return false;
            if ("string" === typeof selector) {
                if (el.matches) return el.matches(selector);
                if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
                if (el.msMatchesSelector) return el.msMatchesSelector(selector);
                compareWith = dom7_esm_$(selector);
                for (i = 0; i < compareWith.length; i += 1) if (compareWith[i] === el) return true;
                return false;
            }
            if (selector === document) return el === document;
            if (selector === window) return el === window;
            if (selector.nodeType || selector instanceof Dom7) {
                compareWith = selector.nodeType ? [ selector ] : selector;
                for (i = 0; i < compareWith.length; i += 1) if (compareWith[i] === el) return true;
                return false;
            }
            return false;
        }
        function index() {
            let child = this[0];
            let i;
            if (child) {
                i = 0;
                while (null !== (child = child.previousSibling)) if (1 === child.nodeType) i += 1;
                return i;
            }
            return;
        }
        function eq(index) {
            if ("undefined" === typeof index) return this;
            const length = this.length;
            if (index > length - 1) return dom7_esm_$([]);
            if (index < 0) {
                const returnIndex = length + index;
                if (returnIndex < 0) return dom7_esm_$([]);
                return dom7_esm_$([ this[returnIndex] ]);
            }
            return dom7_esm_$([ this[index] ]);
        }
        function append(...els) {
            let newChild;
            const document = ssr_window_esm_getDocument();
            for (let k = 0; k < els.length; k += 1) {
                newChild = els[k];
                for (let i = 0; i < this.length; i += 1) if ("string" === typeof newChild) {
                    const tempDiv = document.createElement("div");
                    tempDiv.innerHTML = newChild;
                    while (tempDiv.firstChild) this[i].appendChild(tempDiv.firstChild);
                } else if (newChild instanceof Dom7) for (let j = 0; j < newChild.length; j += 1) this[i].appendChild(newChild[j]); else this[i].appendChild(newChild);
            }
            return this;
        }
        function prepend(newChild) {
            const document = ssr_window_esm_getDocument();
            let i;
            let j;
            for (i = 0; i < this.length; i += 1) if ("string" === typeof newChild) {
                const tempDiv = document.createElement("div");
                tempDiv.innerHTML = newChild;
                for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
            } else if (newChild instanceof Dom7) for (j = 0; j < newChild.length; j += 1) this[i].insertBefore(newChild[j], this[i].childNodes[0]); else this[i].insertBefore(newChild, this[i].childNodes[0]);
            return this;
        }
        function next(selector) {
            if (this.length > 0) {
                if (selector) {
                    if (this[0].nextElementSibling && dom7_esm_$(this[0].nextElementSibling).is(selector)) return dom7_esm_$([ this[0].nextElementSibling ]);
                    return dom7_esm_$([]);
                }
                if (this[0].nextElementSibling) return dom7_esm_$([ this[0].nextElementSibling ]);
                return dom7_esm_$([]);
            }
            return dom7_esm_$([]);
        }
        function nextAll(selector) {
            const nextEls = [];
            let el = this[0];
            if (!el) return dom7_esm_$([]);
            while (el.nextElementSibling) {
                const next = el.nextElementSibling;
                if (selector) {
                    if (dom7_esm_$(next).is(selector)) nextEls.push(next);
                } else nextEls.push(next);
                el = next;
            }
            return dom7_esm_$(nextEls);
        }
        function prev(selector) {
            if (this.length > 0) {
                const el = this[0];
                if (selector) {
                    if (el.previousElementSibling && dom7_esm_$(el.previousElementSibling).is(selector)) return dom7_esm_$([ el.previousElementSibling ]);
                    return dom7_esm_$([]);
                }
                if (el.previousElementSibling) return dom7_esm_$([ el.previousElementSibling ]);
                return dom7_esm_$([]);
            }
            return dom7_esm_$([]);
        }
        function prevAll(selector) {
            const prevEls = [];
            let el = this[0];
            if (!el) return dom7_esm_$([]);
            while (el.previousElementSibling) {
                const prev = el.previousElementSibling;
                if (selector) {
                    if (dom7_esm_$(prev).is(selector)) prevEls.push(prev);
                } else prevEls.push(prev);
                el = prev;
            }
            return dom7_esm_$(prevEls);
        }
        function dom7_esm_parent(selector) {
            const parents = [];
            for (let i = 0; i < this.length; i += 1) if (null !== this[i].parentNode) if (selector) {
                if (dom7_esm_$(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
            } else parents.push(this[i].parentNode);
            return dom7_esm_$(parents);
        }
        function parents(selector) {
            const parents = [];
            for (let i = 0; i < this.length; i += 1) {
                let parent = this[i].parentNode;
                while (parent) {
                    if (selector) {
                        if (dom7_esm_$(parent).is(selector)) parents.push(parent);
                    } else parents.push(parent);
                    parent = parent.parentNode;
                }
            }
            return dom7_esm_$(parents);
        }
        function closest(selector) {
            let closest = this;
            if ("undefined" === typeof selector) return dom7_esm_$([]);
            if (!closest.is(selector)) closest = closest.parents(selector).eq(0);
            return closest;
        }
        function find(selector) {
            const foundElements = [];
            for (let i = 0; i < this.length; i += 1) {
                const found = this[i].querySelectorAll(selector);
                for (let j = 0; j < found.length; j += 1) foundElements.push(found[j]);
            }
            return dom7_esm_$(foundElements);
        }
        function children(selector) {
            const children = [];
            for (let i = 0; i < this.length; i += 1) {
                const childNodes = this[i].children;
                for (let j = 0; j < childNodes.length; j += 1) if (!selector || dom7_esm_$(childNodes[j]).is(selector)) children.push(childNodes[j]);
            }
            return dom7_esm_$(children);
        }
        function remove() {
            for (let i = 0; i < this.length; i += 1) if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
            return this;
        }
        const noTrigger = "resize scroll".split(" ");
        function shortcut(name) {
            function eventHandler(...args) {
                if ("undefined" === typeof args[0]) {
                    for (let i = 0; i < this.length; i += 1) if (noTrigger.indexOf(name) < 0) if (name in this[i]) this[i][name](); else dom7_esm_$(this[i]).trigger(name);
                    return this;
                }
                return this.on(name, ...args);
            }
            return eventHandler;
        }
        shortcut("click");
        shortcut("blur");
        shortcut("focus");
        shortcut("focusin");
        shortcut("focusout");
        shortcut("keyup");
        shortcut("keydown");
        shortcut("keypress");
        shortcut("submit");
        shortcut("change");
        shortcut("mousedown");
        shortcut("mousemove");
        shortcut("mouseup");
        shortcut("mouseenter");
        shortcut("mouseleave");
        shortcut("mouseout");
        shortcut("mouseover");
        shortcut("touchstart");
        shortcut("touchend");
        shortcut("touchmove");
        shortcut("resize");
        shortcut("scroll");
        const Methods = {
            addClass,
            removeClass,
            hasClass,
            toggleClass,
            attr,
            removeAttr,
            transform,
            transition,
            on,
            off,
            trigger,
            transitionEnd,
            outerWidth: dom7_esm_outerWidth,
            outerHeight: dom7_esm_outerHeight,
            styles,
            offset,
            css,
            each,
            html,
            text: dom7_esm_text,
            is,
            index,
            eq,
            append,
            prepend,
            next,
            nextAll,
            prev,
            prevAll,
            parent: dom7_esm_parent,
            parents,
            closest,
            find,
            children,
            filter,
            remove
        };
        Object.keys(Methods).forEach((methodName => {
            Object.defineProperty(dom7_esm_$.fn, methodName, {
                value: Methods[methodName],
                writable: true
            });
        }));
        const dom = dom7_esm_$;
        function deleteProps(obj) {
            const object = obj;
            Object.keys(object).forEach((key => {
                try {
                    object[key] = null;
                } catch (e) {}
                try {
                    delete object[key];
                } catch (e) {}
            }));
        }
        function utils_nextTick(callback, delay) {
            if (void 0 === delay) delay = 0;
            return setTimeout(callback, delay);
        }
        function utils_now() {
            return Date.now();
        }
        function utils_getComputedStyle(el) {
            const window = ssr_window_esm_getWindow();
            let style;
            if (window.getComputedStyle) style = window.getComputedStyle(el, null);
            if (!style && el.currentStyle) style = el.currentStyle;
            if (!style) style = el.style;
            return style;
        }
        function utils_getTranslate(el, axis) {
            if (void 0 === axis) axis = "x";
            const window = ssr_window_esm_getWindow();
            let matrix;
            let curTransform;
            let transformMatrix;
            const curStyle = utils_getComputedStyle(el, null);
            if (window.WebKitCSSMatrix) {
                curTransform = curStyle.transform || curStyle.webkitTransform;
                if (curTransform.split(",").length > 6) curTransform = curTransform.split(", ").map((a => a.replace(",", "."))).join(", ");
                transformMatrix = new window.WebKitCSSMatrix("none" === curTransform ? "" : curTransform);
            } else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
                matrix = transformMatrix.toString().split(",");
            }
            if ("x" === axis) if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; else if (16 === matrix.length) curTransform = parseFloat(matrix[12]); else curTransform = parseFloat(matrix[4]);
            if ("y" === axis) if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; else if (16 === matrix.length) curTransform = parseFloat(matrix[13]); else curTransform = parseFloat(matrix[5]);
            return curTransform || 0;
        }
        function utils_isObject(o) {
            return "object" === typeof o && null !== o && o.constructor && "Object" === Object.prototype.toString.call(o).slice(8, -1);
        }
        function isNode(node) {
            if ("undefined" !== typeof window && "undefined" !== typeof window.HTMLElement) return node instanceof HTMLElement;
            return node && (1 === node.nodeType || 11 === node.nodeType);
        }
        function utils_extend() {
            const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
            const noExtend = [ "__proto__", "constructor", "prototype" ];
            for (let i = 1; i < arguments.length; i += 1) {
                const nextSource = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                if (void 0 !== nextSource && null !== nextSource && !isNode(nextSource)) {
                    const keysArray = Object.keys(Object(nextSource)).filter((key => noExtend.indexOf(key) < 0));
                    for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                        const nextKey = keysArray[nextIndex];
                        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (void 0 !== desc && desc.enumerable) if (utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]); else if (!utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
                            to[nextKey] = {};
                            if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]);
                        } else to[nextKey] = nextSource[nextKey];
                    }
                }
            }
            return to;
        }
        function utils_setCSSProperty(el, varName, varValue) {
            el.style.setProperty(varName, varValue);
        }
        function animateCSSModeScroll(_ref) {
            let {swiper, targetPosition, side} = _ref;
            const window = ssr_window_esm_getWindow();
            const startPosition = -swiper.translate;
            let startTime = null;
            let time;
            const duration = swiper.params.speed;
            swiper.wrapperEl.style.scrollSnapType = "none";
            window.cancelAnimationFrame(swiper.cssModeFrameID);
            const dir = targetPosition > startPosition ? "next" : "prev";
            const isOutOfBound = (current, target) => "next" === dir && current >= target || "prev" === dir && current <= target;
            const animate = () => {
                time = (new Date).getTime();
                if (null === startTime) startTime = time;
                const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
                const easeProgress = .5 - Math.cos(progress * Math.PI) / 2;
                let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
                if (isOutOfBound(currentPosition, targetPosition)) currentPosition = targetPosition;
                swiper.wrapperEl.scrollTo({
                    [side]: currentPosition
                });
                if (isOutOfBound(currentPosition, targetPosition)) {
                    swiper.wrapperEl.style.overflow = "hidden";
                    swiper.wrapperEl.style.scrollSnapType = "";
                    setTimeout((() => {
                        swiper.wrapperEl.style.overflow = "";
                        swiper.wrapperEl.scrollTo({
                            [side]: currentPosition
                        });
                    }));
                    window.cancelAnimationFrame(swiper.cssModeFrameID);
                    return;
                }
                swiper.cssModeFrameID = window.requestAnimationFrame(animate);
            };
            animate();
        }
        let support;
        function calcSupport() {
            const window = ssr_window_esm_getWindow();
            const document = ssr_window_esm_getDocument();
            return {
                smoothScroll: document.documentElement && "scrollBehavior" in document.documentElement.style,
                touch: !!("ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch),
                passiveListener: function checkPassiveListener() {
                    let supportsPassive = false;
                    try {
                        const opts = Object.defineProperty({}, "passive", {
                            get() {
                                supportsPassive = true;
                            }
                        });
                        window.addEventListener("testPassiveListener", null, opts);
                    } catch (e) {}
                    return supportsPassive;
                }(),
                gestures: function checkGestures() {
                    return "ongesturestart" in window;
                }()
            };
        }
        function getSupport() {
            if (!support) support = calcSupport();
            return support;
        }
        let deviceCached;
        function calcDevice(_temp) {
            let {userAgent} = void 0 === _temp ? {} : _temp;
            const support = getSupport();
            const window = ssr_window_esm_getWindow();
            const platform = window.navigator.platform;
            const ua = userAgent || window.navigator.userAgent;
            const device = {
                ios: false,
                android: false
            };
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
            const windows = "Win32" === platform;
            let macos = "MacIntel" === platform;
            const iPadScreens = [ "1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810" ];
            if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
                ipad = ua.match(/(Version)\/([\d.]+)/);
                if (!ipad) ipad = [ 0, 1, "13_0_0" ];
                macos = false;
            }
            if (android && !windows) {
                device.os = "android";
                device.android = true;
            }
            if (ipad || iphone || ipod) {
                device.os = "ios";
                device.ios = true;
            }
            return device;
        }
        function getDevice(overrides) {
            if (void 0 === overrides) overrides = {};
            if (!deviceCached) deviceCached = calcDevice(overrides);
            return deviceCached;
        }
        let browser;
        function calcBrowser() {
            const window = ssr_window_esm_getWindow();
            function isSafari() {
                const ua = window.navigator.userAgent.toLowerCase();
                return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
            }
            return {
                isSafari: isSafari(),
                isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
            };
        }
        function getBrowser() {
            if (!browser) browser = calcBrowser();
            return browser;
        }
        function Resize(_ref) {
            let {swiper, on, emit} = _ref;
            const window = ssr_window_esm_getWindow();
            let observer = null;
            let animationFrame = null;
            const resizeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("beforeResize");
                emit("resize");
            };
            const createObserver = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                observer = new ResizeObserver((entries => {
                    animationFrame = window.requestAnimationFrame((() => {
                        const {width, height} = swiper;
                        let newWidth = width;
                        let newHeight = height;
                        entries.forEach((_ref2 => {
                            let {contentBoxSize, contentRect, target} = _ref2;
                            if (target && target !== swiper.el) return;
                            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                        }));
                        if (newWidth !== width || newHeight !== height) resizeHandler();
                    }));
                }));
                observer.observe(swiper.el);
            };
            const removeObserver = () => {
                if (animationFrame) window.cancelAnimationFrame(animationFrame);
                if (observer && observer.unobserve && swiper.el) {
                    observer.unobserve(swiper.el);
                    observer = null;
                }
            };
            const orientationChangeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("orientationchange");
            };
            on("init", (() => {
                if (swiper.params.resizeObserver && "undefined" !== typeof window.ResizeObserver) {
                    createObserver();
                    return;
                }
                window.addEventListener("resize", resizeHandler);
                window.addEventListener("orientationchange", orientationChangeHandler);
            }));
            on("destroy", (() => {
                removeObserver();
                window.removeEventListener("resize", resizeHandler);
                window.removeEventListener("orientationchange", orientationChangeHandler);
            }));
        }
        function Observer(_ref) {
            let {swiper, extendParams, on, emit} = _ref;
            const observers = [];
            const window = ssr_window_esm_getWindow();
            const attach = function(target, options) {
                if (void 0 === options) options = {};
                const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
                const observer = new ObserverFunc((mutations => {
                    if (1 === mutations.length) {
                        emit("observerUpdate", mutations[0]);
                        return;
                    }
                    const observerUpdate = function observerUpdate() {
                        emit("observerUpdate", mutations[0]);
                    };
                    if (window.requestAnimationFrame) window.requestAnimationFrame(observerUpdate); else window.setTimeout(observerUpdate, 0);
                }));
                observer.observe(target, {
                    attributes: "undefined" === typeof options.attributes ? true : options.attributes,
                    childList: "undefined" === typeof options.childList ? true : options.childList,
                    characterData: "undefined" === typeof options.characterData ? true : options.characterData
                });
                observers.push(observer);
            };
            const init = () => {
                if (!swiper.params.observer) return;
                if (swiper.params.observeParents) {
                    const containerParents = swiper.$el.parents();
                    for (let i = 0; i < containerParents.length; i += 1) attach(containerParents[i]);
                }
                attach(swiper.$el[0], {
                    childList: swiper.params.observeSlideChildren
                });
                attach(swiper.$wrapperEl[0], {
                    attributes: false
                });
            };
            const destroy = () => {
                observers.forEach((observer => {
                    observer.disconnect();
                }));
                observers.splice(0, observers.length);
            };
            extendParams({
                observer: false,
                observeParents: false,
                observeSlideChildren: false
            });
            on("init", init);
            on("destroy", destroy);
        }
        const events_emitter = {
            on(events, handler, priority) {
                const self = this;
                if ("function" !== typeof handler) return self;
                const method = priority ? "unshift" : "push";
                events.split(" ").forEach((event => {
                    if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
                    self.eventsListeners[event][method](handler);
                }));
                return self;
            },
            once(events, handler, priority) {
                const self = this;
                if ("function" !== typeof handler) return self;
                function onceHandler() {
                    self.off(events, onceHandler);
                    if (onceHandler.__emitterProxy) delete onceHandler.__emitterProxy;
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    handler.apply(self, args);
                }
                onceHandler.__emitterProxy = handler;
                return self.on(events, onceHandler, priority);
            },
            onAny(handler, priority) {
                const self = this;
                if ("function" !== typeof handler) return self;
                const method = priority ? "unshift" : "push";
                if (self.eventsAnyListeners.indexOf(handler) < 0) self.eventsAnyListeners[method](handler);
                return self;
            },
            offAny(handler) {
                const self = this;
                if (!self.eventsAnyListeners) return self;
                const index = self.eventsAnyListeners.indexOf(handler);
                if (index >= 0) self.eventsAnyListeners.splice(index, 1);
                return self;
            },
            off(events, handler) {
                const self = this;
                if (!self.eventsListeners) return self;
                events.split(" ").forEach((event => {
                    if ("undefined" === typeof handler) self.eventsListeners[event] = []; else if (self.eventsListeners[event]) self.eventsListeners[event].forEach(((eventHandler, index) => {
                        if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) self.eventsListeners[event].splice(index, 1);
                    }));
                }));
                return self;
            },
            emit() {
                const self = this;
                if (!self.eventsListeners) return self;
                let events;
                let data;
                let context;
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                if ("string" === typeof args[0] || Array.isArray(args[0])) {
                    events = args[0];
                    data = args.slice(1, args.length);
                    context = self;
                } else {
                    events = args[0].events;
                    data = args[0].data;
                    context = args[0].context || self;
                }
                data.unshift(context);
                const eventsArray = Array.isArray(events) ? events : events.split(" ");
                eventsArray.forEach((event => {
                    if (self.eventsAnyListeners && self.eventsAnyListeners.length) self.eventsAnyListeners.forEach((eventHandler => {
                        eventHandler.apply(context, [ event, ...data ]);
                    }));
                    if (self.eventsListeners && self.eventsListeners[event]) self.eventsListeners[event].forEach((eventHandler => {
                        eventHandler.apply(context, data);
                    }));
                }));
                return self;
            }
        };
        function updateSize() {
            const swiper = this;
            let width;
            let height;
            const $el = swiper.$el;
            if ("undefined" !== typeof swiper.params.width && null !== swiper.params.width) width = swiper.params.width; else width = $el[0].clientWidth;
            if ("undefined" !== typeof swiper.params.height && null !== swiper.params.height) height = swiper.params.height; else height = $el[0].clientHeight;
            if (0 === width && swiper.isHorizontal() || 0 === height && swiper.isVertical()) return;
            width = width - parseInt($el.css("padding-left") || 0, 10) - parseInt($el.css("padding-right") || 0, 10);
            height = height - parseInt($el.css("padding-top") || 0, 10) - parseInt($el.css("padding-bottom") || 0, 10);
            if (Number.isNaN(width)) width = 0;
            if (Number.isNaN(height)) height = 0;
            Object.assign(swiper, {
                width,
                height,
                size: swiper.isHorizontal() ? width : height
            });
        }
        function updateSlides() {
            const swiper = this;
            function getDirectionLabel(property) {
                if (swiper.isHorizontal()) return property;
                return {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom"
                }[property];
            }
            function getDirectionPropertyValue(node, label) {
                return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
            }
            const params = swiper.params;
            const {$wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
            const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
            const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
            let snapGrid = [];
            const slidesGrid = [];
            const slidesSizesGrid = [];
            let offsetBefore = params.slidesOffsetBefore;
            if ("function" === typeof offsetBefore) offsetBefore = params.slidesOffsetBefore.call(swiper);
            let offsetAfter = params.slidesOffsetAfter;
            if ("function" === typeof offsetAfter) offsetAfter = params.slidesOffsetAfter.call(swiper);
            const previousSnapGridLength = swiper.snapGrid.length;
            const previousSlidesGridLength = swiper.slidesGrid.length;
            let spaceBetween = params.spaceBetween;
            let slidePosition = -offsetBefore;
            let prevSlideSize = 0;
            let index = 0;
            if ("undefined" === typeof swiperSize) return;
            if ("string" === typeof spaceBetween && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
            swiper.virtualSize = -spaceBetween;
            if (rtl) slides.css({
                marginLeft: "",
                marginBottom: "",
                marginTop: ""
            }); else slides.css({
                marginRight: "",
                marginBottom: "",
                marginTop: ""
            });
            if (params.centeredSlides && params.cssMode) {
                utils_setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", "");
                utils_setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", "");
            }
            const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
            if (gridEnabled) swiper.grid.initSlides(slidesLength);
            let slideSize;
            const shouldResetSlideSize = "auto" === params.slidesPerView && params.breakpoints && Object.keys(params.breakpoints).filter((key => "undefined" !== typeof params.breakpoints[key].slidesPerView)).length > 0;
            for (let i = 0; i < slidesLength; i += 1) {
                slideSize = 0;
                const slide = slides.eq(i);
                if (gridEnabled) swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
                if ("none" === slide.css("display")) continue;
                if ("auto" === params.slidesPerView) {
                    if (shouldResetSlideSize) slides[i].style[getDirectionLabel("width")] = ``;
                    const slideStyles = getComputedStyle(slide[0]);
                    const currentTransform = slide[0].style.transform;
                    const currentWebKitTransform = slide[0].style.webkitTransform;
                    if (currentTransform) slide[0].style.transform = "none";
                    if (currentWebKitTransform) slide[0].style.webkitTransform = "none";
                    if (params.roundLengths) slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true); else {
                        const width = getDirectionPropertyValue(slideStyles, "width");
                        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
                        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
                        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
                        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
                        const boxSizing = slideStyles.getPropertyValue("box-sizing");
                        if (boxSizing && "border-box" === boxSizing) slideSize = width + marginLeft + marginRight; else {
                            const {clientWidth, offsetWidth} = slide[0];
                            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                        }
                    }
                    if (currentTransform) slide[0].style.transform = currentTransform;
                    if (currentWebKitTransform) slide[0].style.webkitTransform = currentWebKitTransform;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                } else {
                    slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                    if (slides[i]) slides[i].style[getDirectionLabel("width")] = `${slideSize}px`;
                }
                if (slides[i]) slides[i].swiperSlideSize = slideSize;
                slidesSizesGrid.push(slideSize);
                if (params.centeredSlides) {
                    slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                    if (0 === prevSlideSize && 0 !== i) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (0 === i) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                } else {
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                    slidePosition = slidePosition + slideSize + spaceBetween;
                }
                swiper.virtualSize += slideSize + spaceBetween;
                prevSlideSize = slideSize;
                index += 1;
            }
            swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
            if (rtl && wrongRTL && ("slide" === params.effect || "coverflow" === params.effect)) $wrapperEl.css({
                width: `${swiper.virtualSize + params.spaceBetween}px`
            });
            if (params.setWrapperSize) $wrapperEl.css({
                [getDirectionLabel("width")]: `${swiper.virtualSize + params.spaceBetween}px`
            });
            if (gridEnabled) swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
            if (!params.centeredSlides) {
                const newSlidesGrid = [];
                for (let i = 0; i < snapGrid.length; i += 1) {
                    let slidesGridItem = snapGrid[i];
                    if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                    if (snapGrid[i] <= swiper.virtualSize - swiperSize) newSlidesGrid.push(slidesGridItem);
                }
                snapGrid = newSlidesGrid;
                if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) snapGrid.push(swiper.virtualSize - swiperSize);
            }
            if (0 === snapGrid.length) snapGrid = [ 0 ];
            if (0 !== params.spaceBetween) {
                const key = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
                slides.filter(((_, slideIndex) => {
                    if (!params.cssMode) return true;
                    if (slideIndex === slides.length - 1) return false;
                    return true;
                })).css({
                    [key]: `${spaceBetween}px`
                });
            }
            if (params.centeredSlides && params.centeredSlidesBounds) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach((slideSizeValue => {
                    allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
                }));
                allSlidesSize -= params.spaceBetween;
                const maxSnap = allSlidesSize - swiperSize;
                snapGrid = snapGrid.map((snap => {
                    if (snap < 0) return -offsetBefore;
                    if (snap > maxSnap) return maxSnap + offsetAfter;
                    return snap;
                }));
            }
            if (params.centerInsufficientSlides) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach((slideSizeValue => {
                    allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
                }));
                allSlidesSize -= params.spaceBetween;
                if (allSlidesSize < swiperSize) {
                    const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
                    snapGrid.forEach(((snap, snapIndex) => {
                        snapGrid[snapIndex] = snap - allSlidesOffset;
                    }));
                    slidesGrid.forEach(((snap, snapIndex) => {
                        slidesGrid[snapIndex] = snap + allSlidesOffset;
                    }));
                }
            }
            Object.assign(swiper, {
                slides,
                snapGrid,
                slidesGrid,
                slidesSizesGrid
            });
            if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
                utils_setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
                utils_setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
                const addToSnapGrid = -swiper.snapGrid[0];
                const addToSlidesGrid = -swiper.slidesGrid[0];
                swiper.snapGrid = swiper.snapGrid.map((v => v + addToSnapGrid));
                swiper.slidesGrid = swiper.slidesGrid.map((v => v + addToSlidesGrid));
            }
            if (slidesLength !== previousSlidesLength) swiper.emit("slidesLengthChange");
            if (snapGrid.length !== previousSnapGridLength) {
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                swiper.emit("snapGridLengthChange");
            }
            if (slidesGrid.length !== previousSlidesGridLength) swiper.emit("slidesGridLengthChange");
            if (params.watchSlidesProgress) swiper.updateSlidesOffset();
            if (!isVirtual && !params.cssMode && ("slide" === params.effect || "fade" === params.effect)) {
                const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
                const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);
                if (slidesLength <= params.maxBackfaceHiddenSlides) {
                    if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);
                } else if (hasClassBackfaceClassAdded) swiper.$el.removeClass(backFaceHiddenClass);
            }
        }
        function updateAutoHeight(speed) {
            const swiper = this;
            const activeSlides = [];
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            let newHeight = 0;
            let i;
            if ("number" === typeof speed) swiper.setTransition(speed); else if (true === speed) swiper.setTransition(swiper.params.speed);
            const getSlideByIndex = index => {
                if (isVirtual) return swiper.slides.filter((el => parseInt(el.getAttribute("data-swiper-slide-index"), 10) === index))[0];
                return swiper.slides.eq(index)[0];
            };
            if ("auto" !== swiper.params.slidesPerView && swiper.params.slidesPerView > 1) if (swiper.params.centeredSlides) swiper.visibleSlides.each((slide => {
                activeSlides.push(slide);
            })); else for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                const index = swiper.activeIndex + i;
                if (index > swiper.slides.length && !isVirtual) break;
                activeSlides.push(getSlideByIndex(index));
            } else activeSlides.push(getSlideByIndex(swiper.activeIndex));
            for (i = 0; i < activeSlides.length; i += 1) if ("undefined" !== typeof activeSlides[i]) {
                const height = activeSlides[i].offsetHeight;
                newHeight = height > newHeight ? height : newHeight;
            }
            if (newHeight || 0 === newHeight) swiper.$wrapperEl.css("height", `${newHeight}px`);
        }
        function updateSlidesOffset() {
            const swiper = this;
            const slides = swiper.slides;
            for (let i = 0; i < slides.length; i += 1) slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
        }
        function updateSlidesProgress(translate) {
            if (void 0 === translate) translate = this && this.translate || 0;
            const swiper = this;
            const params = swiper.params;
            const {slides, rtlTranslate: rtl, snapGrid} = swiper;
            if (0 === slides.length) return;
            if ("undefined" === typeof slides[0].swiperSlideOffset) swiper.updateSlidesOffset();
            let offsetCenter = -translate;
            if (rtl) offsetCenter = translate;
            slides.removeClass(params.slideVisibleClass);
            swiper.visibleSlidesIndexes = [];
            swiper.visibleSlides = [];
            for (let i = 0; i < slides.length; i += 1) {
                const slide = slides[i];
                let slideOffset = slide.swiperSlideOffset;
                if (params.cssMode && params.centeredSlides) slideOffset -= slides[0].swiperSlideOffset;
                const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
                const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
                const slideBefore = -(offsetCenter - slideOffset);
                const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
                const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
                if (isVisible) {
                    swiper.visibleSlides.push(slide);
                    swiper.visibleSlidesIndexes.push(i);
                    slides.eq(i).addClass(params.slideVisibleClass);
                }
                slide.progress = rtl ? -slideProgress : slideProgress;
                slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
            }
            swiper.visibleSlides = dom(swiper.visibleSlides);
        }
        function updateProgress(translate) {
            const swiper = this;
            if ("undefined" === typeof translate) {
                const multiplier = swiper.rtlTranslate ? -1 : 1;
                translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
            }
            const params = swiper.params;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            let {progress, isBeginning, isEnd} = swiper;
            const wasBeginning = isBeginning;
            const wasEnd = isEnd;
            if (0 === translatesDiff) {
                progress = 0;
                isBeginning = true;
                isEnd = true;
            } else {
                progress = (translate - swiper.minTranslate()) / translatesDiff;
                isBeginning = progress <= 0;
                isEnd = progress >= 1;
            }
            Object.assign(swiper, {
                progress,
                isBeginning,
                isEnd
            });
            if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
            if (isBeginning && !wasBeginning) swiper.emit("reachBeginning toEdge");
            if (isEnd && !wasEnd) swiper.emit("reachEnd toEdge");
            if (wasBeginning && !isBeginning || wasEnd && !isEnd) swiper.emit("fromEdge");
            swiper.emit("progress", progress);
        }
        function updateSlidesClasses() {
            const swiper = this;
            const {slides, params, $wrapperEl, activeIndex, realIndex} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
            let activeSlide;
            if (isVirtual) activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`); else activeSlide = slides.eq(activeIndex);
            activeSlide.addClass(params.slideActiveClass);
            if (params.loop) if (activeSlide.hasClass(params.slideDuplicateClass)) $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass); else $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
            let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
            if (params.loop && 0 === nextSlide.length) {
                nextSlide = slides.eq(0);
                nextSlide.addClass(params.slideNextClass);
            }
            let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
            if (params.loop && 0 === prevSlide.length) {
                prevSlide = slides.eq(-1);
                prevSlide.addClass(params.slidePrevClass);
            }
            if (params.loop) {
                if (nextSlide.hasClass(params.slideDuplicateClass)) $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass); else $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
                if (prevSlide.hasClass(params.slideDuplicateClass)) $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass); else $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
            }
            swiper.emitSlidesClasses();
        }
        function updateActiveIndex(newActiveIndex) {
            const swiper = this;
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            const {slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex} = swiper;
            let activeIndex = newActiveIndex;
            let snapIndex;
            if ("undefined" === typeof activeIndex) {
                for (let i = 0; i < slidesGrid.length; i += 1) if ("undefined" !== typeof slidesGrid[i + 1]) {
                    if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) activeIndex = i; else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) activeIndex = i + 1;
                } else if (translate >= slidesGrid[i]) activeIndex = i;
                if (params.normalizeSlideIndex) if (activeIndex < 0 || "undefined" === typeof activeIndex) activeIndex = 0;
            }
            if (snapGrid.indexOf(translate) >= 0) snapIndex = snapGrid.indexOf(translate); else {
                const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
                snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
            }
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            if (activeIndex === previousIndex) {
                if (snapIndex !== previousSnapIndex) {
                    swiper.snapIndex = snapIndex;
                    swiper.emit("snapIndexChange");
                }
                return;
            }
            const realIndex = parseInt(swiper.slides.eq(activeIndex).attr("data-swiper-slide-index") || activeIndex, 10);
            Object.assign(swiper, {
                snapIndex,
                realIndex,
                previousIndex,
                activeIndex
            });
            swiper.emit("activeIndexChange");
            swiper.emit("snapIndexChange");
            if (previousRealIndex !== realIndex) swiper.emit("realIndexChange");
            if (swiper.initialized || swiper.params.runCallbacksOnInit) swiper.emit("slideChange");
        }
        function updateClickedSlide(e) {
            const swiper = this;
            const params = swiper.params;
            const slide = dom(e).closest(`.${params.slideClass}`)[0];
            let slideFound = false;
            let slideIndex;
            if (slide) for (let i = 0; i < swiper.slides.length; i += 1) if (swiper.slides[i] === slide) {
                slideFound = true;
                slideIndex = i;
                break;
            }
            if (slide && slideFound) {
                swiper.clickedSlide = slide;
                if (swiper.virtual && swiper.params.virtual.enabled) swiper.clickedIndex = parseInt(dom(slide).attr("data-swiper-slide-index"), 10); else swiper.clickedIndex = slideIndex;
            } else {
                swiper.clickedSlide = void 0;
                swiper.clickedIndex = void 0;
                return;
            }
            if (params.slideToClickedSlide && void 0 !== swiper.clickedIndex && swiper.clickedIndex !== swiper.activeIndex) swiper.slideToClickedSlide();
        }
        const update = {
            updateSize,
            updateSlides,
            updateAutoHeight,
            updateSlidesOffset,
            updateSlidesProgress,
            updateProgress,
            updateSlidesClasses,
            updateActiveIndex,
            updateClickedSlide
        };
        function getSwiperTranslate(axis) {
            if (void 0 === axis) axis = this.isHorizontal() ? "x" : "y";
            const swiper = this;
            const {params, rtlTranslate: rtl, translate, $wrapperEl} = swiper;
            if (params.virtualTranslate) return rtl ? -translate : translate;
            if (params.cssMode) return translate;
            let currentTranslate = utils_getTranslate($wrapperEl[0], axis);
            if (rtl) currentTranslate = -currentTranslate;
            return currentTranslate || 0;
        }
        function setTranslate(translate, byController) {
            const swiper = this;
            const {rtlTranslate: rtl, params, $wrapperEl, wrapperEl, progress} = swiper;
            let x = 0;
            let y = 0;
            const z = 0;
            if (swiper.isHorizontal()) x = rtl ? -translate : translate; else y = translate;
            if (params.roundLengths) {
                x = Math.floor(x);
                y = Math.floor(y);
            }
            if (params.cssMode) wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y; else if (!params.virtualTranslate) $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
            swiper.previousTranslate = swiper.translate;
            swiper.translate = swiper.isHorizontal() ? x : y;
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (0 === translatesDiff) newProgress = 0; else newProgress = (translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== progress) swiper.updateProgress(translate);
            swiper.emit("setTranslate", swiper.translate, byController);
        }
        function minTranslate() {
            return -this.snapGrid[0];
        }
        function maxTranslate() {
            return -this.snapGrid[this.snapGrid.length - 1];
        }
        function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
            if (void 0 === translate) translate = 0;
            if (void 0 === speed) speed = this.params.speed;
            if (void 0 === runCallbacks) runCallbacks = true;
            if (void 0 === translateBounds) translateBounds = true;
            const swiper = this;
            const {params, wrapperEl} = swiper;
            if (swiper.animating && params.preventInteractionOnTransition) return false;
            const minTranslate = swiper.minTranslate();
            const maxTranslate = swiper.maxTranslate();
            let newTranslate;
            if (translateBounds && translate > minTranslate) newTranslate = minTranslate; else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate; else newTranslate = translate;
            swiper.updateProgress(newTranslate);
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                if (0 === speed) wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate; else {
                    if (!swiper.support.smoothScroll) {
                        animateCSSModeScroll({
                            swiper,
                            targetPosition: -newTranslate,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: -newTranslate,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            if (0 === speed) {
                swiper.setTransition(0);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionEnd");
                }
            } else {
                swiper.setTransition(speed);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionStart");
                }
                if (!swiper.animating) {
                    swiper.animating = true;
                    if (!swiper.onTranslateToWrapperTransitionEnd) swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                        if (!swiper || swiper.destroyed) return;
                        if (e.target !== this) return;
                        swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                        swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
                        swiper.onTranslateToWrapperTransitionEnd = null;
                        delete swiper.onTranslateToWrapperTransitionEnd;
                        if (runCallbacks) swiper.emit("transitionEnd");
                    };
                    swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                    swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
                }
            }
            return true;
        }
        const translate = {
            getTranslate: getSwiperTranslate,
            setTranslate,
            minTranslate,
            maxTranslate,
            translateTo
        };
        function setTransition(duration, byController) {
            const swiper = this;
            if (!swiper.params.cssMode) swiper.$wrapperEl.transition(duration);
            swiper.emit("setTransition", duration, byController);
        }
        function transitionEmit(_ref) {
            let {swiper, runCallbacks, direction, step} = _ref;
            const {activeIndex, previousIndex} = swiper;
            let dir = direction;
            if (!dir) if (activeIndex > previousIndex) dir = "next"; else if (activeIndex < previousIndex) dir = "prev"; else dir = "reset";
            swiper.emit(`transition${step}`);
            if (runCallbacks && activeIndex !== previousIndex) {
                if ("reset" === dir) {
                    swiper.emit(`slideResetTransition${step}`);
                    return;
                }
                swiper.emit(`slideChangeTransition${step}`);
                if ("next" === dir) swiper.emit(`slideNextTransition${step}`); else swiper.emit(`slidePrevTransition${step}`);
            }
        }
        function transitionStart(runCallbacks, direction) {
            if (void 0 === runCallbacks) runCallbacks = true;
            const swiper = this;
            const {params} = swiper;
            if (params.cssMode) return;
            if (params.autoHeight) swiper.updateAutoHeight();
            transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "Start"
            });
        }
        function transitionEnd_transitionEnd(runCallbacks, direction) {
            if (void 0 === runCallbacks) runCallbacks = true;
            const swiper = this;
            const {params} = swiper;
            swiper.animating = false;
            if (params.cssMode) return;
            swiper.setTransition(0);
            transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "End"
            });
        }
        const core_transition = {
            setTransition,
            transitionStart,
            transitionEnd: transitionEnd_transitionEnd
        };
        function slideTo(index, speed, runCallbacks, internal, initial) {
            if (void 0 === index) index = 0;
            if (void 0 === speed) speed = this.params.speed;
            if (void 0 === runCallbacks) runCallbacks = true;
            if ("number" !== typeof index && "string" !== typeof index) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
            if ("string" === typeof index) {
                const indexAsNumber = parseInt(index, 10);
                const isValidNumber = isFinite(indexAsNumber);
                if (!isValidNumber) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
                index = indexAsNumber;
            }
            const swiper = this;
            let slideIndex = index;
            if (slideIndex < 0) slideIndex = 0;
            const {params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled} = swiper;
            if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) return false;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
            let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) swiper.emit("beforeSlideChangeStart");
            const translate = -snapGrid[snapIndex];
            swiper.updateProgress(translate);
            if (params.normalizeSlideIndex) for (let i = 0; i < slidesGrid.length; i += 1) {
                const normalizedTranslate = -Math.floor(100 * translate);
                const normalizedGrid = Math.floor(100 * slidesGrid[i]);
                const normalizedGridNext = Math.floor(100 * slidesGrid[i + 1]);
                if ("undefined" !== typeof slidesGrid[i + 1]) {
                    if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) slideIndex = i; else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) slideIndex = i + 1;
                } else if (normalizedTranslate >= normalizedGrid) slideIndex = i;
            }
            if (swiper.initialized && slideIndex !== activeIndex) {
                if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) return false;
                if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) if ((activeIndex || 0) !== slideIndex) return false;
            }
            let direction;
            if (slideIndex > activeIndex) direction = "next"; else if (slideIndex < activeIndex) direction = "prev"; else direction = "reset";
            if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
                swiper.updateActiveIndex(slideIndex);
                if (params.autoHeight) swiper.updateAutoHeight();
                swiper.updateSlidesClasses();
                if ("slide" !== params.effect) swiper.setTranslate(translate);
                if ("reset" !== direction) {
                    swiper.transitionStart(runCallbacks, direction);
                    swiper.transitionEnd(runCallbacks, direction);
                }
                return false;
            }
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                const t = rtl ? translate : -translate;
                if (0 === speed) {
                    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                    if (isVirtual) {
                        swiper.wrapperEl.style.scrollSnapType = "none";
                        swiper._immediateVirtual = true;
                    }
                    wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                    if (isVirtual) requestAnimationFrame((() => {
                        swiper.wrapperEl.style.scrollSnapType = "";
                        swiper._swiperImmediateVirtual = false;
                    }));
                } else {
                    if (!swiper.support.smoothScroll) {
                        animateCSSModeScroll({
                            swiper,
                            targetPosition: t,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: t,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            swiper.setTransition(speed);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            if (0 === speed) swiper.transitionEnd(runCallbacks, direction); else if (!swiper.animating) {
                swiper.animating = true;
                if (!swiper.onSlideToWrapperTransitionEnd) swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                    swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
                    swiper.onSlideToWrapperTransitionEnd = null;
                    delete swiper.onSlideToWrapperTransitionEnd;
                    swiper.transitionEnd(runCallbacks, direction);
                };
                swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
            }
            return true;
        }
        function slideToLoop(index, speed, runCallbacks, internal) {
            if (void 0 === index) index = 0;
            if (void 0 === speed) speed = this.params.speed;
            if (void 0 === runCallbacks) runCallbacks = true;
            const swiper = this;
            let newIndex = index;
            if (swiper.params.loop) newIndex += swiper.loopedSlides;
            return swiper.slideTo(newIndex, speed, runCallbacks, internal);
        }
        function slideNext(speed, runCallbacks, internal) {
            if (void 0 === speed) speed = this.params.speed;
            if (void 0 === runCallbacks) runCallbacks = true;
            const swiper = this;
            const {animating, enabled, params} = swiper;
            if (!enabled) return swiper;
            let perGroup = params.slidesPerGroup;
            if ("auto" === params.slidesPerView && 1 === params.slidesPerGroup && params.slidesPerGroupAuto) perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
            const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
            if (params.loop) {
                if (animating && params.loopPreventsSlide) return false;
                swiper.loopFix();
                swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
            }
            if (params.rewind && swiper.isEnd) return swiper.slideTo(0, speed, runCallbacks, internal);
            return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
        }
        function slidePrev(speed, runCallbacks, internal) {
            if (void 0 === speed) speed = this.params.speed;
            if (void 0 === runCallbacks) runCallbacks = true;
            const swiper = this;
            const {params, animating, snapGrid, slidesGrid, rtlTranslate, enabled} = swiper;
            if (!enabled) return swiper;
            if (params.loop) {
                if (animating && params.loopPreventsSlide) return false;
                swiper.loopFix();
                swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
            }
            const translate = rtlTranslate ? swiper.translate : -swiper.translate;
            function normalize(val) {
                if (val < 0) return -Math.floor(Math.abs(val));
                return Math.floor(val);
            }
            const normalizedTranslate = normalize(translate);
            const normalizedSnapGrid = snapGrid.map((val => normalize(val)));
            let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
            if ("undefined" === typeof prevSnap && params.cssMode) {
                let prevSnapIndex;
                snapGrid.forEach(((snap, snapIndex) => {
                    if (normalizedTranslate >= snap) prevSnapIndex = snapIndex;
                }));
                if ("undefined" !== typeof prevSnapIndex) prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
            }
            let prevIndex = 0;
            if ("undefined" !== typeof prevSnap) {
                prevIndex = slidesGrid.indexOf(prevSnap);
                if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
                if ("auto" === params.slidesPerView && 1 === params.slidesPerGroup && params.slidesPerGroupAuto) {
                    prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
                    prevIndex = Math.max(prevIndex, 0);
                }
            }
            if (params.rewind && swiper.isBeginning) {
                const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
                return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
            }
            return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
        }
        function slideReset(speed, runCallbacks, internal) {
            if (void 0 === speed) speed = this.params.speed;
            if (void 0 === runCallbacks) runCallbacks = true;
            const swiper = this;
            return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
        }
        function slideToClosest(speed, runCallbacks, internal, threshold) {
            if (void 0 === speed) speed = this.params.speed;
            if (void 0 === runCallbacks) runCallbacks = true;
            if (void 0 === threshold) threshold = .5;
            const swiper = this;
            let index = swiper.activeIndex;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
            const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            if (translate >= swiper.snapGrid[snapIndex]) {
                const currentSnap = swiper.snapGrid[snapIndex];
                const nextSnap = swiper.snapGrid[snapIndex + 1];
                if (translate - currentSnap > (nextSnap - currentSnap) * threshold) index += swiper.params.slidesPerGroup;
            } else {
                const prevSnap = swiper.snapGrid[snapIndex - 1];
                const currentSnap = swiper.snapGrid[snapIndex];
                if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) index -= swiper.params.slidesPerGroup;
            }
            index = Math.max(index, 0);
            index = Math.min(index, swiper.slidesGrid.length - 1);
            return swiper.slideTo(index, speed, runCallbacks, internal);
        }
        function slideToClickedSlide() {
            const swiper = this;
            const {params, $wrapperEl} = swiper;
            const slidesPerView = "auto" === params.slidesPerView ? swiper.slidesPerViewDynamic() : params.slidesPerView;
            let slideToIndex = swiper.clickedIndex;
            let realIndex;
            if (params.loop) {
                if (swiper.animating) return;
                realIndex = parseInt(dom(swiper.clickedSlide).attr("data-swiper-slide-index"), 10);
                if (params.centeredSlides) if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                    swiper.loopFix();
                    slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
                    utils_nextTick((() => {
                        swiper.slideTo(slideToIndex);
                    }));
                } else swiper.slideTo(slideToIndex); else if (slideToIndex > swiper.slides.length - slidesPerView) {
                    swiper.loopFix();
                    slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
                    utils_nextTick((() => {
                        swiper.slideTo(slideToIndex);
                    }));
                } else swiper.slideTo(slideToIndex);
            } else swiper.slideTo(slideToIndex);
        }
        const slide = {
            slideTo,
            slideToLoop,
            slideNext,
            slidePrev,
            slideReset,
            slideToClosest,
            slideToClickedSlide
        };
        function loopCreate() {
            const swiper = this;
            const document = ssr_window_esm_getDocument();
            const {params, $wrapperEl} = swiper;
            const $selector = $wrapperEl.children().length > 0 ? dom($wrapperEl.children()[0].parentNode) : $wrapperEl;
            $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
            let slides = $selector.children(`.${params.slideClass}`);
            if (params.loopFillGroupWithBlank) {
                const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
                if (blankSlidesNum !== params.slidesPerGroup) {
                    for (let i = 0; i < blankSlidesNum; i += 1) {
                        const blankNode = dom(document.createElement("div")).addClass(`${params.slideClass} ${params.slideBlankClass}`);
                        $selector.append(blankNode);
                    }
                    slides = $selector.children(`.${params.slideClass}`);
                }
            }
            if ("auto" === params.slidesPerView && !params.loopedSlides) params.loopedSlides = slides.length;
            swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
            swiper.loopedSlides += params.loopAdditionalSlides;
            if (swiper.loopedSlides > slides.length) swiper.loopedSlides = slides.length;
            const prependSlides = [];
            const appendSlides = [];
            slides.each(((el, index) => {
                const slide = dom(el);
                if (index < swiper.loopedSlides) appendSlides.push(el);
                if (index < slides.length && index >= slides.length - swiper.loopedSlides) prependSlides.push(el);
                slide.attr("data-swiper-slide-index", index);
            }));
            for (let i = 0; i < appendSlides.length; i += 1) $selector.append(dom(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
            for (let i = prependSlides.length - 1; i >= 0; i -= 1) $selector.prepend(dom(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
        }
        function loopFix() {
            const swiper = this;
            swiper.emit("beforeLoopFix");
            const {activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl} = swiper;
            let newIndex;
            swiper.allowSlidePrev = true;
            swiper.allowSlideNext = true;
            const snapTranslate = -snapGrid[activeIndex];
            const diff = snapTranslate - swiper.getTranslate();
            if (activeIndex < loopedSlides) {
                newIndex = slides.length - 3 * loopedSlides + activeIndex;
                newIndex += loopedSlides;
                const slideChanged = swiper.slideTo(newIndex, 0, false, true);
                if (slideChanged && 0 !== diff) swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            } else if (activeIndex >= slides.length - loopedSlides) {
                newIndex = -slides.length + activeIndex + loopedSlides;
                newIndex += loopedSlides;
                const slideChanged = swiper.slideTo(newIndex, 0, false, true);
                if (slideChanged && 0 !== diff) swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            }
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            swiper.emit("loopFix");
        }
        function loopDestroy() {
            const swiper = this;
            const {$wrapperEl, params, slides} = swiper;
            $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
            slides.removeAttr("data-swiper-slide-index");
        }
        const loop = {
            loopCreate,
            loopFix,
            loopDestroy
        };
        function setGrabCursor(moving) {
            const swiper = this;
            if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            const el = "container" === swiper.params.touchEventsTarget ? swiper.el : swiper.wrapperEl;
            el.style.cursor = "move";
            el.style.cursor = moving ? "-webkit-grabbing" : "-webkit-grab";
            el.style.cursor = moving ? "-moz-grabbin" : "-moz-grab";
            el.style.cursor = moving ? "grabbing" : "grab";
        }
        function unsetGrabCursor() {
            const swiper = this;
            if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            swiper["container" === swiper.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "";
        }
        const grab_cursor = {
            setGrabCursor,
            unsetGrabCursor
        };
        function closestElement(selector, base) {
            if (void 0 === base) base = this;
            function __closestFrom(el) {
                if (!el || el === ssr_window_esm_getDocument() || el === ssr_window_esm_getWindow()) return null;
                if (el.assignedSlot) el = el.assignedSlot;
                const found = el.closest(selector);
                return found || __closestFrom(el.getRootNode().host);
            }
            return __closestFrom(base);
        }
        function onTouchStart(event) {
            const swiper = this;
            const document = ssr_window_esm_getDocument();
            const window = ssr_window_esm_getWindow();
            const data = swiper.touchEventsData;
            const {params, touches, enabled} = swiper;
            if (!enabled) return;
            if (swiper.animating && params.preventInteractionOnTransition) return;
            if (!swiper.animating && params.cssMode && params.loop) swiper.loopFix();
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            let $targetEl = dom(e.target);
            if ("wrapper" === params.touchEventsTarget) if (!$targetEl.closest(swiper.wrapperEl).length) return;
            data.isTouchEvent = "touchstart" === e.type;
            if (!data.isTouchEvent && "which" in e && 3 === e.which) return;
            if (!data.isTouchEvent && "button" in e && e.button > 0) return;
            if (data.isTouched && data.isMoved) return;
            const swipingClassHasValue = !!params.noSwipingClass && "" !== params.noSwipingClass;
            if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) $targetEl = dom(event.path[0]);
            const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
            const isTargetShadow = !!(e.target && e.target.shadowRoot);
            if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
                swiper.allowClick = true;
                return;
            }
            if (params.swipeHandler) if (!$targetEl.closest(params.swipeHandler)[0]) return;
            touches.currentX = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX;
            touches.currentY = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY;
            const startX = touches.currentX;
            const startY = touches.currentY;
            const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
            const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
            if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) if ("prevent" === edgeSwipeDetection) event.preventDefault(); else return;
            Object.assign(data, {
                isTouched: true,
                isMoved: false,
                allowTouchCallbacks: true,
                isScrolling: void 0,
                startMoving: void 0
            });
            touches.startX = startX;
            touches.startY = startY;
            data.touchStartTime = utils_now();
            swiper.allowClick = true;
            swiper.updateSize();
            swiper.swipeDirection = void 0;
            if (params.threshold > 0) data.allowThresholdMove = false;
            if ("touchstart" !== e.type) {
                let preventDefault = true;
                if ($targetEl.is(data.focusableElements)) {
                    preventDefault = false;
                    if ("SELECT" === $targetEl[0].nodeName) data.isTouched = false;
                }
                if (document.activeElement && dom(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) document.activeElement.blur();
                const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
                if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) e.preventDefault();
            }
            if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) swiper.freeMode.onTouchStart();
            swiper.emit("touchStart", e);
        }
        function onTouchMove(event) {
            const document = ssr_window_esm_getDocument();
            const swiper = this;
            const data = swiper.touchEventsData;
            const {params, touches, rtlTranslate: rtl, enabled} = swiper;
            if (!enabled) return;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            if (!data.isTouched) {
                if (data.startMoving && data.isScrolling) swiper.emit("touchMoveOpposite", e);
                return;
            }
            if (data.isTouchEvent && "touchmove" !== e.type) return;
            const targetTouch = "touchmove" === e.type && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
            const pageX = "touchmove" === e.type ? targetTouch.pageX : e.pageX;
            const pageY = "touchmove" === e.type ? targetTouch.pageY : e.pageY;
            if (e.preventedByNestedSwiper) {
                touches.startX = pageX;
                touches.startY = pageY;
                return;
            }
            if (!swiper.allowTouchMove) {
                if (!dom(e.target).is(data.focusableElements)) swiper.allowClick = false;
                if (data.isTouched) {
                    Object.assign(touches, {
                        startX: pageX,
                        startY: pageY,
                        currentX: pageX,
                        currentY: pageY
                    });
                    data.touchStartTime = utils_now();
                }
                return;
            }
            if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) if (swiper.isVertical()) {
                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                    data.isTouched = false;
                    data.isMoved = false;
                    return;
                }
            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) return;
            if (data.isTouchEvent && document.activeElement) if (e.target === document.activeElement && dom(e.target).is(data.focusableElements)) {
                data.isMoved = true;
                swiper.allowClick = false;
                return;
            }
            if (data.allowTouchCallbacks) swiper.emit("touchMove", e);
            if (e.targetTouches && e.targetTouches.length > 1) return;
            touches.currentX = pageX;
            touches.currentY = pageY;
            const diffX = touches.currentX - touches.startX;
            const diffY = touches.currentY - touches.startY;
            if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
            if ("undefined" === typeof data.isScrolling) {
                let touchAngle;
                if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) data.isScrolling = false; else if (diffX * diffX + diffY * diffY >= 25) {
                    touchAngle = 180 * Math.atan2(Math.abs(diffY), Math.abs(diffX)) / Math.PI;
                    data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
                }
            }
            if (data.isScrolling) swiper.emit("touchMoveOpposite", e);
            if ("undefined" === typeof data.startMoving) if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) data.startMoving = true;
            if (data.isScrolling) {
                data.isTouched = false;
                return;
            }
            if (!data.startMoving) return;
            swiper.allowClick = false;
            if (!params.cssMode && e.cancelable) e.preventDefault();
            if (params.touchMoveStopPropagation && !params.nested) e.stopPropagation();
            if (!data.isMoved) {
                if (params.loop && !params.cssMode) swiper.loopFix();
                data.startTranslate = swiper.getTranslate();
                swiper.setTransition(0);
                if (swiper.animating) swiper.$wrapperEl.trigger("webkitTransitionEnd transitionend");
                data.allowMomentumBounce = false;
                if (params.grabCursor && (true === swiper.allowSlideNext || true === swiper.allowSlidePrev)) swiper.setGrabCursor(true);
                swiper.emit("sliderFirstMove", e);
            }
            swiper.emit("sliderMove", e);
            data.isMoved = true;
            let diff = swiper.isHorizontal() ? diffX : diffY;
            touches.diff = diff;
            diff *= params.touchRatio;
            if (rtl) diff = -diff;
            swiper.swipeDirection = diff > 0 ? "prev" : "next";
            data.currentTranslate = diff + data.startTranslate;
            let disableParentSwiper = true;
            let resistanceRatio = params.resistanceRatio;
            if (params.touchReleaseOnEdges) resistanceRatio = 0;
            if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
                disableParentSwiper = false;
                if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
            } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
                disableParentSwiper = false;
                if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
            }
            if (disableParentSwiper) e.preventedByNestedSwiper = true;
            if (!swiper.allowSlideNext && "next" === swiper.swipeDirection && data.currentTranslate < data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && "prev" === swiper.swipeDirection && data.currentTranslate > data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && !swiper.allowSlideNext) data.currentTranslate = data.startTranslate;
            if (params.threshold > 0) if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                if (!data.allowThresholdMove) {
                    data.allowThresholdMove = true;
                    touches.startX = touches.currentX;
                    touches.startY = touches.currentY;
                    data.currentTranslate = data.startTranslate;
                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                    return;
                }
            } else {
                data.currentTranslate = data.startTranslate;
                return;
            }
            if (!params.followFinger || params.cssMode) return;
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) swiper.freeMode.onTouchMove();
            swiper.updateProgress(data.currentTranslate);
            swiper.setTranslate(data.currentTranslate);
        }
        function onTouchEnd(event) {
            const swiper = this;
            const data = swiper.touchEventsData;
            const {params, touches, rtlTranslate: rtl, slidesGrid, enabled} = swiper;
            if (!enabled) return;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            if (data.allowTouchCallbacks) swiper.emit("touchEnd", e);
            data.allowTouchCallbacks = false;
            if (!data.isTouched) {
                if (data.isMoved && params.grabCursor) swiper.setGrabCursor(false);
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            if (params.grabCursor && data.isMoved && data.isTouched && (true === swiper.allowSlideNext || true === swiper.allowSlidePrev)) swiper.setGrabCursor(false);
            const touchEndTime = utils_now();
            const timeDiff = touchEndTime - data.touchStartTime;
            if (swiper.allowClick) {
                const pathTree = e.path || e.composedPath && e.composedPath();
                swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
                swiper.emit("tap click", e);
                if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) swiper.emit("doubleTap doubleClick", e);
            }
            data.lastClickTime = utils_now();
            utils_nextTick((() => {
                if (!swiper.destroyed) swiper.allowClick = true;
            }));
            if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || 0 === touches.diff || data.currentTranslate === data.startTranslate) {
                data.isTouched = false;
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;
            let currentPos;
            if (params.followFinger) currentPos = rtl ? swiper.translate : -swiper.translate; else currentPos = -data.currentTranslate;
            if (params.cssMode) return;
            if (swiper.params.freeMode && params.freeMode.enabled) {
                swiper.freeMode.onTouchEnd({
                    currentPos
                });
                return;
            }
            let stopIndex = 0;
            let groupSize = swiper.slidesSizesGrid[0];
            for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
                const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
                if ("undefined" !== typeof slidesGrid[i + increment]) {
                    if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                        stopIndex = i;
                        groupSize = slidesGrid[i + increment] - slidesGrid[i];
                    }
                } else if (currentPos >= slidesGrid[i]) {
                    stopIndex = i;
                    groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
                }
            }
            let rewindFirstIndex = null;
            let rewindLastIndex = null;
            if (params.rewind) if (swiper.isBeginning) rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1; else if (swiper.isEnd) rewindFirstIndex = 0;
            const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
            const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
            if (timeDiff > params.longSwipesMs) {
                if (!params.longSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                if ("next" === swiper.swipeDirection) if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);
                if ("prev" === swiper.swipeDirection) if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment); else if (null !== rewindLastIndex && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) swiper.slideTo(rewindLastIndex); else swiper.slideTo(stopIndex);
            } else {
                if (!params.shortSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
                if (!isNavButtonTarget) {
                    if ("next" === swiper.swipeDirection) swiper.slideTo(null !== rewindFirstIndex ? rewindFirstIndex : stopIndex + increment);
                    if ("prev" === swiper.swipeDirection) swiper.slideTo(null !== rewindLastIndex ? rewindLastIndex : stopIndex);
                } else if (e.target === swiper.navigation.nextEl) swiper.slideTo(stopIndex + increment); else swiper.slideTo(stopIndex);
            }
        }
        function onResize() {
            const swiper = this;
            const {params, el} = swiper;
            if (el && 0 === el.offsetWidth) return;
            if (params.breakpoints) swiper.setBreakpoint();
            const {allowSlideNext, allowSlidePrev, snapGrid} = swiper;
            swiper.allowSlideNext = true;
            swiper.allowSlidePrev = true;
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateSlidesClasses();
            if (("auto" === params.slidesPerView || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) swiper.slideTo(swiper.slides.length - 1, 0, false, true); else swiper.slideTo(swiper.activeIndex, 0, false, true);
            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) swiper.autoplay.run();
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
        }
        function onClick(e) {
            const swiper = this;
            if (!swiper.enabled) return;
            if (!swiper.allowClick) {
                if (swiper.params.preventClicks) e.preventDefault();
                if (swiper.params.preventClicksPropagation && swiper.animating) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            }
        }
        function onScroll() {
            const swiper = this;
            const {wrapperEl, rtlTranslate, enabled} = swiper;
            if (!enabled) return;
            swiper.previousTranslate = swiper.translate;
            if (swiper.isHorizontal()) swiper.translate = -wrapperEl.scrollLeft; else swiper.translate = -wrapperEl.scrollTop;
            if (-0 === swiper.translate) swiper.translate = 0;
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (0 === translatesDiff) newProgress = 0; else newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== swiper.progress) swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
            swiper.emit("setTranslate", swiper.translate, false);
        }
        let dummyEventAttached = false;
        function dummyEventListener() {}
        const events = (swiper, method) => {
            const document = ssr_window_esm_getDocument();
            const {params, touchEvents, el, wrapperEl, device, support} = swiper;
            const capture = !!params.nested;
            const domMethod = "on" === method ? "addEventListener" : "removeEventListener";
            const swiperMethod = method;
            if (!support.touch) {
                el[domMethod](touchEvents.start, swiper.onTouchStart, false);
                document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
                document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
            } else {
                const passiveListener = "touchstart" === touchEvents.start && support.passiveListener && params.passiveListeners ? {
                    passive: true,
                    capture: false
                } : false;
                el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
                el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
                    passive: false,
                    capture
                } : capture);
                el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);
                if (touchEvents.cancel) el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
            }
            if (params.preventClicks || params.preventClicksPropagation) el[domMethod]("click", swiper.onClick, true);
            if (params.cssMode) wrapperEl[domMethod]("scroll", swiper.onScroll);
            if (params.updateOnWindowResize) swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true); else swiper[swiperMethod]("observerUpdate", onResize, true);
        };
        function attachEvents() {
            const swiper = this;
            const document = ssr_window_esm_getDocument();
            const {params, support} = swiper;
            swiper.onTouchStart = onTouchStart.bind(swiper);
            swiper.onTouchMove = onTouchMove.bind(swiper);
            swiper.onTouchEnd = onTouchEnd.bind(swiper);
            if (params.cssMode) swiper.onScroll = onScroll.bind(swiper);
            swiper.onClick = onClick.bind(swiper);
            if (support.touch && !dummyEventAttached) {
                document.addEventListener("touchstart", dummyEventListener);
                dummyEventAttached = true;
            }
            events(swiper, "on");
        }
        function detachEvents() {
            const swiper = this;
            events(swiper, "off");
        }
        const core_events = {
            attachEvents,
            detachEvents
        };
        const isGridEnabled = (swiper, params) => swiper.grid && params.grid && params.grid.rows > 1;
        function setBreakpoint() {
            const swiper = this;
            const {activeIndex, initialized, loopedSlides = 0, params, $el} = swiper;
            const breakpoints = params.breakpoints;
            if (!breakpoints || breakpoints && 0 === Object.keys(breakpoints).length) return;
            const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
            if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
            const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
            const breakpointParams = breakpointOnlyParams || swiper.originalParams;
            const wasMultiRow = isGridEnabled(swiper, params);
            const isMultiRow = isGridEnabled(swiper, breakpointParams);
            const wasEnabled = params.enabled;
            if (wasMultiRow && !isMultiRow) {
                $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            } else if (!wasMultiRow && isMultiRow) {
                $el.addClass(`${params.containerModifierClass}grid`);
                if (breakpointParams.grid.fill && "column" === breakpointParams.grid.fill || !breakpointParams.grid.fill && "column" === params.grid.fill) $el.addClass(`${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            }
            const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
            const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
            if (directionChanged && initialized) swiper.changeDirection();
            utils_extend(swiper.params, breakpointParams);
            const isEnabled = swiper.params.enabled;
            Object.assign(swiper, {
                allowTouchMove: swiper.params.allowTouchMove,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev
            });
            if (wasEnabled && !isEnabled) swiper.disable(); else if (!wasEnabled && isEnabled) swiper.enable();
            swiper.currentBreakpoint = breakpoint;
            swiper.emit("_beforeBreakpoint", breakpointParams);
            if (needsReLoop && initialized) {
                swiper.loopDestroy();
                swiper.loopCreate();
                swiper.updateSlides();
                swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
            }
            swiper.emit("breakpoint", breakpointParams);
        }
        function getBreakpoint(breakpoints, base, containerEl) {
            if (void 0 === base) base = "window";
            if (!breakpoints || "container" === base && !containerEl) return;
            let breakpoint = false;
            const window = ssr_window_esm_getWindow();
            const currentHeight = "window" === base ? window.innerHeight : containerEl.clientHeight;
            const points = Object.keys(breakpoints).map((point => {
                if ("string" === typeof point && 0 === point.indexOf("@")) {
                    const minRatio = parseFloat(point.substr(1));
                    const value = currentHeight * minRatio;
                    return {
                        value,
                        point
                    };
                }
                return {
                    value: point,
                    point
                };
            }));
            points.sort(((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10)));
            for (let i = 0; i < points.length; i += 1) {
                const {point, value} = points[i];
                if ("window" === base) {
                    if (window.matchMedia(`(min-width: ${value}px)`).matches) breakpoint = point;
                } else if (value <= containerEl.clientWidth) breakpoint = point;
            }
            return breakpoint || "max";
        }
        const breakpoints = {
            setBreakpoint,
            getBreakpoint
        };
        function prepareClasses(entries, prefix) {
            const resultClasses = [];
            entries.forEach((item => {
                if ("object" === typeof item) Object.keys(item).forEach((classNames => {
                    if (item[classNames]) resultClasses.push(prefix + classNames);
                })); else if ("string" === typeof item) resultClasses.push(prefix + item);
            }));
            return resultClasses;
        }
        function addClasses() {
            const swiper = this;
            const {classNames, params, rtl, $el, device, support} = swiper;
            const suffixes = prepareClasses([ "initialized", params.direction, {
                "pointer-events": !support.touch
            }, {
                "free-mode": swiper.params.freeMode && params.freeMode.enabled
            }, {
                autoheight: params.autoHeight
            }, {
                rtl
            }, {
                grid: params.grid && params.grid.rows > 1
            }, {
                "grid-column": params.grid && params.grid.rows > 1 && "column" === params.grid.fill
            }, {
                android: device.android
            }, {
                ios: device.ios
            }, {
                "css-mode": params.cssMode
            }, {
                centered: params.cssMode && params.centeredSlides
            } ], params.containerModifierClass);
            classNames.push(...suffixes);
            $el.addClass([ ...classNames ].join(" "));
            swiper.emitContainerClasses();
        }
        function removeClasses_removeClasses() {
            const swiper = this;
            const {$el, classNames} = swiper;
            $el.removeClass(classNames.join(" "));
            swiper.emitContainerClasses();
        }
        const classes = {
            addClasses,
            removeClasses: removeClasses_removeClasses
        };
        function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
            const window = ssr_window_esm_getWindow();
            let image;
            function onReady() {
                if (callback) callback();
            }
            const isPicture = dom(imageEl).parent("picture")[0];
            if (!isPicture && (!imageEl.complete || !checkForComplete)) if (src) {
                image = new window.Image;
                image.onload = onReady;
                image.onerror = onReady;
                if (sizes) image.sizes = sizes;
                if (srcset) image.srcset = srcset;
                if (src) image.src = src;
            } else onReady(); else onReady();
        }
        function preloadImages() {
            const swiper = this;
            swiper.imagesToLoad = swiper.$el.find("img");
            function onReady() {
                if ("undefined" === typeof swiper || null === swiper || !swiper || swiper.destroyed) return;
                if (void 0 !== swiper.imagesLoaded) swiper.imagesLoaded += 1;
                if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
                    if (swiper.params.updateOnImagesReady) swiper.update();
                    swiper.emit("imagesReady");
                }
            }
            for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
                const imageEl = swiper.imagesToLoad[i];
                swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute("src"), imageEl.srcset || imageEl.getAttribute("srcset"), imageEl.sizes || imageEl.getAttribute("sizes"), true, onReady);
            }
        }
        const core_images = {
            loadImage,
            preloadImages
        };
        function checkOverflow() {
            const swiper = this;
            const {isLocked: wasLocked, params} = swiper;
            const {slidesOffsetBefore} = params;
            if (slidesOffsetBefore) {
                const lastSlideIndex = swiper.slides.length - 1;
                const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + 2 * slidesOffsetBefore;
                swiper.isLocked = swiper.size > lastSlideRightEdge;
            } else swiper.isLocked = 1 === swiper.snapGrid.length;
            if (true === params.allowSlideNext) swiper.allowSlideNext = !swiper.isLocked;
            if (true === params.allowSlidePrev) swiper.allowSlidePrev = !swiper.isLocked;
            if (wasLocked && wasLocked !== swiper.isLocked) swiper.isEnd = false;
            if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? "lock" : "unlock");
        }
        const check_overflow = {
            checkOverflow
        };
        const defaults = {
            init: true,
            direction: "horizontal",
            touchEventsTarget: "wrapper",
            initialSlide: 0,
            speed: 300,
            cssMode: false,
            updateOnWindowResize: true,
            resizeObserver: true,
            nested: false,
            createElements: false,
            enabled: true,
            focusableElements: "input, select, option, textarea, button, video, label",
            width: null,
            height: null,
            preventInteractionOnTransition: false,
            userAgent: null,
            url: null,
            edgeSwipeDetection: false,
            edgeSwipeThreshold: 20,
            autoHeight: false,
            setWrapperSize: false,
            virtualTranslate: false,
            effect: "slide",
            breakpoints: void 0,
            breakpointsBase: "window",
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerGroup: 1,
            slidesPerGroupSkip: 0,
            slidesPerGroupAuto: false,
            centeredSlides: false,
            centeredSlidesBounds: false,
            slidesOffsetBefore: 0,
            slidesOffsetAfter: 0,
            normalizeSlideIndex: true,
            centerInsufficientSlides: false,
            watchOverflow: true,
            roundLengths: false,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            longSwipes: true,
            longSwipesRatio: .5,
            longSwipesMs: 300,
            followFinger: true,
            allowTouchMove: true,
            threshold: 0,
            touchMoveStopPropagation: false,
            touchStartPreventDefault: true,
            touchStartForcePreventDefault: false,
            touchReleaseOnEdges: false,
            uniqueNavElements: true,
            resistance: true,
            resistanceRatio: .85,
            watchSlidesProgress: false,
            grabCursor: false,
            preventClicks: true,
            preventClicksPropagation: true,
            slideToClickedSlide: false,
            preloadImages: true,
            updateOnImagesReady: true,
            loop: false,
            loopAdditionalSlides: 0,
            loopedSlides: null,
            loopFillGroupWithBlank: false,
            loopPreventsSlide: true,
            rewind: false,
            allowSlidePrev: true,
            allowSlideNext: true,
            swipeHandler: null,
            noSwiping: true,
            noSwipingClass: "swiper-no-swiping",
            noSwipingSelector: null,
            passiveListeners: true,
            maxBackfaceHiddenSlides: 10,
            containerModifierClass: "swiper-",
            slideClass: "swiper-slide",
            slideBlankClass: "swiper-slide-invisible-blank",
            slideActiveClass: "swiper-slide-active",
            slideDuplicateActiveClass: "swiper-slide-duplicate-active",
            slideVisibleClass: "swiper-slide-visible",
            slideDuplicateClass: "swiper-slide-duplicate",
            slideNextClass: "swiper-slide-next",
            slideDuplicateNextClass: "swiper-slide-duplicate-next",
            slidePrevClass: "swiper-slide-prev",
            slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
            wrapperClass: "swiper-wrapper",
            runCallbacksOnInit: true,
            _emitClasses: false
        };
        function moduleExtendParams(params, allModulesParams) {
            return function extendParams(obj) {
                if (void 0 === obj) obj = {};
                const moduleParamName = Object.keys(obj)[0];
                const moduleParams = obj[moduleParamName];
                if ("object" !== typeof moduleParams || null === moduleParams) {
                    utils_extend(allModulesParams, obj);
                    return;
                }
                if ([ "navigation", "pagination", "scrollbar" ].indexOf(moduleParamName) >= 0 && true === params[moduleParamName]) params[moduleParamName] = {
                    auto: true
                };
                if (!(moduleParamName in params && "enabled" in moduleParams)) {
                    utils_extend(allModulesParams, obj);
                    return;
                }
                if (true === params[moduleParamName]) params[moduleParamName] = {
                    enabled: true
                };
                if ("object" === typeof params[moduleParamName] && !("enabled" in params[moduleParamName])) params[moduleParamName].enabled = true;
                if (!params[moduleParamName]) params[moduleParamName] = {
                    enabled: false
                };
                utils_extend(allModulesParams, obj);
            };
        }
        const prototypes = {
            eventsEmitter: events_emitter,
            update,
            translate,
            transition: core_transition,
            slide,
            loop,
            grabCursor: grab_cursor,
            events: core_events,
            breakpoints,
            checkOverflow: check_overflow,
            classes,
            images: core_images
        };
        const extendedDefaults = {};
        class core_Swiper {
            constructor() {
                let el;
                let params;
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                if (1 === args.length && args[0].constructor && "Object" === Object.prototype.toString.call(args[0]).slice(8, -1)) params = args[0]; else [el, params] = args;
                if (!params) params = {};
                params = utils_extend({}, params);
                if (el && !params.el) params.el = el;
                if (params.el && dom(params.el).length > 1) {
                    const swipers = [];
                    dom(params.el).each((containerEl => {
                        const newParams = utils_extend({}, params, {
                            el: containerEl
                        });
                        swipers.push(new core_Swiper(newParams));
                    }));
                    return swipers;
                }
                const swiper = this;
                swiper.__swiper__ = true;
                swiper.support = getSupport();
                swiper.device = getDevice({
                    userAgent: params.userAgent
                });
                swiper.browser = getBrowser();
                swiper.eventsListeners = {};
                swiper.eventsAnyListeners = [];
                swiper.modules = [ ...swiper.__modules__ ];
                if (params.modules && Array.isArray(params.modules)) swiper.modules.push(...params.modules);
                const allModulesParams = {};
                swiper.modules.forEach((mod => {
                    mod({
                        swiper,
                        extendParams: moduleExtendParams(params, allModulesParams),
                        on: swiper.on.bind(swiper),
                        once: swiper.once.bind(swiper),
                        off: swiper.off.bind(swiper),
                        emit: swiper.emit.bind(swiper)
                    });
                }));
                const swiperParams = utils_extend({}, defaults, allModulesParams);
                swiper.params = utils_extend({}, swiperParams, extendedDefaults, params);
                swiper.originalParams = utils_extend({}, swiper.params);
                swiper.passedParams = utils_extend({}, params);
                if (swiper.params && swiper.params.on) Object.keys(swiper.params.on).forEach((eventName => {
                    swiper.on(eventName, swiper.params.on[eventName]);
                }));
                if (swiper.params && swiper.params.onAny) swiper.onAny(swiper.params.onAny);
                swiper.$ = dom;
                Object.assign(swiper, {
                    enabled: swiper.params.enabled,
                    el,
                    classNames: [],
                    slides: dom(),
                    slidesGrid: [],
                    snapGrid: [],
                    slidesSizesGrid: [],
                    isHorizontal() {
                        return "horizontal" === swiper.params.direction;
                    },
                    isVertical() {
                        return "vertical" === swiper.params.direction;
                    },
                    activeIndex: 0,
                    realIndex: 0,
                    isBeginning: true,
                    isEnd: false,
                    translate: 0,
                    previousTranslate: 0,
                    progress: 0,
                    velocity: 0,
                    animating: false,
                    allowSlideNext: swiper.params.allowSlideNext,
                    allowSlidePrev: swiper.params.allowSlidePrev,
                    touchEvents: function touchEvents() {
                        const touch = [ "touchstart", "touchmove", "touchend", "touchcancel" ];
                        const desktop = [ "pointerdown", "pointermove", "pointerup" ];
                        swiper.touchEventsTouch = {
                            start: touch[0],
                            move: touch[1],
                            end: touch[2],
                            cancel: touch[3]
                        };
                        swiper.touchEventsDesktop = {
                            start: desktop[0],
                            move: desktop[1],
                            end: desktop[2]
                        };
                        return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
                    }(),
                    touchEventsData: {
                        isTouched: void 0,
                        isMoved: void 0,
                        allowTouchCallbacks: void 0,
                        touchStartTime: void 0,
                        isScrolling: void 0,
                        currentTranslate: void 0,
                        startTranslate: void 0,
                        allowThresholdMove: void 0,
                        focusableElements: swiper.params.focusableElements,
                        lastClickTime: utils_now(),
                        clickTimeout: void 0,
                        velocities: [],
                        allowMomentumBounce: void 0,
                        isTouchEvent: void 0,
                        startMoving: void 0
                    },
                    allowClick: true,
                    allowTouchMove: swiper.params.allowTouchMove,
                    touches: {
                        startX: 0,
                        startY: 0,
                        currentX: 0,
                        currentY: 0,
                        diff: 0
                    },
                    imagesToLoad: [],
                    imagesLoaded: 0
                });
                swiper.emit("_swiper");
                if (swiper.params.init) swiper.init();
                return swiper;
            }
            enable() {
                const swiper = this;
                if (swiper.enabled) return;
                swiper.enabled = true;
                if (swiper.params.grabCursor) swiper.setGrabCursor();
                swiper.emit("enable");
            }
            disable() {
                const swiper = this;
                if (!swiper.enabled) return;
                swiper.enabled = false;
                if (swiper.params.grabCursor) swiper.unsetGrabCursor();
                swiper.emit("disable");
            }
            setProgress(progress, speed) {
                const swiper = this;
                progress = Math.min(Math.max(progress, 0), 1);
                const min = swiper.minTranslate();
                const max = swiper.maxTranslate();
                const current = (max - min) * progress + min;
                swiper.translateTo(current, "undefined" === typeof speed ? 0 : speed);
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            emitContainerClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const cls = swiper.el.className.split(" ").filter((className => 0 === className.indexOf("swiper") || 0 === className.indexOf(swiper.params.containerModifierClass)));
                swiper.emit("_containerClasses", cls.join(" "));
            }
            getSlideClasses(slideEl) {
                const swiper = this;
                return slideEl.className.split(" ").filter((className => 0 === className.indexOf("swiper-slide") || 0 === className.indexOf(swiper.params.slideClass))).join(" ");
            }
            emitSlidesClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const updates = [];
                swiper.slides.each((slideEl => {
                    const classNames = swiper.getSlideClasses(slideEl);
                    updates.push({
                        slideEl,
                        classNames
                    });
                    swiper.emit("_slideClass", slideEl, classNames);
                }));
                swiper.emit("_slideClasses", updates);
            }
            slidesPerViewDynamic(view, exact) {
                if (void 0 === view) view = "current";
                if (void 0 === exact) exact = false;
                const swiper = this;
                const {params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex} = swiper;
                let spv = 1;
                if (params.centeredSlides) {
                    let slideSize = slides[activeIndex].swiperSlideSize;
                    let breakLoop;
                    for (let i = activeIndex + 1; i < slides.length; i += 1) if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                    for (let i = activeIndex - 1; i >= 0; i -= 1) if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                } else if ("current" === view) for (let i = activeIndex + 1; i < slides.length; i += 1) {
                    const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                    if (slideInView) spv += 1;
                } else for (let i = activeIndex - 1; i >= 0; i -= 1) {
                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                    if (slideInView) spv += 1;
                }
                return spv;
            }
            update() {
                const swiper = this;
                if (!swiper || swiper.destroyed) return;
                const {snapGrid, params} = swiper;
                if (params.breakpoints) swiper.setBreakpoint();
                swiper.updateSize();
                swiper.updateSlides();
                swiper.updateProgress();
                swiper.updateSlidesClasses();
                function setTranslate() {
                    const translateValue = swiper.rtlTranslate ? -1 * swiper.translate : swiper.translate;
                    const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                    swiper.setTranslate(newTranslate);
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                }
                let translated;
                if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
                    setTranslate();
                    if (swiper.params.autoHeight) swiper.updateAutoHeight();
                } else {
                    if (("auto" === swiper.params.slidesPerView || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true); else translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                    if (!translated) setTranslate();
                }
                if (params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
                swiper.emit("update");
            }
            changeDirection(newDirection, needUpdate) {
                if (void 0 === needUpdate) needUpdate = true;
                const swiper = this;
                const currentDirection = swiper.params.direction;
                if (!newDirection) newDirection = "horizontal" === currentDirection ? "vertical" : "horizontal";
                if (newDirection === currentDirection || "horizontal" !== newDirection && "vertical" !== newDirection) return swiper;
                swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
                swiper.emitContainerClasses();
                swiper.params.direction = newDirection;
                swiper.slides.each((slideEl => {
                    if ("vertical" === newDirection) slideEl.style.width = ""; else slideEl.style.height = "";
                }));
                swiper.emit("changeDirection");
                if (needUpdate) swiper.update();
                return swiper;
            }
            mount(el) {
                const swiper = this;
                if (swiper.mounted) return true;
                const $el = dom(el || swiper.params.el);
                el = $el[0];
                if (!el) return false;
                el.swiper = swiper;
                const getWrapperSelector = () => `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
                const getWrapper = () => {
                    if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                        const res = dom(el.shadowRoot.querySelector(getWrapperSelector()));
                        res.children = options => $el.children(options);
                        return res;
                    }
                    return $el.children(getWrapperSelector());
                };
                let $wrapperEl = getWrapper();
                if (0 === $wrapperEl.length && swiper.params.createElements) {
                    const document = ssr_window_esm_getDocument();
                    const wrapper = document.createElement("div");
                    $wrapperEl = dom(wrapper);
                    wrapper.className = swiper.params.wrapperClass;
                    $el.append(wrapper);
                    $el.children(`.${swiper.params.slideClass}`).each((slideEl => {
                        $wrapperEl.append(slideEl);
                    }));
                }
                Object.assign(swiper, {
                    $el,
                    el,
                    $wrapperEl,
                    wrapperEl: $wrapperEl[0],
                    mounted: true,
                    rtl: "rtl" === el.dir.toLowerCase() || "rtl" === $el.css("direction"),
                    rtlTranslate: "horizontal" === swiper.params.direction && ("rtl" === el.dir.toLowerCase() || "rtl" === $el.css("direction")),
                    wrongRTL: "-webkit-box" === $wrapperEl.css("display")
                });
                return true;
            }
            init(el) {
                const swiper = this;
                if (swiper.initialized) return swiper;
                const mounted = swiper.mount(el);
                if (false === mounted) return swiper;
                swiper.emit("beforeInit");
                if (swiper.params.breakpoints) swiper.setBreakpoint();
                swiper.addClasses();
                if (swiper.params.loop) swiper.loopCreate();
                swiper.updateSize();
                swiper.updateSlides();
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                if (swiper.params.grabCursor && swiper.enabled) swiper.setGrabCursor();
                if (swiper.params.preloadImages) swiper.preloadImages();
                if (swiper.params.loop) swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true); else swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
                swiper.attachEvents();
                swiper.initialized = true;
                swiper.emit("init");
                swiper.emit("afterInit");
                return swiper;
            }
            destroy(deleteInstance, cleanStyles) {
                if (void 0 === deleteInstance) deleteInstance = true;
                if (void 0 === cleanStyles) cleanStyles = true;
                const swiper = this;
                const {params, $el, $wrapperEl, slides} = swiper;
                if ("undefined" === typeof swiper.params || swiper.destroyed) return null;
                swiper.emit("beforeDestroy");
                swiper.initialized = false;
                swiper.detachEvents();
                if (params.loop) swiper.loopDestroy();
                if (cleanStyles) {
                    swiper.removeClasses();
                    $el.removeAttr("style");
                    $wrapperEl.removeAttr("style");
                    if (slides && slides.length) slides.removeClass([ params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass ].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index");
                }
                swiper.emit("destroy");
                Object.keys(swiper.eventsListeners).forEach((eventName => {
                    swiper.off(eventName);
                }));
                if (false !== deleteInstance) {
                    swiper.$el[0].swiper = null;
                    deleteProps(swiper);
                }
                swiper.destroyed = true;
                return null;
            }
            static extendDefaults(newDefaults) {
                utils_extend(extendedDefaults, newDefaults);
            }
            static get extendedDefaults() {
                return extendedDefaults;
            }
            static get defaults() {
                return defaults;
            }
            static installModule(mod) {
                if (!core_Swiper.prototype.__modules__) core_Swiper.prototype.__modules__ = [];
                const modules = core_Swiper.prototype.__modules__;
                if ("function" === typeof mod && modules.indexOf(mod) < 0) modules.push(mod);
            }
            static use(module) {
                if (Array.isArray(module)) {
                    module.forEach((m => core_Swiper.installModule(m)));
                    return core_Swiper;
                }
                core_Swiper.installModule(module);
                return core_Swiper;
            }
        }
        Object.keys(prototypes).forEach((prototypeGroup => {
            Object.keys(prototypes[prototypeGroup]).forEach((protoMethod => {
                core_Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
            }));
        }));
        core_Swiper.use([ Resize, Observer ]);
        const core = core_Swiper;
        function create_element_if_not_defined_createElementIfNotDefined(swiper, originalParams, params, checkProps) {
            const document = ssr_window_esm_getDocument();
            if (swiper.params.createElements) Object.keys(checkProps).forEach((key => {
                if (!params[key] && true === params.auto) {
                    let element = swiper.$el.children(`.${checkProps[key]}`)[0];
                    if (!element) {
                        element = document.createElement("div");
                        element.className = checkProps[key];
                        swiper.$el.append(element);
                    }
                    params[key] = element;
                    originalParams[key] = element;
                }
            }));
            return params;
        }
        function Navigation(_ref) {
            let {swiper, extendParams, on, emit} = _ref;
            extendParams({
                navigation: {
                    nextEl: null,
                    prevEl: null,
                    hideOnClick: false,
                    disabledClass: "swiper-button-disabled",
                    hiddenClass: "swiper-button-hidden",
                    lockClass: "swiper-button-lock"
                }
            });
            swiper.navigation = {
                nextEl: null,
                $nextEl: null,
                prevEl: null,
                $prevEl: null
            };
            function getEl(el) {
                let $el;
                if (el) {
                    $el = dom(el);
                    if (swiper.params.uniqueNavElements && "string" === typeof el && $el.length > 1 && 1 === swiper.$el.find(el).length) $el = swiper.$el.find(el);
                }
                return $el;
            }
            function toggleEl($el, disabled) {
                const params = swiper.params.navigation;
                if ($el && $el.length > 0) {
                    $el[disabled ? "addClass" : "removeClass"](params.disabledClass);
                    if ($el[0] && "BUTTON" === $el[0].tagName) $el[0].disabled = disabled;
                    if (swiper.params.watchOverflow && swiper.enabled) $el[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
                }
            }
            function update() {
                if (swiper.params.loop) return;
                const {$nextEl, $prevEl} = swiper.navigation;
                toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
                toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
            }
            function onPrevClick(e) {
                e.preventDefault();
                if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
                swiper.slidePrev();
            }
            function onNextClick(e) {
                e.preventDefault();
                if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
                swiper.slideNext();
            }
            function init() {
                const params = swiper.params.navigation;
                swiper.params.navigation = create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
                    nextEl: "swiper-button-next",
                    prevEl: "swiper-button-prev"
                });
                if (!(params.nextEl || params.prevEl)) return;
                const $nextEl = getEl(params.nextEl);
                const $prevEl = getEl(params.prevEl);
                if ($nextEl && $nextEl.length > 0) $nextEl.on("click", onNextClick);
                if ($prevEl && $prevEl.length > 0) $prevEl.on("click", onPrevClick);
                Object.assign(swiper.navigation, {
                    $nextEl,
                    nextEl: $nextEl && $nextEl[0],
                    $prevEl,
                    prevEl: $prevEl && $prevEl[0]
                });
                if (!swiper.enabled) {
                    if ($nextEl) $nextEl.addClass(params.lockClass);
                    if ($prevEl) $prevEl.addClass(params.lockClass);
                }
            }
            function destroy() {
                const {$nextEl, $prevEl} = swiper.navigation;
                if ($nextEl && $nextEl.length) {
                    $nextEl.off("click", onNextClick);
                    $nextEl.removeClass(swiper.params.navigation.disabledClass);
                }
                if ($prevEl && $prevEl.length) {
                    $prevEl.off("click", onPrevClick);
                    $prevEl.removeClass(swiper.params.navigation.disabledClass);
                }
            }
            on("init", (() => {
                init();
                update();
            }));
            on("toEdge fromEdge lock unlock", (() => {
                update();
            }));
            on("destroy", (() => {
                destroy();
            }));
            on("enable disable", (() => {
                const {$nextEl, $prevEl} = swiper.navigation;
                if ($nextEl) $nextEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
                if ($prevEl) $prevEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
            }));
            on("click", ((_s, e) => {
                const {$nextEl, $prevEl} = swiper.navigation;
                const targetEl = e.target;
                if (swiper.params.navigation.hideOnClick && !dom(targetEl).is($prevEl) && !dom(targetEl).is($nextEl)) {
                    if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
                    let isHidden;
                    if ($nextEl) isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass); else if ($prevEl) isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
                    if (true === isHidden) emit("navigationShow"); else emit("navigationHide");
                    if ($nextEl) $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
                    if ($prevEl) $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
                }
            }));
            Object.assign(swiper.navigation, {
                update,
                init,
                destroy
            });
        }
        function classes_to_selector_classesToSelector(classes) {
            if (void 0 === classes) classes = "";
            return `.${classes.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}`;
        }
        function Pagination(_ref) {
            let {swiper, extendParams, on, emit} = _ref;
            const pfx = "swiper-pagination";
            extendParams({
                pagination: {
                    el: null,
                    bulletElement: "span",
                    clickable: false,
                    hideOnClick: false,
                    renderBullet: null,
                    renderProgressbar: null,
                    renderFraction: null,
                    renderCustom: null,
                    progressbarOpposite: false,
                    type: "bullets",
                    dynamicBullets: false,
                    dynamicMainBullets: 1,
                    formatFractionCurrent: number => number,
                    formatFractionTotal: number => number,
                    bulletClass: `${pfx}-bullet`,
                    bulletActiveClass: `${pfx}-bullet-active`,
                    modifierClass: `${pfx}-`,
                    currentClass: `${pfx}-current`,
                    totalClass: `${pfx}-total`,
                    hiddenClass: `${pfx}-hidden`,
                    progressbarFillClass: `${pfx}-progressbar-fill`,
                    progressbarOppositeClass: `${pfx}-progressbar-opposite`,
                    clickableClass: `${pfx}-clickable`,
                    lockClass: `${pfx}-lock`,
                    horizontalClass: `${pfx}-horizontal`,
                    verticalClass: `${pfx}-vertical`
                }
            });
            swiper.pagination = {
                el: null,
                $el: null,
                bullets: []
            };
            let bulletSize;
            let dynamicBulletIndex = 0;
            function isPaginationDisabled() {
                return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || 0 === swiper.pagination.$el.length;
            }
            function setSideBullets($bulletEl, position) {
                const {bulletActiveClass} = swiper.params.pagination;
                $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
            }
            function update() {
                const rtl = swiper.rtl;
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
                const $el = swiper.pagination.$el;
                let current;
                const total = swiper.params.loop ? Math.ceil((slidesLength - 2 * swiper.loopedSlides) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                if (swiper.params.loop) {
                    current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
                    if (current > slidesLength - 1 - 2 * swiper.loopedSlides) current -= slidesLength - 2 * swiper.loopedSlides;
                    if (current > total - 1) current -= total;
                    if (current < 0 && "bullets" !== swiper.params.paginationType) current = total + current;
                } else if ("undefined" !== typeof swiper.snapIndex) current = swiper.snapIndex; else current = swiper.activeIndex || 0;
                if ("bullets" === params.type && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
                    const bullets = swiper.pagination.bullets;
                    let firstIndex;
                    let lastIndex;
                    let midIndex;
                    if (params.dynamicBullets) {
                        bulletSize = bullets.eq(0)[swiper.isHorizontal() ? "outerWidth" : "outerHeight"](true);
                        $el.css(swiper.isHorizontal() ? "width" : "height", `${bulletSize * (params.dynamicMainBullets + 4)}px`);
                        if (params.dynamicMainBullets > 1 && void 0 !== swiper.previousIndex) {
                            dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);
                            if (dynamicBulletIndex > params.dynamicMainBullets - 1) dynamicBulletIndex = params.dynamicMainBullets - 1; else if (dynamicBulletIndex < 0) dynamicBulletIndex = 0;
                        }
                        firstIndex = Math.max(current - dynamicBulletIndex, 0);
                        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                        midIndex = (lastIndex + firstIndex) / 2;
                    }
                    bullets.removeClass([ "", "-next", "-next-next", "-prev", "-prev-prev", "-main" ].map((suffix => `${params.bulletActiveClass}${suffix}`)).join(" "));
                    if ($el.length > 1) bullets.each((bullet => {
                        const $bullet = dom(bullet);
                        const bulletIndex = $bullet.index();
                        if (bulletIndex === current) $bullet.addClass(params.bulletActiveClass);
                        if (params.dynamicBullets) {
                            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) $bullet.addClass(`${params.bulletActiveClass}-main`);
                            if (bulletIndex === firstIndex) setSideBullets($bullet, "prev");
                            if (bulletIndex === lastIndex) setSideBullets($bullet, "next");
                        }
                    })); else {
                        const $bullet = bullets.eq(current);
                        const bulletIndex = $bullet.index();
                        $bullet.addClass(params.bulletActiveClass);
                        if (params.dynamicBullets) {
                            const $firstDisplayedBullet = bullets.eq(firstIndex);
                            const $lastDisplayedBullet = bullets.eq(lastIndex);
                            for (let i = firstIndex; i <= lastIndex; i += 1) bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
                            if (swiper.params.loop) if (bulletIndex >= bullets.length) {
                                for (let i = params.dynamicMainBullets; i >= 0; i -= 1) bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
                                bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
                            } else {
                                setSideBullets($firstDisplayedBullet, "prev");
                                setSideBullets($lastDisplayedBullet, "next");
                            } else {
                                setSideBullets($firstDisplayedBullet, "prev");
                                setSideBullets($lastDisplayedBullet, "next");
                            }
                        }
                    }
                    if (params.dynamicBullets) {
                        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
                        const offsetProp = rtl ? "right" : "left";
                        bullets.css(swiper.isHorizontal() ? offsetProp : "top", `${bulletsOffset}px`);
                    }
                }
                if ("fraction" === params.type) {
                    $el.find(classes_to_selector_classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
                    $el.find(classes_to_selector_classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
                }
                if ("progressbar" === params.type) {
                    let progressbarDirection;
                    if (params.progressbarOpposite) progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal"; else progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
                    const scale = (current + 1) / total;
                    let scaleX = 1;
                    let scaleY = 1;
                    if ("horizontal" === progressbarDirection) scaleX = scale; else scaleY = scale;
                    $el.find(classes_to_selector_classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
                }
                if ("custom" === params.type && params.renderCustom) {
                    $el.html(params.renderCustom(swiper, current + 1, total));
                    emit("paginationRender", $el[0]);
                } else emit("paginationUpdate", $el[0]);
                if (swiper.params.watchOverflow && swiper.enabled) $el[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
            }
            function render() {
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
                const $el = swiper.pagination.$el;
                let paginationHTML = "";
                if ("bullets" === params.type) {
                    let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - 2 * swiper.loopedSlides) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                    if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) numberOfBullets = slidesLength;
                    for (let i = 0; i < numberOfBullets; i += 1) if (params.renderBullet) paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass); else paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
                    $el.html(paginationHTML);
                    swiper.pagination.bullets = $el.find(classes_to_selector_classesToSelector(params.bulletClass));
                }
                if ("fraction" === params.type) {
                    if (params.renderFraction) paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass); else paginationHTML = `<span class="${params.currentClass}"></span>` + " / " + `<span class="${params.totalClass}"></span>`;
                    $el.html(paginationHTML);
                }
                if ("progressbar" === params.type) {
                    if (params.renderProgressbar) paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass); else paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
                    $el.html(paginationHTML);
                }
                if ("custom" !== params.type) emit("paginationRender", swiper.pagination.$el[0]);
            }
            function init() {
                swiper.params.pagination = create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
                    el: "swiper-pagination"
                });
                const params = swiper.params.pagination;
                if (!params.el) return;
                let $el = dom(params.el);
                if (0 === $el.length) return;
                if (swiper.params.uniqueNavElements && "string" === typeof params.el && $el.length > 1) {
                    $el = swiper.$el.find(params.el);
                    if ($el.length > 1) $el = $el.filter((el => {
                        if (dom(el).parents(".swiper")[0] !== swiper.el) return false;
                        return true;
                    }));
                }
                if ("bullets" === params.type && params.clickable) $el.addClass(params.clickableClass);
                $el.addClass(params.modifierClass + params.type);
                $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                if ("bullets" === params.type && params.dynamicBullets) {
                    $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
                    dynamicBulletIndex = 0;
                    if (params.dynamicMainBullets < 1) params.dynamicMainBullets = 1;
                }
                if ("progressbar" === params.type && params.progressbarOpposite) $el.addClass(params.progressbarOppositeClass);
                if (params.clickable) $el.on("click", classes_to_selector_classesToSelector(params.bulletClass), (function onClick(e) {
                    e.preventDefault();
                    let index = dom(this).index() * swiper.params.slidesPerGroup;
                    if (swiper.params.loop) index += swiper.loopedSlides;
                    swiper.slideTo(index);
                }));
                Object.assign(swiper.pagination, {
                    $el,
                    el: $el[0]
                });
                if (!swiper.enabled) $el.addClass(params.lockClass);
            }
            function destroy() {
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                const $el = swiper.pagination.$el;
                $el.removeClass(params.hiddenClass);
                $el.removeClass(params.modifierClass + params.type);
                $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
                if (params.clickable) $el.off("click", classes_to_selector_classesToSelector(params.bulletClass));
            }
            on("init", (() => {
                init();
                render();
                update();
            }));
            on("activeIndexChange", (() => {
                if (swiper.params.loop) update(); else if ("undefined" === typeof swiper.snapIndex) update();
            }));
            on("snapIndexChange", (() => {
                if (!swiper.params.loop) update();
            }));
            on("slidesLengthChange", (() => {
                if (swiper.params.loop) {
                    render();
                    update();
                }
            }));
            on("snapGridLengthChange", (() => {
                if (!swiper.params.loop) {
                    render();
                    update();
                }
            }));
            on("destroy", (() => {
                destroy();
            }));
            on("enable disable", (() => {
                const {$el} = swiper.pagination;
                if ($el) $el[swiper.enabled ? "removeClass" : "addClass"](swiper.params.pagination.lockClass);
            }));
            on("lock unlock", (() => {
                update();
            }));
            on("click", ((_s, e) => {
                const targetEl = e.target;
                const {$el} = swiper.pagination;
                if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el.length > 0 && !dom(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
                    if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
                    const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);
                    if (true === isHidden) emit("paginationShow"); else emit("paginationHide");
                    $el.toggleClass(swiper.params.pagination.hiddenClass);
                }
            }));
            Object.assign(swiper.pagination, {
                render,
                update,
                init,
                destroy
            });
        }
        function initSliders() {
            if (document.querySelector(".roomSwiper")) new core(".roomSwiper", {
                modules: [ Navigation, Pagination ],
                slidesPerView: 1,
                navigation: {
                    prevEl: ".prev",
                    nextEl: ".next"
                }
            });
            if (document.querySelector(".swiper-certificates")) new core(".swiper-certificates", {
                modules: [ Navigation, Pagination ],
                observer: true,
                observeParents: true,
                slidesPerView: 4,
                spaceBetween: 40,
                autoHeight: true,
                speed: 800,
                pagination: {
                    el: ".swiper-pagination",
                    clickable: true
                },
                navigation: {
                    prevEl: ".swiper-button-prev",
                    nextEl: ".swiper-button-next"
                },
                breakpoints: {
                    320: {
                        slidesPerView: 1,
                        spaceBetween: 20,
                        autoHeight: true
                    },
                    480: {
                        slidesPerView: 2,
                        spaceBetween: 20
                    },
                    768: {
                        slidesPerView: 3,
                        spaceBetween: 30
                    },
                    992: {
                        slidesPerView: 4,
                        spaceBetween: 30
                    },
                    1200: {
                        slidesPerView: 4,
                        spaceBetween: 40
                    }
                },
                on: {}
            });
            if (document.querySelector(".swiper-ad")) new core(".swiper-ad", {
                modules: [ Navigation ],
                observer: true,
                observeParents: true,
                spaceBetween: 20,
                navigation: {
                    prevEl: ".prev",
                    nextEl: ".next"
                }
            });
        }
        window.addEventListener("load", (function(e) {
            initSliders();
        }));
        let addWindowScrollEvent = false;
        setTimeout((() => {
            if (addWindowScrollEvent) {
                let windowScroll = new Event("windowScroll");
                window.addEventListener("scroll", (function(e) {
                    document.dispatchEvent(windowScroll);
                }));
            }
        }), 0);
        /*!
 * lightgallery | 2.4.0 | January 29th 2022
 * http://www.lightgalleryjs.com/
 * Copyright (c) 2020 Sachin Neravath;
 * @license GPLv3
 */
        /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
        var __assign = function() {
            __assign = Object.assign || function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return __assign.apply(this, arguments);
        };
        function __spreadArrays() {
            for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
            var r = Array(s), k = 0;
            for (i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, 
            k++) r[k] = a[j];
            return r;
        }
        var lGEvents = {
            afterAppendSlide: "lgAfterAppendSlide",
            init: "lgInit",
            hasVideo: "lgHasVideo",
            containerResize: "lgContainerResize",
            updateSlides: "lgUpdateSlides",
            afterAppendSubHtml: "lgAfterAppendSubHtml",
            beforeOpen: "lgBeforeOpen",
            afterOpen: "lgAfterOpen",
            slideItemLoad: "lgSlideItemLoad",
            beforeSlide: "lgBeforeSlide",
            afterSlide: "lgAfterSlide",
            posterClick: "lgPosterClick",
            dragStart: "lgDragStart",
            dragMove: "lgDragMove",
            dragEnd: "lgDragEnd",
            beforeNextSlide: "lgBeforeNextSlide",
            beforePrevSlide: "lgBeforePrevSlide",
            beforeClose: "lgBeforeClose",
            afterClose: "lgAfterClose",
            rotateLeft: "lgRotateLeft",
            rotateRight: "lgRotateRight",
            flipHorizontal: "lgFlipHorizontal",
            flipVertical: "lgFlipVertical",
            autoplay: "lgAutoplay",
            autoplayStart: "lgAutoplayStart",
            autoplayStop: "lgAutoplayStop"
        };
        var lightGalleryCoreSettings = {
            mode: "lg-slide",
            easing: "ease",
            speed: 400,
            licenseKey: "0000-0000-000-0000",
            height: "100%",
            width: "100%",
            addClass: "",
            startClass: "lg-start-zoom",
            backdropDuration: 300,
            container: "",
            startAnimationDuration: 400,
            zoomFromOrigin: true,
            hideBarsDelay: 0,
            showBarsAfter: 1e4,
            slideDelay: 0,
            supportLegacyBrowser: true,
            allowMediaOverlap: false,
            videoMaxSize: "1280-720",
            loadYouTubePoster: true,
            defaultCaptionHeight: 0,
            ariaLabelledby: "",
            ariaDescribedby: "",
            closable: true,
            swipeToClose: true,
            closeOnTap: true,
            showCloseIcon: true,
            showMaximizeIcon: false,
            loop: true,
            escKey: true,
            keyPress: true,
            controls: true,
            slideEndAnimation: true,
            hideControlOnEnd: false,
            mousewheel: false,
            getCaptionFromTitleOrAlt: true,
            appendSubHtmlTo: ".lg-sub-html",
            subHtmlSelectorRelative: false,
            preload: 2,
            numberOfSlideItemsInDom: 10,
            selector: "",
            selectWithin: "",
            nextHtml: "",
            prevHtml: "",
            index: 0,
            iframeWidth: "100%",
            iframeHeight: "100%",
            iframeMaxWidth: "100%",
            iframeMaxHeight: "100%",
            download: true,
            counter: true,
            appendCounterTo: ".lg-toolbar",
            swipeThreshold: 50,
            enableSwipe: true,
            enableDrag: true,
            dynamic: false,
            dynamicEl: [],
            extraProps: [],
            exThumbImage: "",
            isMobile: void 0,
            mobileSettings: {
                controls: false,
                showCloseIcon: false,
                download: false
            },
            plugins: [],
            strings: {
                closeGallery: "Close gallery",
                toggleMaximize: "Toggle maximize",
                previousSlide: "Previous slide",
                nextSlide: "Next slide",
                download: "Download",
                playVideo: "Play video"
            }
        };
        function initLgPolyfills() {
            (function() {
                if ("function" === typeof window.CustomEvent) return false;
                function CustomEvent(event, params) {
                    params = params || {
                        bubbles: false,
                        cancelable: false,
                        detail: null
                    };
                    var evt = document.createEvent("CustomEvent");
                    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
                    return evt;
                }
                window.CustomEvent = CustomEvent;
            })();
            (function() {
                if (!Element.prototype.matches) Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
            })();
        }
        var lgQuery = function() {
            function lgQuery(selector) {
                this.cssVenderPrefixes = [ "TransitionDuration", "TransitionTimingFunction", "Transform", "Transition" ];
                this.selector = this._getSelector(selector);
                this.firstElement = this._getFirstEl();
                return this;
            }
            lgQuery.generateUUID = function() {
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(c) {
                    var r = 16 * Math.random() | 0, v = "x" == c ? r : 3 & r | 8;
                    return v.toString(16);
                }));
            };
            lgQuery.prototype._getSelector = function(selector, context) {
                if (void 0 === context) context = document;
                if ("string" !== typeof selector) return selector;
                context = context || document;
                var fl = selector.substring(0, 1);
                if ("#" === fl) return context.querySelector(selector); else return context.querySelectorAll(selector);
            };
            lgQuery.prototype._each = function(func) {
                if (!this.selector) return this;
                if (void 0 !== this.selector.length) [].forEach.call(this.selector, func); else func(this.selector, 0);
                return this;
            };
            lgQuery.prototype._setCssVendorPrefix = function(el, cssProperty, value) {
                var property = cssProperty.replace(/-([a-z])/gi, (function(s, group1) {
                    return group1.toUpperCase();
                }));
                if (-1 !== this.cssVenderPrefixes.indexOf(property)) {
                    el.style[property.charAt(0).toLowerCase() + property.slice(1)] = value;
                    el.style["webkit" + property] = value;
                    el.style["moz" + property] = value;
                    el.style["ms" + property] = value;
                    el.style["o" + property] = value;
                } else el.style[property] = value;
            };
            lgQuery.prototype._getFirstEl = function() {
                if (this.selector && void 0 !== this.selector.length) return this.selector[0]; else return this.selector;
            };
            lgQuery.prototype.isEventMatched = function(event, eventName) {
                var eventNamespace = eventName.split(".");
                return event.split(".").filter((function(e) {
                    return e;
                })).every((function(e) {
                    return -1 !== eventNamespace.indexOf(e);
                }));
            };
            lgQuery.prototype.attr = function(attr, value) {
                if (void 0 === value) {
                    if (!this.firstElement) return "";
                    return this.firstElement.getAttribute(attr);
                }
                this._each((function(el) {
                    el.setAttribute(attr, value);
                }));
                return this;
            };
            lgQuery.prototype.find = function(selector) {
                return $LG(this._getSelector(selector, this.selector));
            };
            lgQuery.prototype.first = function() {
                if (this.selector && void 0 !== this.selector.length) return $LG(this.selector[0]); else return $LG(this.selector);
            };
            lgQuery.prototype.eq = function(index) {
                return $LG(this.selector[index]);
            };
            lgQuery.prototype.parent = function() {
                return $LG(this.selector.parentElement);
            };
            lgQuery.prototype.get = function() {
                return this._getFirstEl();
            };
            lgQuery.prototype.removeAttr = function(attributes) {
                var attrs = attributes.split(" ");
                this._each((function(el) {
                    attrs.forEach((function(attr) {
                        return el.removeAttribute(attr);
                    }));
                }));
                return this;
            };
            lgQuery.prototype.wrap = function(className) {
                if (!this.firstElement) return this;
                var wrapper = document.createElement("div");
                wrapper.className = className;
                this.firstElement.parentNode.insertBefore(wrapper, this.firstElement);
                this.firstElement.parentNode.removeChild(this.firstElement);
                wrapper.appendChild(this.firstElement);
                return this;
            };
            lgQuery.prototype.addClass = function(classNames) {
                if (void 0 === classNames) classNames = "";
                this._each((function(el) {
                    classNames.split(" ").forEach((function(className) {
                        if (className) el.classList.add(className);
                    }));
                }));
                return this;
            };
            lgQuery.prototype.removeClass = function(classNames) {
                this._each((function(el) {
                    classNames.split(" ").forEach((function(className) {
                        if (className) el.classList.remove(className);
                    }));
                }));
                return this;
            };
            lgQuery.prototype.hasClass = function(className) {
                if (!this.firstElement) return false;
                return this.firstElement.classList.contains(className);
            };
            lgQuery.prototype.hasAttribute = function(attribute) {
                if (!this.firstElement) return false;
                return this.firstElement.hasAttribute(attribute);
            };
            lgQuery.prototype.toggleClass = function(className) {
                if (!this.firstElement) return this;
                if (this.hasClass(className)) this.removeClass(className); else this.addClass(className);
                return this;
            };
            lgQuery.prototype.css = function(property, value) {
                var _this = this;
                this._each((function(el) {
                    _this._setCssVendorPrefix(el, property, value);
                }));
                return this;
            };
            lgQuery.prototype.on = function(events, listener) {
                var _this = this;
                if (!this.selector) return this;
                events.split(" ").forEach((function(event) {
                    if (!Array.isArray(lgQuery.eventListeners[event])) lgQuery.eventListeners[event] = [];
                    lgQuery.eventListeners[event].push(listener);
                    _this.selector.addEventListener(event.split(".")[0], listener);
                }));
                return this;
            };
            lgQuery.prototype.once = function(event, listener) {
                var _this = this;
                this.on(event, (function() {
                    _this.off(event);
                    listener(event);
                }));
                return this;
            };
            lgQuery.prototype.off = function(event) {
                var _this = this;
                if (!this.selector) return this;
                Object.keys(lgQuery.eventListeners).forEach((function(eventName) {
                    if (_this.isEventMatched(event, eventName)) {
                        lgQuery.eventListeners[eventName].forEach((function(listener) {
                            _this.selector.removeEventListener(eventName.split(".")[0], listener);
                        }));
                        lgQuery.eventListeners[eventName] = [];
                    }
                }));
                return this;
            };
            lgQuery.prototype.trigger = function(event, detail) {
                if (!this.firstElement) return this;
                var customEvent = new CustomEvent(event.split(".")[0], {
                    detail: detail || null
                });
                this.firstElement.dispatchEvent(customEvent);
                return this;
            };
            lgQuery.prototype.load = function(url) {
                var _this = this;
                fetch(url).then((function(res) {
                    return res.text();
                })).then((function(html) {
                    _this.selector.innerHTML = html;
                }));
                return this;
            };
            lgQuery.prototype.html = function(html) {
                if (void 0 === html) {
                    if (!this.firstElement) return "";
                    return this.firstElement.innerHTML;
                }
                this._each((function(el) {
                    el.innerHTML = html;
                }));
                return this;
            };
            lgQuery.prototype.append = function(html) {
                this._each((function(el) {
                    if ("string" === typeof html) el.insertAdjacentHTML("beforeend", html); else el.appendChild(html);
                }));
                return this;
            };
            lgQuery.prototype.prepend = function(html) {
                this._each((function(el) {
                    el.insertAdjacentHTML("afterbegin", html);
                }));
                return this;
            };
            lgQuery.prototype.remove = function() {
                this._each((function(el) {
                    el.parentNode.removeChild(el);
                }));
                return this;
            };
            lgQuery.prototype.empty = function() {
                this._each((function(el) {
                    el.innerHTML = "";
                }));
                return this;
            };
            lgQuery.prototype.scrollTop = function(scrollTop) {
                if (void 0 !== scrollTop) {
                    document.body.scrollTop = scrollTop;
                    document.documentElement.scrollTop = scrollTop;
                    return this;
                } else return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
            };
            lgQuery.prototype.scrollLeft = function(scrollLeft) {
                if (void 0 !== scrollLeft) {
                    document.body.scrollLeft = scrollLeft;
                    document.documentElement.scrollLeft = scrollLeft;
                    return this;
                } else return window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
            };
            lgQuery.prototype.offset = function() {
                if (!this.firstElement) return {
                    left: 0,
                    top: 0
                };
                var rect = this.firstElement.getBoundingClientRect();
                var bodyMarginLeft = $LG("body").style().marginLeft;
                return {
                    left: rect.left - parseFloat(bodyMarginLeft) + this.scrollLeft(),
                    top: rect.top + this.scrollTop()
                };
            };
            lgQuery.prototype.style = function() {
                if (!this.firstElement) return {};
                return this.firstElement.currentStyle || window.getComputedStyle(this.firstElement);
            };
            lgQuery.prototype.width = function() {
                var style = this.style();
                return this.firstElement.clientWidth - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight);
            };
            lgQuery.prototype.height = function() {
                var style = this.style();
                return this.firstElement.clientHeight - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom);
            };
            lgQuery.eventListeners = {};
            return lgQuery;
        }();
        function $LG(selector) {
            initLgPolyfills();
            return new lgQuery(selector);
        }
        var defaultDynamicOptions = [ "src", "sources", "subHtml", "subHtmlUrl", "html", "video", "poster", "slideName", "responsive", "srcset", "sizes", "iframe", "downloadUrl", "download", "width", "facebookShareUrl", "tweetText", "iframeTitle", "twitterShareUrl", "pinterestShareUrl", "pinterestText", "fbHtml", "disqusIdentifier", "disqusUrl" ];
        function convertToData(attr) {
            if ("href" === attr) return "src";
            attr = attr.replace("data-", "");
            attr = attr.charAt(0).toLowerCase() + attr.slice(1);
            attr = attr.replace(/-([a-z])/g, (function(g) {
                return g[1].toUpperCase();
            }));
            return attr;
        }
        var utils = {
            getSize: function(el, container, spacing, defaultLgSize) {
                if (void 0 === spacing) spacing = 0;
                var LGel = $LG(el);
                var lgSize = LGel.attr("data-lg-size") || defaultLgSize;
                if (!lgSize) return;
                var isResponsiveSizes = lgSize.split(",");
                if (isResponsiveSizes[1]) {
                    var wWidth = window.innerWidth;
                    for (var i = 0; i < isResponsiveSizes.length; i++) {
                        var size_1 = isResponsiveSizes[i];
                        var responsiveWidth = parseInt(size_1.split("-")[2], 10);
                        if (responsiveWidth > wWidth) {
                            lgSize = size_1;
                            break;
                        }
                        if (i === isResponsiveSizes.length - 1) lgSize = size_1;
                    }
                }
                var size = lgSize.split("-");
                var width = parseInt(size[0], 10);
                var height = parseInt(size[1], 10);
                var cWidth = container.width();
                var cHeight = container.height() - spacing;
                var maxWidth = Math.min(cWidth, width);
                var maxHeight = Math.min(cHeight, height);
                var ratio = Math.min(maxWidth / width, maxHeight / height);
                return {
                    width: width * ratio,
                    height: height * ratio
                };
            },
            getTransform: function(el, container, top, bottom, imageSize) {
                if (!imageSize) return;
                var LGel = $LG(el).find("img").first();
                if (!LGel.get()) return;
                var containerRect = container.get().getBoundingClientRect();
                var wWidth = containerRect.width;
                var wHeight = container.height() - (top + bottom);
                var elWidth = LGel.width();
                var elHeight = LGel.height();
                var elStyle = LGel.style();
                var x = (wWidth - elWidth) / 2 - LGel.offset().left + (parseFloat(elStyle.paddingLeft) || 0) + (parseFloat(elStyle.borderLeft) || 0) + $LG(window).scrollLeft() + containerRect.left;
                var y = (wHeight - elHeight) / 2 - LGel.offset().top + (parseFloat(elStyle.paddingTop) || 0) + (parseFloat(elStyle.borderTop) || 0) + $LG(window).scrollTop() + top;
                var scX = elWidth / imageSize.width;
                var scY = elHeight / imageSize.height;
                var transform = "translate3d(" + (x *= -1) + "px, " + (y *= -1) + "px, 0) scale3d(" + scX + ", " + scY + ", 1)";
                return transform;
            },
            getIframeMarkup: function(iframeWidth, iframeHeight, iframeMaxWidth, iframeMaxHeight, src, iframeTitle) {
                var title = iframeTitle ? 'title="' + iframeTitle + '"' : "";
                return '<div class="lg-video-cont lg-has-iframe" style="width:' + iframeWidth + "; max-width:" + iframeMaxWidth + "; height: " + iframeHeight + "; max-height:" + iframeMaxHeight + '">\n                    <iframe class="lg-object" frameborder="0" ' + title + ' src="' + src + '"  allowfullscreen="true"></iframe>\n                </div>';
            },
            getImgMarkup: function(index, src, altAttr, srcset, sizes, sources) {
                var srcsetAttr = srcset ? 'srcset="' + srcset + '"' : "";
                var sizesAttr = sizes ? 'sizes="' + sizes + '"' : "";
                var imgMarkup = "<img " + altAttr + " " + srcsetAttr + "  " + sizesAttr + ' class="lg-object lg-image" data-index="' + index + '" src="' + src + '" />';
                var sourceTag = "";
                if (sources) {
                    var sourceObj = "string" === typeof sources ? JSON.parse(sources) : sources;
                    sourceTag = sourceObj.map((function(source) {
                        var attrs = "";
                        Object.keys(source).forEach((function(key) {
                            attrs += " " + key + '="' + source[key] + '"';
                        }));
                        return "<source " + attrs + "></source>";
                    }));
                }
                return "" + sourceTag + imgMarkup;
            },
            getResponsiveSrc: function(srcItms) {
                var rsWidth = [];
                var rsSrc = [];
                var src = "";
                for (var i = 0; i < srcItms.length; i++) {
                    var _src = srcItms[i].split(" ");
                    if ("" === _src[0]) _src.splice(0, 1);
                    rsSrc.push(_src[0]);
                    rsWidth.push(_src[1]);
                }
                var wWidth = window.innerWidth;
                for (var j = 0; j < rsWidth.length; j++) if (parseInt(rsWidth[j], 10) > wWidth) {
                    src = rsSrc[j];
                    break;
                }
                return src;
            },
            isImageLoaded: function(img) {
                if (!img) return false;
                if (!img.complete) return false;
                if (0 === img.naturalWidth) return false;
                return true;
            },
            getVideoPosterMarkup: function(_poster, dummyImg, videoContStyle, playVideoString, _isVideo) {
                var videoClass = "";
                if (_isVideo && _isVideo.youtube) videoClass = "lg-has-youtube"; else if (_isVideo && _isVideo.vimeo) videoClass = "lg-has-vimeo"; else videoClass = "lg-has-html5";
                return '<div class="lg-video-cont ' + videoClass + '" style="' + videoContStyle + '">\n                <div class="lg-video-play-button">\n                <svg\n                    viewBox="0 0 20 20"\n                    preserveAspectRatio="xMidYMid"\n                    focusable="false"\n                    aria-labelledby="' + playVideoString + '"\n                    role="img"\n                    class="lg-video-play-icon"\n                >\n                    <title>' + playVideoString + '</title>\n                    <polygon class="lg-video-play-icon-inner" points="1,0 20,10 1,20"></polygon>\n                </svg>\n                <svg class="lg-video-play-icon-bg" viewBox="0 0 50 50" focusable="false">\n                    <circle cx="50%" cy="50%" r="20"></circle></svg>\n                <svg class="lg-video-play-icon-circle" viewBox="0 0 50 50" focusable="false">\n                    <circle cx="50%" cy="50%" r="20"></circle>\n                </svg>\n            </div>\n            ' + (dummyImg || "") + '\n            <img class="lg-object lg-video-poster" src="' + _poster + '" />\n        </div>';
            },
            getDynamicOptions: function(items, extraProps, getCaptionFromTitleOrAlt, exThumbImage) {
                var dynamicElements = [];
                var availableDynamicOptions = __spreadArrays(defaultDynamicOptions, extraProps);
                [].forEach.call(items, (function(item) {
                    var dynamicEl = {};
                    for (var i = 0; i < item.attributes.length; i++) {
                        var attr = item.attributes[i];
                        if (attr.specified) {
                            var dynamicAttr = convertToData(attr.name);
                            var label = "";
                            if (availableDynamicOptions.indexOf(dynamicAttr) > -1) label = dynamicAttr;
                            if (label) dynamicEl[label] = attr.value;
                        }
                    }
                    var currentItem = $LG(item);
                    var alt = currentItem.find("img").first().attr("alt");
                    var title = currentItem.attr("title");
                    var thumb = exThumbImage ? currentItem.attr(exThumbImage) : currentItem.find("img").first().attr("src");
                    dynamicEl.thumb = thumb;
                    if (getCaptionFromTitleOrAlt && !dynamicEl.subHtml) dynamicEl.subHtml = title || alt || "";
                    dynamicEl.alt = alt || title || "";
                    dynamicElements.push(dynamicEl);
                }));
                return dynamicElements;
            },
            isMobile: function() {
                return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            },
            isVideo: function(src, isHTML5VIdeo, index) {
                if (!src) if (isHTML5VIdeo) return {
                    html5: true
                }; else {
                    console.error("lightGallery :- data-src is not provided on slide item " + (index + 1) + ". Please make sure the selector property is properly configured. More info - https://www.lightgalleryjs.com/demos/html-markup/");
                    return;
                }
                var youtube = src.match(/\/\/(?:www\.)?youtu(?:\.be|be\.com|be-nocookie\.com)\/(?:watch\?v=|embed\/)?([a-z0-9\-\_\%]+)([\&|?][\S]*)*/i);
                var vimeo = src.match(/\/\/(?:www\.)?(?:player\.)?vimeo.com\/(?:video\/)?([0-9a-z\-_]+)(.*)?/i);
                var wistia = src.match(/https?:\/\/(.+)?(wistia\.com|wi\.st)\/(medias|embed)\/([0-9a-z\-_]+)(.*)/);
                if (youtube) return {
                    youtube
                }; else if (vimeo) return {
                    vimeo
                }; else if (wistia) return {
                    wistia
                };
            }
        };
        var lgId = 0;
        var LightGallery = function() {
            function LightGallery(element, options) {
                this.lgOpened = false;
                this.index = 0;
                this.plugins = [];
                this.lGalleryOn = false;
                this.lgBusy = false;
                this.currentItemsInDom = [];
                this.prevScrollTop = 0;
                this.isDummyImageRemoved = false;
                this.dragOrSwipeEnabled = false;
                this.mediaContainerPosition = {
                    top: 0,
                    bottom: 0
                };
                if (!element) return this;
                lgId++;
                this.lgId = lgId;
                this.el = element;
                this.LGel = $LG(element);
                this.generateSettings(options);
                this.buildModules();
                if (this.settings.dynamic && void 0 !== this.settings.dynamicEl && !Array.isArray(this.settings.dynamicEl)) throw "When using dynamic mode, you must also define dynamicEl as an Array.";
                this.galleryItems = this.getItems();
                this.normalizeSettings();
                this.init();
                this.validateLicense();
                return this;
            }
            LightGallery.prototype.generateSettings = function(options) {
                this.settings = __assign(__assign({}, lightGalleryCoreSettings), options);
                if (this.settings.isMobile && "function" === typeof this.settings.isMobile ? this.settings.isMobile() : utils.isMobile()) {
                    var mobileSettings = __assign(__assign({}, this.settings.mobileSettings), this.settings.mobileSettings);
                    this.settings = __assign(__assign({}, this.settings), mobileSettings);
                }
            };
            LightGallery.prototype.normalizeSettings = function() {
                if (this.settings.slideEndAnimation) this.settings.hideControlOnEnd = false;
                if (!this.settings.closable) this.settings.swipeToClose = false;
                this.zoomFromOrigin = this.settings.zoomFromOrigin;
                if (this.settings.dynamic) this.zoomFromOrigin = false;
                if (!this.settings.container) this.settings.container = document.body;
                this.settings.preload = Math.min(this.settings.preload, this.galleryItems.length);
            };
            LightGallery.prototype.init = function() {
                var _this = this;
                this.addSlideVideoInfo(this.galleryItems);
                this.buildStructure();
                this.LGel.trigger(lGEvents.init, {
                    instance: this
                });
                if (this.settings.keyPress) this.keyPress();
                setTimeout((function() {
                    _this.enableDrag();
                    _this.enableSwipe();
                    _this.triggerPosterClick();
                }), 50);
                this.arrow();
                if (this.settings.mousewheel) this.mousewheel();
                if (!this.settings.dynamic) this.openGalleryOnItemClick();
            };
            LightGallery.prototype.openGalleryOnItemClick = function() {
                var _this = this;
                var _loop_1 = function(index) {
                    var element = this_1.items[index];
                    var $element = $LG(element);
                    var uuid = lgQuery.generateUUID();
                    $element.attr("data-lg-id", uuid).on("click.lgcustom-item-" + uuid, (function(e) {
                        e.preventDefault();
                        var currentItemIndex = _this.settings.index || index;
                        _this.openGallery(currentItemIndex, element);
                    }));
                };
                var this_1 = this;
                for (var index = 0; index < this.items.length; index++) _loop_1(index);
            };
            LightGallery.prototype.buildModules = function() {
                var _this = this;
                this.settings.plugins.forEach((function(plugin) {
                    _this.plugins.push(new plugin(_this, $LG));
                }));
            };
            LightGallery.prototype.validateLicense = function() {
                if (!this.settings.licenseKey) console.error("Please provide a valid license key"); else if ("0000-0000-000-0000" === this.settings.licenseKey) console.warn("lightGallery: " + this.settings.licenseKey + " license key is not valid for production use");
            };
            LightGallery.prototype.getSlideItem = function(index) {
                return $LG(this.getSlideItemId(index));
            };
            LightGallery.prototype.getSlideItemId = function(index) {
                return "#lg-item-" + this.lgId + "-" + index;
            };
            LightGallery.prototype.getIdName = function(id) {
                return id + "-" + this.lgId;
            };
            LightGallery.prototype.getElementById = function(id) {
                return $LG("#" + this.getIdName(id));
            };
            LightGallery.prototype.manageSingleSlideClassName = function() {
                if (this.galleryItems.length < 2) this.outer.addClass("lg-single-item"); else this.outer.removeClass("lg-single-item");
            };
            LightGallery.prototype.buildStructure = function() {
                var _this = this;
                var container = this.$container && this.$container.get();
                if (container) return;
                var controls = "";
                var subHtmlCont = "";
                if (this.settings.controls) controls = '<button type="button" id="' + this.getIdName("lg-prev") + '" aria-label="' + this.settings.strings["previousSlide"] + '" class="lg-prev lg-icon"> ' + this.settings.prevHtml + ' </button>\n                <button type="button" id="' + this.getIdName("lg-next") + '" aria-label="' + this.settings.strings["nextSlide"] + '" class="lg-next lg-icon"> ' + this.settings.nextHtml + " </button>";
                if (".lg-item" !== this.settings.appendSubHtmlTo) subHtmlCont = '<div class="lg-sub-html" role="status" aria-live="polite"></div>';
                var addClasses = "";
                if (this.settings.allowMediaOverlap) addClasses += "lg-media-overlap ";
                var ariaLabelledby = this.settings.ariaLabelledby ? 'aria-labelledby="' + this.settings.ariaLabelledby + '"' : "";
                var ariaDescribedby = this.settings.ariaDescribedby ? 'aria-describedby="' + this.settings.ariaDescribedby + '"' : "";
                var containerClassName = "lg-container " + this.settings.addClass + " " + (document.body !== this.settings.container ? "lg-inline" : "");
                var closeIcon = this.settings.closable && this.settings.showCloseIcon ? '<button type="button" aria-label="' + this.settings.strings["closeGallery"] + '" id="' + this.getIdName("lg-close") + '" class="lg-close lg-icon"></button>' : "";
                var maximizeIcon = this.settings.showMaximizeIcon ? '<button type="button" aria-label="' + this.settings.strings["toggleMaximize"] + '" id="' + this.getIdName("lg-maximize") + '" class="lg-maximize lg-icon"></button>' : "";
                var template = '\n        <div class="' + containerClassName + '" id="' + this.getIdName("lg-container") + '" tabindex="-1" aria-modal="true" ' + ariaLabelledby + " " + ariaDescribedby + ' role="dialog"\n        >\n            <div id="' + this.getIdName("lg-backdrop") + '" class="lg-backdrop"></div>\n\n            <div id="' + this.getIdName("lg-outer") + '" class="lg-outer lg-use-css3 lg-css3 lg-hide-items ' + addClasses + ' ">\n\n              <div id="' + this.getIdName("lg-content") + '" class="lg-content">\n                <div id="' + this.getIdName("lg-inner") + '" class="lg-inner">\n                </div>\n                ' + controls + '\n              </div>\n                <div id="' + this.getIdName("lg-toolbar") + '" class="lg-toolbar lg-group">\n                    ' + maximizeIcon + "\n                    " + closeIcon + "\n                    </div>\n                    " + (".lg-outer" === this.settings.appendSubHtmlTo ? subHtmlCont : "") + '\n                <div id="' + this.getIdName("lg-components") + '" class="lg-components">\n                    ' + (".lg-sub-html" === this.settings.appendSubHtmlTo ? subHtmlCont : "") + "\n                </div>\n            </div>\n        </div>\n        ";
                $LG(this.settings.container).append(template);
                if (document.body !== this.settings.container) $LG(this.settings.container).css("position", "relative");
                this.outer = this.getElementById("lg-outer");
                this.$lgComponents = this.getElementById("lg-components");
                this.$backdrop = this.getElementById("lg-backdrop");
                this.$container = this.getElementById("lg-container");
                this.$inner = this.getElementById("lg-inner");
                this.$content = this.getElementById("lg-content");
                this.$toolbar = this.getElementById("lg-toolbar");
                this.$backdrop.css("transition-duration", this.settings.backdropDuration + "ms");
                var outerClassNames = this.settings.mode + " ";
                this.manageSingleSlideClassName();
                if (this.settings.enableDrag) outerClassNames += "lg-grab ";
                this.outer.addClass(outerClassNames);
                this.$inner.css("transition-timing-function", this.settings.easing);
                this.$inner.css("transition-duration", this.settings.speed + "ms");
                if (this.settings.download) this.$toolbar.append('<a id="' + this.getIdName("lg-download") + '" target="_blank" rel="noopener" aria-label="' + this.settings.strings["download"] + '" download class="lg-download lg-icon"></a>');
                this.counter();
                $LG(window).on("resize.lg.global" + this.lgId + " orientationchange.lg.global" + this.lgId, (function() {
                    _this.refreshOnResize();
                }));
                this.hideBars();
                this.manageCloseGallery();
                this.toggleMaximize();
                this.initModules();
            };
            LightGallery.prototype.refreshOnResize = function() {
                if (this.lgOpened) {
                    var currentGalleryItem = this.galleryItems[this.index];
                    var __slideVideoInfo = currentGalleryItem.__slideVideoInfo;
                    this.mediaContainerPosition = this.getMediaContainerPosition();
                    var _a = this.mediaContainerPosition, top_1 = _a.top, bottom = _a.bottom;
                    this.currentImageSize = utils.getSize(this.items[this.index], this.outer, top_1 + bottom, __slideVideoInfo && this.settings.videoMaxSize);
                    if (__slideVideoInfo) this.resizeVideoSlide(this.index, this.currentImageSize);
                    if (this.zoomFromOrigin && !this.isDummyImageRemoved) {
                        var imgStyle = this.getDummyImgStyles(this.currentImageSize);
                        this.outer.find(".lg-current .lg-dummy-img").first().attr("style", imgStyle);
                    }
                    this.LGel.trigger(lGEvents.containerResize);
                }
            };
            LightGallery.prototype.resizeVideoSlide = function(index, imageSize) {
                var lgVideoStyle = this.getVideoContStyle(imageSize);
                var currentSlide = this.getSlideItem(index);
                currentSlide.find(".lg-video-cont").attr("style", lgVideoStyle);
            };
            LightGallery.prototype.updateSlides = function(items, index) {
                if (this.index > items.length - 1) this.index = items.length - 1;
                if (1 === items.length) this.index = 0;
                if (!items.length) {
                    this.closeGallery();
                    return;
                }
                var currentSrc = this.galleryItems[index].src;
                this.galleryItems = items;
                this.updateControls();
                this.$inner.empty();
                this.currentItemsInDom = [];
                var _index = 0;
                this.galleryItems.some((function(galleryItem, itemIndex) {
                    if (galleryItem.src === currentSrc) {
                        _index = itemIndex;
                        return true;
                    }
                    return false;
                }));
                this.currentItemsInDom = this.organizeSlideItems(_index, -1);
                this.loadContent(_index, true);
                this.getSlideItem(_index).addClass("lg-current");
                this.index = _index;
                this.updateCurrentCounter(_index);
                this.LGel.trigger(lGEvents.updateSlides);
            };
            LightGallery.prototype.getItems = function() {
                this.items = [];
                if (!this.settings.dynamic) {
                    if ("this" === this.settings.selector) this.items.push(this.el); else if (this.settings.selector) if ("string" === typeof this.settings.selector) if (this.settings.selectWithin) {
                        var selectWithin = $LG(this.settings.selectWithin);
                        this.items = selectWithin.find(this.settings.selector).get();
                    } else this.items = this.el.querySelectorAll(this.settings.selector); else this.items = this.settings.selector; else this.items = this.el.children;
                    return utils.getDynamicOptions(this.items, this.settings.extraProps, this.settings.getCaptionFromTitleOrAlt, this.settings.exThumbImage);
                } else return this.settings.dynamicEl || [];
            };
            LightGallery.prototype.openGallery = function(index, element) {
                var _this = this;
                if (void 0 === index) index = this.settings.index;
                if (this.lgOpened) return;
                this.lgOpened = true;
                this.outer.get().focus();
                this.outer.removeClass("lg-hide-items");
                this.$container.addClass("lg-show");
                var itemsToBeInsertedToDom = this.getItemsToBeInsertedToDom(index, index);
                this.currentItemsInDom = itemsToBeInsertedToDom;
                var items = "";
                itemsToBeInsertedToDom.forEach((function(item) {
                    items = items + '<div id="' + item + '" class="lg-item"></div>';
                }));
                this.$inner.append(items);
                this.addHtml(index);
                var transform = "";
                this.mediaContainerPosition = this.getMediaContainerPosition();
                var _a = this.mediaContainerPosition, top = _a.top, bottom = _a.bottom;
                if (!this.settings.allowMediaOverlap) this.setMediaContainerPosition(top, bottom);
                var __slideVideoInfo = this.galleryItems[index].__slideVideoInfo;
                if (this.zoomFromOrigin && element) {
                    this.currentImageSize = utils.getSize(element, this.outer, top + bottom, __slideVideoInfo && this.settings.videoMaxSize);
                    transform = utils.getTransform(element, this.outer, top, bottom, this.currentImageSize);
                }
                if (!this.zoomFromOrigin || !transform) {
                    this.outer.addClass(this.settings.startClass);
                    this.getSlideItem(index).removeClass("lg-complete");
                }
                var timeout = this.settings.zoomFromOrigin ? 100 : this.settings.backdropDuration;
                setTimeout((function() {
                    _this.outer.addClass("lg-components-open");
                }), timeout);
                this.index = index;
                this.LGel.trigger(lGEvents.beforeOpen);
                this.getSlideItem(index).addClass("lg-current");
                this.lGalleryOn = false;
                this.prevScrollTop = $LG(window).scrollTop();
                setTimeout((function() {
                    if (_this.zoomFromOrigin && transform) {
                        var currentSlide_1 = _this.getSlideItem(index);
                        currentSlide_1.css("transform", transform);
                        setTimeout((function() {
                            currentSlide_1.addClass("lg-start-progress lg-start-end-progress").css("transition-duration", _this.settings.startAnimationDuration + "ms");
                            _this.outer.addClass("lg-zoom-from-image");
                        }));
                        setTimeout((function() {
                            currentSlide_1.css("transform", "translate3d(0, 0, 0)");
                        }), 100);
                    }
                    setTimeout((function() {
                        _this.$backdrop.addClass("in");
                        _this.$container.addClass("lg-show-in");
                    }), 10);
                    if (!_this.zoomFromOrigin || !transform) setTimeout((function() {
                        _this.outer.addClass("lg-visible");
                    }), _this.settings.backdropDuration);
                    _this.slide(index, false, false, false);
                    _this.LGel.trigger(lGEvents.afterOpen);
                }));
                if (document.body === this.settings.container) $LG("html").addClass("lg-on");
            };
            LightGallery.prototype.getMediaContainerPosition = function() {
                if (this.settings.allowMediaOverlap) return {
                    top: 0,
                    bottom: 0
                };
                var top = this.$toolbar.get().clientHeight || 0;
                var subHtml = this.outer.find(".lg-components .lg-sub-html").get();
                var captionHeight = this.settings.defaultCaptionHeight || subHtml && subHtml.clientHeight || 0;
                var thumbContainer = this.outer.find(".lg-thumb-outer").get();
                var thumbHeight = thumbContainer ? thumbContainer.clientHeight : 0;
                var bottom = thumbHeight + captionHeight;
                return {
                    top,
                    bottom
                };
            };
            LightGallery.prototype.setMediaContainerPosition = function(top, bottom) {
                if (void 0 === top) top = 0;
                if (void 0 === bottom) bottom = 0;
                this.$content.css("top", top + "px").css("bottom", bottom + "px");
            };
            LightGallery.prototype.hideBars = function() {
                var _this = this;
                setTimeout((function() {
                    _this.outer.removeClass("lg-hide-items");
                    if (_this.settings.hideBarsDelay > 0) {
                        _this.outer.on("mousemove.lg click.lg touchstart.lg", (function() {
                            _this.outer.removeClass("lg-hide-items");
                            clearTimeout(_this.hideBarTimeout);
                            _this.hideBarTimeout = setTimeout((function() {
                                _this.outer.addClass("lg-hide-items");
                            }), _this.settings.hideBarsDelay);
                        }));
                        _this.outer.trigger("mousemove.lg");
                    }
                }), this.settings.showBarsAfter);
            };
            LightGallery.prototype.initPictureFill = function($img) {
                if (this.settings.supportLegacyBrowser) try {
                    picturefill({
                        elements: [ $img.get() ]
                    });
                } catch (e) {
                    console.warn("lightGallery :- If you want srcset or picture tag to be supported for older browser please include picturefil javascript library in your document.");
                }
            };
            LightGallery.prototype.counter = function() {
                if (this.settings.counter) {
                    var counterHtml = '<div class="lg-counter" role="status" aria-live="polite">\n                <span id="' + this.getIdName("lg-counter-current") + '" class="lg-counter-current">' + (this.index + 1) + ' </span> /\n                <span id="' + this.getIdName("lg-counter-all") + '" class="lg-counter-all">' + this.galleryItems.length + " </span></div>";
                    this.outer.find(this.settings.appendCounterTo).append(counterHtml);
                }
            };
            LightGallery.prototype.addHtml = function(index) {
                var subHtml;
                var subHtmlUrl;
                if (this.galleryItems[index].subHtmlUrl) subHtmlUrl = this.galleryItems[index].subHtmlUrl; else subHtml = this.galleryItems[index].subHtml;
                if (!subHtmlUrl) if (subHtml) {
                    var fL = subHtml.substring(0, 1);
                    if ("." === fL || "#" === fL) if (this.settings.subHtmlSelectorRelative && !this.settings.dynamic) subHtml = $LG(this.items).eq(index).find(subHtml).first().html(); else subHtml = $LG(subHtml).first().html();
                } else subHtml = "";
                if (".lg-item" !== this.settings.appendSubHtmlTo) if (subHtmlUrl) this.outer.find(".lg-sub-html").load(subHtmlUrl); else this.outer.find(".lg-sub-html").html(subHtml); else {
                    var currentSlide = $LG(this.getSlideItemId(index));
                    if (subHtmlUrl) currentSlide.load(subHtmlUrl); else currentSlide.append('<div class="lg-sub-html">' + subHtml + "</div>");
                }
                if ("undefined" !== typeof subHtml && null !== subHtml) if ("" === subHtml) this.outer.find(this.settings.appendSubHtmlTo).addClass("lg-empty-html"); else this.outer.find(this.settings.appendSubHtmlTo).removeClass("lg-empty-html");
                this.LGel.trigger(lGEvents.afterAppendSubHtml, {
                    index
                });
            };
            LightGallery.prototype.preload = function(index) {
                for (var i = 1; i <= this.settings.preload; i++) {
                    if (i >= this.galleryItems.length - index) break;
                    this.loadContent(index + i, false);
                }
                for (var j = 1; j <= this.settings.preload; j++) {
                    if (index - j < 0) break;
                    this.loadContent(index - j, false);
                }
            };
            LightGallery.prototype.getDummyImgStyles = function(imageSize) {
                if (!imageSize) return "";
                return "width:" + imageSize.width + "px;\n                margin-left: -" + imageSize.width / 2 + "px;\n                margin-top: -" + imageSize.height / 2 + "px;\n                height:" + imageSize.height + "px";
            };
            LightGallery.prototype.getVideoContStyle = function(imageSize) {
                if (!imageSize) return "";
                return "width:" + imageSize.width + "px;\n                height:" + imageSize.height + "px";
            };
            LightGallery.prototype.getDummyImageContent = function($currentSlide, index, alt) {
                var $currentItem;
                if (!this.settings.dynamic) $currentItem = $LG(this.items).eq(index);
                if ($currentItem) {
                    var _dummyImgSrc = void 0;
                    if (!this.settings.exThumbImage) _dummyImgSrc = $currentItem.find("img").first().attr("src"); else _dummyImgSrc = $currentItem.attr(this.settings.exThumbImage);
                    if (!_dummyImgSrc) return "";
                    var imgStyle = this.getDummyImgStyles(this.currentImageSize);
                    var dummyImgContent = "<img " + alt + ' style="' + imgStyle + '" class="lg-dummy-img" src="' + _dummyImgSrc + '" />';
                    $currentSlide.addClass("lg-first-slide");
                    this.outer.addClass("lg-first-slide-loading");
                    return dummyImgContent;
                }
                return "";
            };
            LightGallery.prototype.setImgMarkup = function(src, $currentSlide, index) {
                var currentGalleryItem = this.galleryItems[index];
                var alt = currentGalleryItem.alt, srcset = currentGalleryItem.srcset, sizes = currentGalleryItem.sizes, sources = currentGalleryItem.sources;
                var imgContent = "";
                var altAttr = alt ? 'alt="' + alt + '"' : "";
                if (this.isFirstSlideWithZoomAnimation()) imgContent = this.getDummyImageContent($currentSlide, index, altAttr); else imgContent = utils.getImgMarkup(index, src, altAttr, srcset, sizes, sources);
                var imgMarkup = '<picture class="lg-img-wrap"> ' + imgContent + "</picture>";
                $currentSlide.prepend(imgMarkup);
            };
            LightGallery.prototype.onSlideObjectLoad = function($slide, isHTML5VideoWithoutPoster, onLoad, onError) {
                var mediaObject = $slide.find(".lg-object").first();
                if (utils.isImageLoaded(mediaObject.get()) || isHTML5VideoWithoutPoster) onLoad(); else {
                    mediaObject.on("load.lg error.lg", (function() {
                        onLoad && onLoad();
                    }));
                    mediaObject.on("error.lg", (function() {
                        onError && onError();
                    }));
                }
            };
            LightGallery.prototype.onLgObjectLoad = function(currentSlide, index, delay, speed, isFirstSlide, isHTML5VideoWithoutPoster) {
                var _this = this;
                this.onSlideObjectLoad(currentSlide, isHTML5VideoWithoutPoster, (function() {
                    _this.triggerSlideItemLoad(currentSlide, index, delay, speed, isFirstSlide);
                }), (function() {
                    currentSlide.addClass("lg-complete lg-complete_");
                    currentSlide.html('<span class="lg-error-msg">Oops... Failed to load content...</span>');
                }));
            };
            LightGallery.prototype.triggerSlideItemLoad = function($currentSlide, index, delay, speed, isFirstSlide) {
                var _this = this;
                var currentGalleryItem = this.galleryItems[index];
                var _speed = isFirstSlide && "video" === this.getSlideType(currentGalleryItem) && !currentGalleryItem.poster ? speed : 0;
                setTimeout((function() {
                    $currentSlide.addClass("lg-complete lg-complete_");
                    _this.LGel.trigger(lGEvents.slideItemLoad, {
                        index,
                        delay: delay || 0,
                        isFirstSlide
                    });
                }), _speed);
            };
            LightGallery.prototype.isFirstSlideWithZoomAnimation = function() {
                return !!(!this.lGalleryOn && this.zoomFromOrigin && this.currentImageSize);
            };
            LightGallery.prototype.addSlideVideoInfo = function(items) {
                var _this = this;
                items.forEach((function(element, index) {
                    element.__slideVideoInfo = utils.isVideo(element.src, !!element.video, index);
                    if (element.__slideVideoInfo && _this.settings.loadYouTubePoster && !element.poster && element.__slideVideoInfo.youtube) element.poster = "//img.youtube.com/vi/" + element.__slideVideoInfo.youtube[1] + "/maxresdefault.jpg";
                }));
            };
            LightGallery.prototype.loadContent = function(index, rec) {
                var _this = this;
                var currentGalleryItem = this.galleryItems[index];
                var $currentSlide = $LG(this.getSlideItemId(index));
                var poster = currentGalleryItem.poster, srcset = currentGalleryItem.srcset, sizes = currentGalleryItem.sizes, sources = currentGalleryItem.sources;
                var src = currentGalleryItem.src;
                var video = currentGalleryItem.video;
                var _html5Video = video && "string" === typeof video ? JSON.parse(video) : video;
                if (currentGalleryItem.responsive) {
                    var srcDyItms = currentGalleryItem.responsive.split(",");
                    src = utils.getResponsiveSrc(srcDyItms) || src;
                }
                var videoInfo = currentGalleryItem.__slideVideoInfo;
                var lgVideoStyle = "";
                var iframe = !!currentGalleryItem.iframe;
                var isFirstSlide = !this.lGalleryOn;
                var delay = 0;
                if (isFirstSlide) if (this.zoomFromOrigin && this.currentImageSize) delay = this.settings.startAnimationDuration + 10; else delay = this.settings.backdropDuration + 10;
                if (!$currentSlide.hasClass("lg-loaded")) {
                    if (videoInfo) {
                        var _a = this.mediaContainerPosition, top_2 = _a.top, bottom = _a.bottom;
                        var videoSize = utils.getSize(this.items[index], this.outer, top_2 + bottom, videoInfo && this.settings.videoMaxSize);
                        lgVideoStyle = this.getVideoContStyle(videoSize);
                    }
                    if (iframe) {
                        var markup = utils.getIframeMarkup(this.settings.iframeWidth, this.settings.iframeHeight, this.settings.iframeMaxWidth, this.settings.iframeMaxHeight, src, currentGalleryItem.iframeTitle);
                        $currentSlide.prepend(markup);
                    } else if (poster) {
                        var dummyImg = "";
                        var hasStartAnimation = isFirstSlide && this.zoomFromOrigin && this.currentImageSize;
                        if (hasStartAnimation) dummyImg = this.getDummyImageContent($currentSlide, index, "");
                        markup = utils.getVideoPosterMarkup(poster, dummyImg || "", lgVideoStyle, this.settings.strings["playVideo"], videoInfo);
                        $currentSlide.prepend(markup);
                    } else if (videoInfo) {
                        markup = '<div class="lg-video-cont " style="' + lgVideoStyle + '"></div>';
                        $currentSlide.prepend(markup);
                    } else {
                        this.setImgMarkup(src, $currentSlide, index);
                        if (srcset || sources) {
                            var $img = $currentSlide.find(".lg-object");
                            this.initPictureFill($img);
                        }
                    }
                    if (poster || videoInfo) this.LGel.trigger(lGEvents.hasVideo, {
                        index,
                        src,
                        html5Video: _html5Video,
                        hasPoster: !!poster
                    });
                    this.LGel.trigger(lGEvents.afterAppendSlide, {
                        index
                    });
                    if (this.lGalleryOn && ".lg-item" === this.settings.appendSubHtmlTo) this.addHtml(index);
                }
                var _speed = 0;
                if (delay && !$LG(document.body).hasClass("lg-from-hash")) _speed = delay;
                if (this.isFirstSlideWithZoomAnimation()) {
                    setTimeout((function() {
                        $currentSlide.removeClass("lg-start-end-progress lg-start-progress").removeAttr("style");
                    }), this.settings.startAnimationDuration + 100);
                    if (!$currentSlide.hasClass("lg-loaded")) setTimeout((function() {
                        if ("image" === _this.getSlideType(currentGalleryItem)) {
                            $currentSlide.find(".lg-img-wrap").append(utils.getImgMarkup(index, src, "", srcset, sizes, currentGalleryItem.sources));
                            if (srcset || sources) {
                                var $img = $currentSlide.find(".lg-object");
                                _this.initPictureFill($img);
                            }
                        }
                        if ("image" === _this.getSlideType(currentGalleryItem) || "video" === _this.getSlideType(currentGalleryItem) && poster) {
                            _this.onLgObjectLoad($currentSlide, index, delay, _speed, true, false);
                            _this.onSlideObjectLoad($currentSlide, !!(videoInfo && videoInfo.html5 && !poster), (function() {
                                _this.loadContentOnFirstSlideLoad(index, $currentSlide, _speed);
                            }), (function() {
                                _this.loadContentOnFirstSlideLoad(index, $currentSlide, _speed);
                            }));
                        }
                    }), this.settings.startAnimationDuration + 100);
                }
                $currentSlide.addClass("lg-loaded");
                if (!this.isFirstSlideWithZoomAnimation() || "video" === this.getSlideType(currentGalleryItem) && !poster) this.onLgObjectLoad($currentSlide, index, delay, _speed, isFirstSlide, !!(videoInfo && videoInfo.html5 && !poster));
                if ((!this.zoomFromOrigin || !this.currentImageSize) && $currentSlide.hasClass("lg-complete_") && !this.lGalleryOn) setTimeout((function() {
                    $currentSlide.addClass("lg-complete");
                }), this.settings.backdropDuration);
                this.lGalleryOn = true;
                if (true === rec) if (!$currentSlide.hasClass("lg-complete_")) $currentSlide.find(".lg-object").first().on("load.lg error.lg", (function() {
                    _this.preload(index);
                })); else this.preload(index);
            };
            LightGallery.prototype.loadContentOnFirstSlideLoad = function(index, $currentSlide, speed) {
                var _this = this;
                setTimeout((function() {
                    $currentSlide.find(".lg-dummy-img").remove();
                    $currentSlide.removeClass("lg-first-slide");
                    _this.outer.removeClass("lg-first-slide-loading");
                    _this.isDummyImageRemoved = true;
                    _this.preload(index);
                }), speed + 300);
            };
            LightGallery.prototype.getItemsToBeInsertedToDom = function(index, prevIndex, numberOfItems) {
                var _this = this;
                if (void 0 === numberOfItems) numberOfItems = 0;
                var itemsToBeInsertedToDom = [];
                var possibleNumberOfItems = Math.max(numberOfItems, 3);
                possibleNumberOfItems = Math.min(possibleNumberOfItems, this.galleryItems.length);
                var prevIndexItem = "lg-item-" + this.lgId + "-" + prevIndex;
                if (this.galleryItems.length <= 3) {
                    this.galleryItems.forEach((function(_element, index) {
                        itemsToBeInsertedToDom.push("lg-item-" + _this.lgId + "-" + index);
                    }));
                    return itemsToBeInsertedToDom;
                }
                if (index < (this.galleryItems.length - 1) / 2) {
                    for (var idx = index; idx > index - possibleNumberOfItems / 2 && idx >= 0; idx--) itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + idx);
                    var numberOfExistingItems = itemsToBeInsertedToDom.length;
                    for (idx = 0; idx < possibleNumberOfItems - numberOfExistingItems; idx++) itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + (index + idx + 1));
                } else {
                    for (idx = index; idx <= this.galleryItems.length - 1 && idx < index + possibleNumberOfItems / 2; idx++) itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + idx);
                    numberOfExistingItems = itemsToBeInsertedToDom.length;
                    for (idx = 0; idx < possibleNumberOfItems - numberOfExistingItems; idx++) itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + (index - idx - 1));
                }
                if (this.settings.loop) if (index === this.galleryItems.length - 1) itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + 0); else if (0 === index) itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + (this.galleryItems.length - 1));
                if (-1 === itemsToBeInsertedToDom.indexOf(prevIndexItem)) itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + prevIndex);
                return itemsToBeInsertedToDom;
            };
            LightGallery.prototype.organizeSlideItems = function(index, prevIndex) {
                var _this = this;
                var itemsToBeInsertedToDom = this.getItemsToBeInsertedToDom(index, prevIndex, this.settings.numberOfSlideItemsInDom);
                itemsToBeInsertedToDom.forEach((function(item) {
                    if (-1 === _this.currentItemsInDom.indexOf(item)) _this.$inner.append('<div id="' + item + '" class="lg-item"></div>');
                }));
                this.currentItemsInDom.forEach((function(item) {
                    if (-1 === itemsToBeInsertedToDom.indexOf(item)) $LG("#" + item).remove();
                }));
                return itemsToBeInsertedToDom;
            };
            LightGallery.prototype.getPreviousSlideIndex = function() {
                var prevIndex = 0;
                try {
                    var currentItemId = this.outer.find(".lg-current").first().attr("id");
                    prevIndex = parseInt(currentItemId.split("-")[3]) || 0;
                } catch (error) {
                    prevIndex = 0;
                }
                return prevIndex;
            };
            LightGallery.prototype.setDownloadValue = function(index) {
                if (this.settings.download) {
                    var currentGalleryItem = this.galleryItems[index];
                    var hideDownloadBtn = false === currentGalleryItem.downloadUrl || "false" === currentGalleryItem.downloadUrl;
                    if (hideDownloadBtn) this.outer.addClass("lg-hide-download"); else {
                        var $download = this.getElementById("lg-download");
                        this.outer.removeClass("lg-hide-download");
                        $download.attr("href", currentGalleryItem.downloadUrl || currentGalleryItem.src);
                        if (currentGalleryItem.download) $download.attr("download", currentGalleryItem.download);
                    }
                }
            };
            LightGallery.prototype.makeSlideAnimation = function(direction, currentSlideItem, previousSlideItem) {
                var _this = this;
                if (this.lGalleryOn) previousSlideItem.addClass("lg-slide-progress");
                setTimeout((function() {
                    _this.outer.addClass("lg-no-trans");
                    _this.outer.find(".lg-item").removeClass("lg-prev-slide lg-next-slide");
                    if ("prev" === direction) {
                        currentSlideItem.addClass("lg-prev-slide");
                        previousSlideItem.addClass("lg-next-slide");
                    } else {
                        currentSlideItem.addClass("lg-next-slide");
                        previousSlideItem.addClass("lg-prev-slide");
                    }
                    setTimeout((function() {
                        _this.outer.find(".lg-item").removeClass("lg-current");
                        currentSlideItem.addClass("lg-current");
                        _this.outer.removeClass("lg-no-trans");
                    }), 50);
                }), this.lGalleryOn ? this.settings.slideDelay : 0);
            };
            LightGallery.prototype.slide = function(index, fromTouch, fromThumb, direction) {
                var _this = this;
                var prevIndex = this.getPreviousSlideIndex();
                this.currentItemsInDom = this.organizeSlideItems(index, prevIndex);
                if (this.lGalleryOn && prevIndex === index) return;
                var numberOfGalleryItems = this.galleryItems.length;
                if (!this.lgBusy) {
                    if (this.settings.counter) this.updateCurrentCounter(index);
                    var currentSlideItem = this.getSlideItem(index);
                    var previousSlideItem_1 = this.getSlideItem(prevIndex);
                    var currentGalleryItem = this.galleryItems[index];
                    var videoInfo = currentGalleryItem.__slideVideoInfo;
                    this.outer.attr("data-lg-slide-type", this.getSlideType(currentGalleryItem));
                    this.setDownloadValue(index);
                    if (videoInfo) {
                        var _a = this.mediaContainerPosition, top_3 = _a.top, bottom = _a.bottom;
                        var videoSize = utils.getSize(this.items[index], this.outer, top_3 + bottom, videoInfo && this.settings.videoMaxSize);
                        this.resizeVideoSlide(index, videoSize);
                    }
                    this.LGel.trigger(lGEvents.beforeSlide, {
                        prevIndex,
                        index,
                        fromTouch: !!fromTouch,
                        fromThumb: !!fromThumb
                    });
                    this.lgBusy = true;
                    clearTimeout(this.hideBarTimeout);
                    this.arrowDisable(index);
                    if (!direction) if (index < prevIndex) direction = "prev"; else if (index > prevIndex) direction = "next";
                    if (!fromTouch) this.makeSlideAnimation(direction, currentSlideItem, previousSlideItem_1); else {
                        this.outer.find(".lg-item").removeClass("lg-prev-slide lg-current lg-next-slide");
                        var touchPrev = void 0;
                        var touchNext = void 0;
                        if (numberOfGalleryItems > 2) {
                            touchPrev = index - 1;
                            touchNext = index + 1;
                            if (0 === index && prevIndex === numberOfGalleryItems - 1) {
                                touchNext = 0;
                                touchPrev = numberOfGalleryItems - 1;
                            } else if (index === numberOfGalleryItems - 1 && 0 === prevIndex) {
                                touchNext = 0;
                                touchPrev = numberOfGalleryItems - 1;
                            }
                        } else {
                            touchPrev = 0;
                            touchNext = 1;
                        }
                        if ("prev" === direction) this.getSlideItem(touchNext).addClass("lg-next-slide"); else this.getSlideItem(touchPrev).addClass("lg-prev-slide");
                        currentSlideItem.addClass("lg-current");
                    }
                    if (!this.lGalleryOn) this.loadContent(index, true); else setTimeout((function() {
                        _this.loadContent(index, true);
                        if (".lg-item" !== _this.settings.appendSubHtmlTo) _this.addHtml(index);
                    }), this.settings.speed + 50 + (fromTouch ? 0 : this.settings.slideDelay));
                    setTimeout((function() {
                        _this.lgBusy = false;
                        previousSlideItem_1.removeClass("lg-slide-progress");
                        _this.LGel.trigger(lGEvents.afterSlide, {
                            prevIndex,
                            index,
                            fromTouch,
                            fromThumb
                        });
                    }), (this.lGalleryOn ? this.settings.speed + 100 : 100) + (fromTouch ? 0 : this.settings.slideDelay));
                }
                this.index = index;
            };
            LightGallery.prototype.updateCurrentCounter = function(index) {
                this.getElementById("lg-counter-current").html(index + 1 + "");
            };
            LightGallery.prototype.updateCounterTotal = function() {
                this.getElementById("lg-counter-all").html(this.galleryItems.length + "");
            };
            LightGallery.prototype.getSlideType = function(item) {
                if (item.__slideVideoInfo) return "video"; else if (item.iframe) return "iframe"; else return "image";
            };
            LightGallery.prototype.touchMove = function(startCoords, endCoords, e) {
                var distanceX = endCoords.pageX - startCoords.pageX;
                var distanceY = endCoords.pageY - startCoords.pageY;
                var allowSwipe = false;
                if (this.swipeDirection) allowSwipe = true; else if (Math.abs(distanceX) > 15) {
                    this.swipeDirection = "horizontal";
                    allowSwipe = true;
                } else if (Math.abs(distanceY) > 15) {
                    this.swipeDirection = "vertical";
                    allowSwipe = true;
                }
                if (!allowSwipe) return;
                var $currentSlide = this.getSlideItem(this.index);
                if ("horizontal" === this.swipeDirection) {
                    null === e || void 0 === e ? void 0 : e.preventDefault();
                    this.outer.addClass("lg-dragging");
                    this.setTranslate($currentSlide, distanceX, 0);
                    var width = $currentSlide.get().offsetWidth;
                    var slideWidthAmount = 15 * width / 100;
                    var gutter = slideWidthAmount - Math.abs(10 * distanceX / 100);
                    this.setTranslate(this.outer.find(".lg-prev-slide").first(), -width + distanceX - gutter, 0);
                    this.setTranslate(this.outer.find(".lg-next-slide").first(), width + distanceX + gutter, 0);
                } else if ("vertical" === this.swipeDirection) if (this.settings.swipeToClose) {
                    null === e || void 0 === e ? void 0 : e.preventDefault();
                    this.$container.addClass("lg-dragging-vertical");
                    var opacity = 1 - Math.abs(distanceY) / window.innerHeight;
                    this.$backdrop.css("opacity", opacity);
                    var scale = 1 - Math.abs(distanceY) / (2 * window.innerWidth);
                    this.setTranslate($currentSlide, 0, distanceY, scale, scale);
                    if (Math.abs(distanceY) > 100) this.outer.addClass("lg-hide-items").removeClass("lg-components-open");
                }
            };
            LightGallery.prototype.touchEnd = function(endCoords, startCoords, event) {
                var _this = this;
                var distance;
                if ("lg-slide" !== this.settings.mode) this.outer.addClass("lg-slide");
                setTimeout((function() {
                    _this.$container.removeClass("lg-dragging-vertical");
                    _this.outer.removeClass("lg-dragging lg-hide-items").addClass("lg-components-open");
                    var triggerClick = true;
                    if ("horizontal" === _this.swipeDirection) {
                        distance = endCoords.pageX - startCoords.pageX;
                        var distanceAbs = Math.abs(endCoords.pageX - startCoords.pageX);
                        if (distance < 0 && distanceAbs > _this.settings.swipeThreshold) {
                            _this.goToNextSlide(true);
                            triggerClick = false;
                        } else if (distance > 0 && distanceAbs > _this.settings.swipeThreshold) {
                            _this.goToPrevSlide(true);
                            triggerClick = false;
                        }
                    } else if ("vertical" === _this.swipeDirection) {
                        distance = Math.abs(endCoords.pageY - startCoords.pageY);
                        if (_this.settings.closable && _this.settings.swipeToClose && distance > 100) {
                            _this.closeGallery();
                            return;
                        } else _this.$backdrop.css("opacity", 1);
                    }
                    _this.outer.find(".lg-item").removeAttr("style");
                    if (triggerClick && Math.abs(endCoords.pageX - startCoords.pageX) < 5) {
                        var target = $LG(event.target);
                        if (_this.isPosterElement(target)) _this.LGel.trigger(lGEvents.posterClick);
                    }
                    _this.swipeDirection = void 0;
                }));
                setTimeout((function() {
                    if (!_this.outer.hasClass("lg-dragging") && "lg-slide" !== _this.settings.mode) _this.outer.removeClass("lg-slide");
                }), this.settings.speed + 100);
            };
            LightGallery.prototype.enableSwipe = function() {
                var _this = this;
                var startCoords = {};
                var endCoords = {};
                var isMoved = false;
                var isSwiping = false;
                if (this.settings.enableSwipe) {
                    this.$inner.on("touchstart.lg", (function(e) {
                        _this.dragOrSwipeEnabled = true;
                        var $item = _this.getSlideItem(_this.index);
                        if (($LG(e.target).hasClass("lg-item") || $item.get().contains(e.target)) && !_this.outer.hasClass("lg-zoomed") && !_this.lgBusy && 1 === e.targetTouches.length) {
                            isSwiping = true;
                            _this.touchAction = "swipe";
                            _this.manageSwipeClass();
                            startCoords = {
                                pageX: e.targetTouches[0].pageX,
                                pageY: e.targetTouches[0].pageY
                            };
                        }
                    }));
                    this.$inner.on("touchmove.lg", (function(e) {
                        if (isSwiping && "swipe" === _this.touchAction && 1 === e.targetTouches.length) {
                            endCoords = {
                                pageX: e.targetTouches[0].pageX,
                                pageY: e.targetTouches[0].pageY
                            };
                            _this.touchMove(startCoords, endCoords, e);
                            isMoved = true;
                        }
                    }));
                    this.$inner.on("touchend.lg", (function(event) {
                        if ("swipe" === _this.touchAction) {
                            if (isMoved) {
                                isMoved = false;
                                _this.touchEnd(endCoords, startCoords, event);
                            } else if (isSwiping) {
                                var target = $LG(event.target);
                                if (_this.isPosterElement(target)) _this.LGel.trigger(lGEvents.posterClick);
                            }
                            _this.touchAction = void 0;
                            isSwiping = false;
                        }
                    }));
                }
            };
            LightGallery.prototype.enableDrag = function() {
                var _this = this;
                var startCoords = {};
                var endCoords = {};
                var isDraging = false;
                var isMoved = false;
                if (this.settings.enableDrag) {
                    this.outer.on("mousedown.lg", (function(e) {
                        _this.dragOrSwipeEnabled = true;
                        var $item = _this.getSlideItem(_this.index);
                        if ($LG(e.target).hasClass("lg-item") || $item.get().contains(e.target)) if (!_this.outer.hasClass("lg-zoomed") && !_this.lgBusy) {
                            e.preventDefault();
                            if (!_this.lgBusy) {
                                _this.manageSwipeClass();
                                startCoords = {
                                    pageX: e.pageX,
                                    pageY: e.pageY
                                };
                                isDraging = true;
                                _this.outer.get().scrollLeft += 1;
                                _this.outer.get().scrollLeft -= 1;
                                _this.outer.removeClass("lg-grab").addClass("lg-grabbing");
                                _this.LGel.trigger(lGEvents.dragStart);
                            }
                        }
                    }));
                    $LG(window).on("mousemove.lg.global" + this.lgId, (function(e) {
                        if (isDraging && _this.lgOpened) {
                            isMoved = true;
                            endCoords = {
                                pageX: e.pageX,
                                pageY: e.pageY
                            };
                            _this.touchMove(startCoords, endCoords);
                            _this.LGel.trigger(lGEvents.dragMove);
                        }
                    }));
                    $LG(window).on("mouseup.lg.global" + this.lgId, (function(event) {
                        if (!_this.lgOpened) return;
                        var target = $LG(event.target);
                        if (isMoved) {
                            isMoved = false;
                            _this.touchEnd(endCoords, startCoords, event);
                            _this.LGel.trigger(lGEvents.dragEnd);
                        } else if (_this.isPosterElement(target)) _this.LGel.trigger(lGEvents.posterClick);
                        if (isDraging) {
                            isDraging = false;
                            _this.outer.removeClass("lg-grabbing").addClass("lg-grab");
                        }
                    }));
                }
            };
            LightGallery.prototype.triggerPosterClick = function() {
                var _this = this;
                this.$inner.on("click.lg", (function(event) {
                    if (!_this.dragOrSwipeEnabled && _this.isPosterElement($LG(event.target))) _this.LGel.trigger(lGEvents.posterClick);
                }));
            };
            LightGallery.prototype.manageSwipeClass = function() {
                var _touchNext = this.index + 1;
                var _touchPrev = this.index - 1;
                if (this.settings.loop && this.galleryItems.length > 2) if (0 === this.index) _touchPrev = this.galleryItems.length - 1; else if (this.index === this.galleryItems.length - 1) _touchNext = 0;
                this.outer.find(".lg-item").removeClass("lg-next-slide lg-prev-slide");
                if (_touchPrev > -1) this.getSlideItem(_touchPrev).addClass("lg-prev-slide");
                this.getSlideItem(_touchNext).addClass("lg-next-slide");
            };
            LightGallery.prototype.goToNextSlide = function(fromTouch) {
                var _this = this;
                var _loop = this.settings.loop;
                if (fromTouch && this.galleryItems.length < 3) _loop = false;
                if (!this.lgBusy) if (this.index + 1 < this.galleryItems.length) {
                    this.index++;
                    this.LGel.trigger(lGEvents.beforeNextSlide, {
                        index: this.index
                    });
                    this.slide(this.index, !!fromTouch, false, "next");
                } else if (_loop) {
                    this.index = 0;
                    this.LGel.trigger(lGEvents.beforeNextSlide, {
                        index: this.index
                    });
                    this.slide(this.index, !!fromTouch, false, "next");
                } else if (this.settings.slideEndAnimation && !fromTouch) {
                    this.outer.addClass("lg-right-end");
                    setTimeout((function() {
                        _this.outer.removeClass("lg-right-end");
                    }), 400);
                }
            };
            LightGallery.prototype.goToPrevSlide = function(fromTouch) {
                var _this = this;
                var _loop = this.settings.loop;
                if (fromTouch && this.galleryItems.length < 3) _loop = false;
                if (!this.lgBusy) if (this.index > 0) {
                    this.index--;
                    this.LGel.trigger(lGEvents.beforePrevSlide, {
                        index: this.index,
                        fromTouch
                    });
                    this.slide(this.index, !!fromTouch, false, "prev");
                } else if (_loop) {
                    this.index = this.galleryItems.length - 1;
                    this.LGel.trigger(lGEvents.beforePrevSlide, {
                        index: this.index,
                        fromTouch
                    });
                    this.slide(this.index, !!fromTouch, false, "prev");
                } else if (this.settings.slideEndAnimation && !fromTouch) {
                    this.outer.addClass("lg-left-end");
                    setTimeout((function() {
                        _this.outer.removeClass("lg-left-end");
                    }), 400);
                }
            };
            LightGallery.prototype.keyPress = function() {
                var _this = this;
                $LG(window).on("keydown.lg.global" + this.lgId, (function(e) {
                    if (_this.lgOpened && true === _this.settings.escKey && 27 === e.keyCode) {
                        e.preventDefault();
                        if (_this.settings.allowMediaOverlap && _this.outer.hasClass("lg-can-toggle") && _this.outer.hasClass("lg-components-open")) _this.outer.removeClass("lg-components-open"); else _this.closeGallery();
                    }
                    if (_this.lgOpened && _this.galleryItems.length > 1) {
                        if (37 === e.keyCode) {
                            e.preventDefault();
                            _this.goToPrevSlide();
                        }
                        if (39 === e.keyCode) {
                            e.preventDefault();
                            _this.goToNextSlide();
                        }
                    }
                }));
            };
            LightGallery.prototype.arrow = function() {
                var _this = this;
                this.getElementById("lg-prev").on("click.lg", (function() {
                    _this.goToPrevSlide();
                }));
                this.getElementById("lg-next").on("click.lg", (function() {
                    _this.goToNextSlide();
                }));
            };
            LightGallery.prototype.arrowDisable = function(index) {
                if (!this.settings.loop && this.settings.hideControlOnEnd) {
                    var $prev = this.getElementById("lg-prev");
                    var $next = this.getElementById("lg-next");
                    if (index + 1 === this.galleryItems.length) $next.attr("disabled", "disabled").addClass("disabled"); else $next.removeAttr("disabled").removeClass("disabled");
                    if (0 === index) $prev.attr("disabled", "disabled").addClass("disabled"); else $prev.removeAttr("disabled").removeClass("disabled");
                }
            };
            LightGallery.prototype.setTranslate = function($el, xValue, yValue, scaleX, scaleY) {
                if (void 0 === scaleX) scaleX = 1;
                if (void 0 === scaleY) scaleY = 1;
                $el.css("transform", "translate3d(" + xValue + "px, " + yValue + "px, 0px) scale3d(" + scaleX + ", " + scaleY + ", 1)");
            };
            LightGallery.prototype.mousewheel = function() {
                var _this = this;
                var lastCall = 0;
                this.outer.on("wheel.lg", (function(e) {
                    if (!e.deltaY || _this.galleryItems.length < 2) return;
                    e.preventDefault();
                    var now = (new Date).getTime();
                    if (now - lastCall < 1e3) return;
                    lastCall = now;
                    if (e.deltaY > 0) _this.goToNextSlide(); else if (e.deltaY < 0) _this.goToPrevSlide();
                }));
            };
            LightGallery.prototype.isSlideElement = function(target) {
                return target.hasClass("lg-outer") || target.hasClass("lg-item") || target.hasClass("lg-img-wrap");
            };
            LightGallery.prototype.isPosterElement = function(target) {
                var playButton = this.getSlideItem(this.index).find(".lg-video-play-button").get();
                return target.hasClass("lg-video-poster") || target.hasClass("lg-video-play-button") || playButton && playButton.contains(target.get());
            };
            LightGallery.prototype.toggleMaximize = function() {
                var _this = this;
                this.getElementById("lg-maximize").on("click.lg", (function() {
                    _this.$container.toggleClass("lg-inline");
                    _this.refreshOnResize();
                }));
            };
            LightGallery.prototype.invalidateItems = function() {
                for (var index = 0; index < this.items.length; index++) {
                    var element = this.items[index];
                    var $element = $LG(element);
                    $element.off("click.lgcustom-item-" + $element.attr("data-lg-id"));
                }
            };
            LightGallery.prototype.manageCloseGallery = function() {
                var _this = this;
                if (!this.settings.closable) return;
                var mousedown = false;
                this.getElementById("lg-close").on("click.lg", (function() {
                    _this.closeGallery();
                }));
                if (this.settings.closeOnTap) {
                    this.outer.on("mousedown.lg", (function(e) {
                        var target = $LG(e.target);
                        if (_this.isSlideElement(target)) mousedown = true; else mousedown = false;
                    }));
                    this.outer.on("mousemove.lg", (function() {
                        mousedown = false;
                    }));
                    this.outer.on("mouseup.lg", (function(e) {
                        var target = $LG(e.target);
                        if (_this.isSlideElement(target) && mousedown) if (!_this.outer.hasClass("lg-dragging")) _this.closeGallery();
                    }));
                }
            };
            LightGallery.prototype.closeGallery = function(force) {
                var _this = this;
                if (!this.lgOpened || !this.settings.closable && !force) return 0;
                this.LGel.trigger(lGEvents.beforeClose);
                $LG(window).scrollTop(this.prevScrollTop);
                var currentItem = this.items[this.index];
                var transform;
                if (this.zoomFromOrigin && currentItem) {
                    var _a = this.mediaContainerPosition, top_4 = _a.top, bottom = _a.bottom;
                    var _b = this.galleryItems[this.index], __slideVideoInfo = _b.__slideVideoInfo, poster = _b.poster;
                    var imageSize = utils.getSize(currentItem, this.outer, top_4 + bottom, __slideVideoInfo && poster && this.settings.videoMaxSize);
                    transform = utils.getTransform(currentItem, this.outer, top_4, bottom, imageSize);
                }
                if (this.zoomFromOrigin && transform) {
                    this.outer.addClass("lg-closing lg-zoom-from-image");
                    this.getSlideItem(this.index).addClass("lg-start-end-progress").css("transition-duration", this.settings.startAnimationDuration + "ms").css("transform", transform);
                } else {
                    this.outer.addClass("lg-hide-items");
                    this.outer.removeClass("lg-zoom-from-image");
                }
                this.destroyModules();
                this.lGalleryOn = false;
                this.isDummyImageRemoved = false;
                this.zoomFromOrigin = this.settings.zoomFromOrigin;
                clearTimeout(this.hideBarTimeout);
                this.hideBarTimeout = false;
                $LG("html").removeClass("lg-on");
                this.outer.removeClass("lg-visible lg-components-open");
                this.$backdrop.removeClass("in").css("opacity", 0);
                var removeTimeout = this.zoomFromOrigin && transform ? Math.max(this.settings.startAnimationDuration, this.settings.backdropDuration) : this.settings.backdropDuration;
                this.$container.removeClass("lg-show-in");
                setTimeout((function() {
                    if (_this.zoomFromOrigin && transform) _this.outer.removeClass("lg-zoom-from-image");
                    _this.$container.removeClass("lg-show");
                    _this.$backdrop.removeAttr("style").css("transition-duration", _this.settings.backdropDuration + "ms");
                    _this.outer.removeClass("lg-closing " + _this.settings.startClass);
                    _this.getSlideItem(_this.index).removeClass("lg-start-end-progress");
                    _this.$inner.empty();
                    if (_this.lgOpened) _this.LGel.trigger(lGEvents.afterClose, {
                        instance: _this
                    });
                    if (_this.outer.get()) _this.outer.get().blur();
                    _this.lgOpened = false;
                }), removeTimeout + 100);
                return removeTimeout + 100;
            };
            LightGallery.prototype.initModules = function() {
                this.plugins.forEach((function(module) {
                    try {
                        module.init();
                    } catch (err) {
                        console.warn("lightGallery:- make sure lightGallery module is properly initiated");
                    }
                }));
            };
            LightGallery.prototype.destroyModules = function(destroy) {
                this.plugins.forEach((function(module) {
                    try {
                        if (destroy) module.destroy(); else module.closeGallery && module.closeGallery();
                    } catch (err) {
                        console.warn("lightGallery:- make sure lightGallery module is properly destroyed");
                    }
                }));
            };
            LightGallery.prototype.refresh = function(galleryItems) {
                if (!this.settings.dynamic) this.invalidateItems();
                if (galleryItems) this.galleryItems = galleryItems; else this.galleryItems = this.getItems();
                this.updateControls();
                this.openGalleryOnItemClick();
                this.LGel.trigger(lGEvents.updateSlides);
            };
            LightGallery.prototype.updateControls = function() {
                this.addSlideVideoInfo(this.galleryItems);
                this.updateCounterTotal();
                this.manageSingleSlideClassName();
            };
            LightGallery.prototype.destroy = function() {
                var _this = this;
                var closeTimeout = this.closeGallery(true);
                setTimeout((function() {
                    _this.destroyModules(true);
                    if (!_this.settings.dynamic) _this.invalidateItems();
                    $LG(window).off(".lg.global" + _this.lgId);
                    _this.LGel.off(".lg");
                    _this.$container.remove();
                }), closeTimeout);
                return closeTimeout;
            };
            return LightGallery;
        }();
        function lightGallery(el, options) {
            return new LightGallery(el, options);
        }
        const lightgallery_es5 = lightGallery;
        var lg_thumbnail_min = __webpack_require__(5097);
        var lg_zoom_min = __webpack_require__(5086);
        const galleries = document.querySelectorAll("[data-gallery]");
        if (galleries.length) {
            let galleyItems = [];
            galleries.forEach((gallery => {
                galleyItems.push({
                    gallery,
                    galleryClass: lightgallery_es5(gallery, {
                        plugins: [ lg_zoom_min, lg_thumbnail_min ],
                        licenseKey: "7EC452A9-0CFD441C-BD984C7C-17C8456E",
                        speed: 400
                    })
                });
            }));
            modules_flsModules.gallery = galleyItems;
        }
        const btnFavorites = document.querySelectorAll(".btn__favorite");
        for (const box of btnFavorites) box.addEventListener("click", (function handleClick() {
            box.classList.toggle("active");
        }));
        const toggleButtons = document.querySelectorAll(".js-sidebar-toggle");
        const sidebarMessage = document.querySelector(".message__sidebar");
        toggleButtons.forEach((function(item) {
            item.addEventListener("click", (function(e) {
                e.preventDefault();
                sidebarMessage.classList.toggle("collapsed");
            }));
        }));
        const inputFile = document.querySelectorAll(".upload-file__input");
        inputFile.forEach((function(el) {
            let textSelector = document.querySelector(".upload-file__text");
            let fileList;
            el.addEventListener("change", (function(e) {
                fileList = [];
                for (let i = 0; i < el.files.length; i++) fileList.push(el.files[i]);
                fileList.forEach((file => {
                    uploadFile(file);
                }));
            }));
            const uploadFile = file => {
                if (file.size > 5 * 1024 * 1024) {
                    alert("Файл должен быть не более 5 МБ.");
                    return;
                }
                if (file && file.length > 1) {
                    if (file.length <= 4) textSelector.textContent = `Выбрано ${file.length} файла`;
                    if (file.length > 4) textSelector.textContent = `Выбрано ${file.length} файлов`;
                } else textSelector.textContent = file.name;
            };
        }));
        document.addEventListener("DOMContentLoaded", (() => {
            flatpickr("#calendar-range", {
                mode: "range",
                minDate: "today",
                altInput: true,
                altFormat: "F j, Y",
                dateFormat: "Y-m-d",
                locale: "ru",
                plugins: [ new rangePlugin({
                    input: "#calendar-range-2"
                }) ]
            });
            flatpickr("#time", {
                enableTime: true,
                noCalendar: true,
                dateFormat: "H:i",
                time_24hr: true
            });
            flatpickr("#hours", {
                enableTime: true,
                noCalendar: true,
                dateFormat: "H",
                time_24hr: true
            });
            flatpickr("#calendar", {
                locale: "ru",
                minDate: "today",
                altInput: true,
                altFormat: "F j, Y",
                dateFormat: "Y-m-d"
            });
            const stickyEl = new Sticksy(".js-sticky-widget", {
                topSpacing: 20
            });
            if ("undefined" != typeof stickyEl && null != stickyEl) stickyEl.onStateChanged = function(state) {
                if ("fixed" === state) stickyEl.nodeRef.classList.add("widget--sticky"); else stickyEl.nodeRef.classList.remove("widget--sticky");
            };
        }));
        var enums_top = "top";
        var bottom = "bottom";
        var right = "right";
        var left = "left";
        var auto = "auto";
        var basePlacements = [ enums_top, bottom, right, left ];
        var start = "start";
        var end = "end";
        var clippingParents = "clippingParents";
        var viewport = "viewport";
        var popper = "popper";
        var reference = "reference";
        var variationPlacements = basePlacements.reduce((function(acc, placement) {
            return acc.concat([ placement + "-" + start, placement + "-" + end ]);
        }), []);
        var enums_placements = [].concat(basePlacements, [ auto ]).reduce((function(acc, placement) {
            return acc.concat([ placement, placement + "-" + start, placement + "-" + end ]);
        }), []);
        var beforeRead = "beforeRead";
        var read = "read";
        var afterRead = "afterRead";
        var beforeMain = "beforeMain";
        var main = "main";
        var afterMain = "afterMain";
        var beforeWrite = "beforeWrite";
        var write = "write";
        var afterWrite = "afterWrite";
        var modifierPhases = [ beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite ];
        function getNodeName(element) {
            return element ? (element.nodeName || "").toLowerCase() : null;
        }
        function getWindow_getWindow(node) {
            if (null == node) return window;
            if ("[object Window]" !== node.toString()) {
                var ownerDocument = node.ownerDocument;
                return ownerDocument ? ownerDocument.defaultView || window : window;
            }
            return node;
        }
        function isElement(node) {
            var OwnElement = getWindow_getWindow(node).Element;
            return node instanceof OwnElement || node instanceof Element;
        }
        function isHTMLElement(node) {
            var OwnElement = getWindow_getWindow(node).HTMLElement;
            return node instanceof OwnElement || node instanceof HTMLElement;
        }
        function isShadowRoot(node) {
            if ("undefined" === typeof ShadowRoot) return false;
            var OwnElement = getWindow_getWindow(node).ShadowRoot;
            return node instanceof OwnElement || node instanceof ShadowRoot;
        }
        function applyStyles(_ref) {
            var state = _ref.state;
            Object.keys(state.elements).forEach((function(name) {
                var style = state.styles[name] || {};
                var attributes = state.attributes[name] || {};
                var element = state.elements[name];
                if (!isHTMLElement(element) || !getNodeName(element)) return;
                Object.assign(element.style, style);
                Object.keys(attributes).forEach((function(name) {
                    var value = attributes[name];
                    if (false === value) element.removeAttribute(name); else element.setAttribute(name, true === value ? "" : value);
                }));
            }));
        }
        function effect(_ref2) {
            var state = _ref2.state;
            var initialStyles = {
                popper: {
                    position: state.options.strategy,
                    left: "0",
                    top: "0",
                    margin: "0"
                },
                arrow: {
                    position: "absolute"
                },
                reference: {}
            };
            Object.assign(state.elements.popper.style, initialStyles.popper);
            state.styles = initialStyles;
            if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow);
            return function() {
                Object.keys(state.elements).forEach((function(name) {
                    var element = state.elements[name];
                    var attributes = state.attributes[name] || {};
                    var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
                    var style = styleProperties.reduce((function(style, property) {
                        style[property] = "";
                        return style;
                    }), {});
                    if (!isHTMLElement(element) || !getNodeName(element)) return;
                    Object.assign(element.style, style);
                    Object.keys(attributes).forEach((function(attribute) {
                        element.removeAttribute(attribute);
                    }));
                }));
            };
        }
        const modifiers_applyStyles = {
            name: "applyStyles",
            enabled: true,
            phase: "write",
            fn: applyStyles,
            effect,
            requires: [ "computeStyles" ]
        };
        function getBasePlacement(placement) {
            return placement.split("-")[0];
        }
        var math_max = Math.max;
        var math_min = Math.min;
        var round = Math.round;
        function getBoundingClientRect(element, includeScale) {
            if (void 0 === includeScale) includeScale = false;
            var rect = element.getBoundingClientRect();
            var scaleX = 1;
            var scaleY = 1;
            if (isHTMLElement(element) && includeScale) {
                var offsetHeight = element.offsetHeight;
                var offsetWidth = element.offsetWidth;
                if (offsetWidth > 0) scaleX = round(rect.width) / offsetWidth || 1;
                if (offsetHeight > 0) scaleY = round(rect.height) / offsetHeight || 1;
            }
            return {
                width: rect.width / scaleX,
                height: rect.height / scaleY,
                top: rect.top / scaleY,
                right: rect.right / scaleX,
                bottom: rect.bottom / scaleY,
                left: rect.left / scaleX,
                x: rect.left / scaleX,
                y: rect.top / scaleY
            };
        }
        function getLayoutRect(element) {
            var clientRect = getBoundingClientRect(element);
            var width = element.offsetWidth;
            var height = element.offsetHeight;
            if (Math.abs(clientRect.width - width) <= 1) width = clientRect.width;
            if (Math.abs(clientRect.height - height) <= 1) height = clientRect.height;
            return {
                x: element.offsetLeft,
                y: element.offsetTop,
                width,
                height
            };
        }
        function contains(parent, child) {
            var rootNode = child.getRootNode && child.getRootNode();
            if (parent.contains(child)) return true; else if (rootNode && isShadowRoot(rootNode)) {
                var next = child;
                do {
                    if (next && parent.isSameNode(next)) return true;
                    next = next.parentNode || next.host;
                } while (next);
            }
            return false;
        }
        function getComputedStyle_getComputedStyle(element) {
            return getWindow_getWindow(element).getComputedStyle(element);
        }
        function isTableElement(element) {
            return [ "table", "td", "th" ].indexOf(getNodeName(element)) >= 0;
        }
        function getDocumentElement(element) {
            return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
        }
        function getParentNode(element) {
            if ("html" === getNodeName(element)) return element;
            return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
        }
        function getTrueOffsetParent(element) {
            if (!isHTMLElement(element) || "fixed" === getComputedStyle_getComputedStyle(element).position) return null;
            return element.offsetParent;
        }
        function getContainingBlock(element) {
            var isFirefox = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");
            var isIE = -1 !== navigator.userAgent.indexOf("Trident");
            if (isIE && isHTMLElement(element)) {
                var elementCss = getComputedStyle_getComputedStyle(element);
                if ("fixed" === elementCss.position) return null;
            }
            var currentNode = getParentNode(element);
            if (isShadowRoot(currentNode)) currentNode = currentNode.host;
            while (isHTMLElement(currentNode) && [ "html", "body" ].indexOf(getNodeName(currentNode)) < 0) {
                var css = getComputedStyle_getComputedStyle(currentNode);
                if ("none" !== css.transform || "none" !== css.perspective || "paint" === css.contain || -1 !== [ "transform", "perspective" ].indexOf(css.willChange) || isFirefox && "filter" === css.willChange || isFirefox && css.filter && "none" !== css.filter) return currentNode; else currentNode = currentNode.parentNode;
            }
            return null;
        }
        function getOffsetParent(element) {
            var window = getWindow_getWindow(element);
            var offsetParent = getTrueOffsetParent(element);
            while (offsetParent && isTableElement(offsetParent) && "static" === getComputedStyle_getComputedStyle(offsetParent).position) offsetParent = getTrueOffsetParent(offsetParent);
            if (offsetParent && ("html" === getNodeName(offsetParent) || "body" === getNodeName(offsetParent) && "static" === getComputedStyle_getComputedStyle(offsetParent).position)) return window;
            return offsetParent || getContainingBlock(element) || window;
        }
        function getMainAxisFromPlacement(placement) {
            return [ "top", "bottom" ].indexOf(placement) >= 0 ? "x" : "y";
        }
        function within(min, value, max) {
            return math_max(min, math_min(value, max));
        }
        function withinMaxClamp(min, value, max) {
            var v = within(min, value, max);
            return v > max ? max : v;
        }
        function getFreshSideObject() {
            return {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            };
        }
        function mergePaddingObject(paddingObject) {
            return Object.assign({}, getFreshSideObject(), paddingObject);
        }
        function expandToHashMap(value, keys) {
            return keys.reduce((function(hashMap, key) {
                hashMap[key] = value;
                return hashMap;
            }), {});
        }
        var toPaddingObject = function toPaddingObject(padding, state) {
            padding = "function" === typeof padding ? padding(Object.assign({}, state.rects, {
                placement: state.placement
            })) : padding;
            return mergePaddingObject("number" !== typeof padding ? padding : expandToHashMap(padding, basePlacements));
        };
        function arrow(_ref) {
            var _state$modifiersData$;
            var state = _ref.state, name = _ref.name, options = _ref.options;
            var arrowElement = state.elements.arrow;
            var popperOffsets = state.modifiersData.popperOffsets;
            var basePlacement = getBasePlacement(state.placement);
            var axis = getMainAxisFromPlacement(basePlacement);
            var isVertical = [ left, right ].indexOf(basePlacement) >= 0;
            var len = isVertical ? "height" : "width";
            if (!arrowElement || !popperOffsets) return;
            var paddingObject = toPaddingObject(options.padding, state);
            var arrowRect = getLayoutRect(arrowElement);
            var minProp = "y" === axis ? enums_top : left;
            var maxProp = "y" === axis ? bottom : right;
            var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
            var startDiff = popperOffsets[axis] - state.rects.reference[axis];
            var arrowOffsetParent = getOffsetParent(arrowElement);
            var clientSize = arrowOffsetParent ? "y" === axis ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
            var centerToReference = endDiff / 2 - startDiff / 2;
            var min = paddingObject[minProp];
            var max = clientSize - arrowRect[len] - paddingObject[maxProp];
            var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
            var offset = within(min, center, max);
            var axisProp = axis;
            state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, 
            _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
        }
        function arrow_effect(_ref2) {
            var state = _ref2.state, options = _ref2.options;
            var _options$element = options.element, arrowElement = void 0 === _options$element ? "[data-popper-arrow]" : _options$element;
            if (null == arrowElement) return;
            if ("string" === typeof arrowElement) {
                arrowElement = state.elements.popper.querySelector(arrowElement);
                if (!arrowElement) return;
            }
            if (false) ;
            if (!contains(state.elements.popper, arrowElement)) {
                if (false) ;
                return;
            }
            state.elements.arrow = arrowElement;
        }
        const modifiers_arrow = {
            name: "arrow",
            enabled: true,
            phase: "main",
            fn: arrow,
            effect: arrow_effect,
            requires: [ "popperOffsets" ],
            requiresIfExists: [ "preventOverflow" ]
        };
        function getVariation(placement) {
            return placement.split("-")[1];
        }
        var unsetSides = {
            top: "auto",
            right: "auto",
            bottom: "auto",
            left: "auto"
        };
        function roundOffsetsByDPR(_ref) {
            var x = _ref.x, y = _ref.y;
            var win = window;
            var dpr = win.devicePixelRatio || 1;
            return {
                x: round(x * dpr) / dpr || 0,
                y: round(y * dpr) / dpr || 0
            };
        }
        function mapToStyles(_ref2) {
            var _Object$assign2;
            var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
            var _offsets$x = offsets.x, x = void 0 === _offsets$x ? 0 : _offsets$x, _offsets$y = offsets.y, y = void 0 === _offsets$y ? 0 : _offsets$y;
            var _ref3 = "function" === typeof roundOffsets ? roundOffsets({
                x,
                y
            }) : {
                x,
                y
            };
            x = _ref3.x;
            y = _ref3.y;
            var hasX = offsets.hasOwnProperty("x");
            var hasY = offsets.hasOwnProperty("y");
            var sideX = left;
            var sideY = enums_top;
            var win = window;
            if (adaptive) {
                var offsetParent = getOffsetParent(popper);
                var heightProp = "clientHeight";
                var widthProp = "clientWidth";
                if (offsetParent === getWindow_getWindow(popper)) {
                    offsetParent = getDocumentElement(popper);
                    if ("static" !== getComputedStyle_getComputedStyle(offsetParent).position && "absolute" === position) {
                        heightProp = "scrollHeight";
                        widthProp = "scrollWidth";
                    }
                }
                offsetParent = offsetParent;
                if (placement === enums_top || (placement === left || placement === right) && variation === end) {
                    sideY = bottom;
                    var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
                    y -= offsetY - popperRect.height;
                    y *= gpuAcceleration ? 1 : -1;
                }
                if (placement === left || (placement === enums_top || placement === bottom) && variation === end) {
                    sideX = right;
                    var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
                    x -= offsetX - popperRect.width;
                    x *= gpuAcceleration ? 1 : -1;
                }
            }
            var commonStyles = Object.assign({
                position
            }, adaptive && unsetSides);
            var _ref4 = true === roundOffsets ? roundOffsetsByDPR({
                x,
                y
            }) : {
                x,
                y
            };
            x = _ref4.x;
            y = _ref4.y;
            if (gpuAcceleration) {
                var _Object$assign;
                return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", 
                _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", 
                _Object$assign));
            }
            return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", 
            _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
        }
        function computeStyles(_ref5) {
            var state = _ref5.state, options = _ref5.options;
            var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = void 0 === _options$gpuAccelerat ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = void 0 === _options$adaptive ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = void 0 === _options$roundOffsets ? true : _options$roundOffsets;
            if (false) ;
            var commonStyles = {
                placement: getBasePlacement(state.placement),
                variation: getVariation(state.placement),
                popper: state.elements.popper,
                popperRect: state.rects.popper,
                gpuAcceleration,
                isFixed: "fixed" === state.options.strategy
            };
            if (null != state.modifiersData.popperOffsets) state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
                offsets: state.modifiersData.popperOffsets,
                position: state.options.strategy,
                adaptive,
                roundOffsets
            })));
            if (null != state.modifiersData.arrow) state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
                offsets: state.modifiersData.arrow,
                position: "absolute",
                adaptive: false,
                roundOffsets
            })));
            state.attributes.popper = Object.assign({}, state.attributes.popper, {
                "data-popper-placement": state.placement
            });
        }
        const modifiers_computeStyles = {
            name: "computeStyles",
            enabled: true,
            phase: "beforeWrite",
            fn: computeStyles,
            data: {}
        };
        var passive = {
            passive: true
        };
        function eventListeners_effect(_ref) {
            var state = _ref.state, instance = _ref.instance, options = _ref.options;
            var _options$scroll = options.scroll, scroll = void 0 === _options$scroll ? true : _options$scroll, _options$resize = options.resize, resize = void 0 === _options$resize ? true : _options$resize;
            var window = getWindow_getWindow(state.elements.popper);
            var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
            if (scroll) scrollParents.forEach((function(scrollParent) {
                scrollParent.addEventListener("scroll", instance.update, passive);
            }));
            if (resize) window.addEventListener("resize", instance.update, passive);
            return function() {
                if (scroll) scrollParents.forEach((function(scrollParent) {
                    scrollParent.removeEventListener("scroll", instance.update, passive);
                }));
                if (resize) window.removeEventListener("resize", instance.update, passive);
            };
        }
        const eventListeners = {
            name: "eventListeners",
            enabled: true,
            phase: "write",
            fn: function fn() {},
            effect: eventListeners_effect,
            data: {}
        };
        var hash = {
            left: "right",
            right: "left",
            bottom: "top",
            top: "bottom"
        };
        function getOppositePlacement(placement) {
            return placement.replace(/left|right|bottom|top/g, (function(matched) {
                return hash[matched];
            }));
        }
        var getOppositeVariationPlacement_hash = {
            start: "end",
            end: "start"
        };
        function getOppositeVariationPlacement(placement) {
            return placement.replace(/start|end/g, (function(matched) {
                return getOppositeVariationPlacement_hash[matched];
            }));
        }
        function getWindowScroll(node) {
            var win = getWindow_getWindow(node);
            var scrollLeft = win.pageXOffset;
            var scrollTop = win.pageYOffset;
            return {
                scrollLeft,
                scrollTop
            };
        }
        function getWindowScrollBarX(element) {
            return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
        }
        function getViewportRect(element) {
            var win = getWindow_getWindow(element);
            var html = getDocumentElement(element);
            var visualViewport = win.visualViewport;
            var width = html.clientWidth;
            var height = html.clientHeight;
            var x = 0;
            var y = 0;
            if (visualViewport) {
                width = visualViewport.width;
                height = visualViewport.height;
                if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
                    x = visualViewport.offsetLeft;
                    y = visualViewport.offsetTop;
                }
            }
            return {
                width,
                height,
                x: x + getWindowScrollBarX(element),
                y
            };
        }
        function getDocumentRect(element) {
            var _element$ownerDocumen;
            var html = getDocumentElement(element);
            var winScroll = getWindowScroll(element);
            var body = null == (_element$ownerDocumen = element.ownerDocument) ? void 0 : _element$ownerDocumen.body;
            var width = math_max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
            var height = math_max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
            var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
            var y = -winScroll.scrollTop;
            if ("rtl" === getComputedStyle_getComputedStyle(body || html).direction) x += math_max(html.clientWidth, body ? body.clientWidth : 0) - width;
            return {
                width,
                height,
                x,
                y
            };
        }
        function isScrollParent(element) {
            var _getComputedStyle = getComputedStyle_getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
            return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
        }
        function getScrollParent(node) {
            if ([ "html", "body", "#document" ].indexOf(getNodeName(node)) >= 0) return node.ownerDocument.body;
            if (isHTMLElement(node) && isScrollParent(node)) return node;
            return getScrollParent(getParentNode(node));
        }
        function listScrollParents(element, list) {
            var _element$ownerDocumen;
            if (void 0 === list) list = [];
            var scrollParent = getScrollParent(element);
            var isBody = scrollParent === (null == (_element$ownerDocumen = element.ownerDocument) ? void 0 : _element$ownerDocumen.body);
            var win = getWindow_getWindow(scrollParent);
            var target = isBody ? [ win ].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
            var updatedList = list.concat(target);
            return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
        }
        function rectToClientRect(rect) {
            return Object.assign({}, rect, {
                left: rect.x,
                top: rect.y,
                right: rect.x + rect.width,
                bottom: rect.y + rect.height
            });
        }
        function getInnerBoundingClientRect(element) {
            var rect = getBoundingClientRect(element);
            rect.top = rect.top + element.clientTop;
            rect.left = rect.left + element.clientLeft;
            rect.bottom = rect.top + element.clientHeight;
            rect.right = rect.left + element.clientWidth;
            rect.width = element.clientWidth;
            rect.height = element.clientHeight;
            rect.x = rect.left;
            rect.y = rect.top;
            return rect;
        }
        function getClientRectFromMixedType(element, clippingParent) {
            return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
        }
        function getClippingParents(element) {
            var clippingParents = listScrollParents(getParentNode(element));
            var canEscapeClipping = [ "absolute", "fixed" ].indexOf(getComputedStyle_getComputedStyle(element).position) >= 0;
            var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
            if (!isElement(clipperElement)) return [];
            return clippingParents.filter((function(clippingParent) {
                return isElement(clippingParent) && contains(clippingParent, clipperElement) && "body" !== getNodeName(clippingParent);
            }));
        }
        function getClippingRect(element, boundary, rootBoundary) {
            var mainClippingParents = "clippingParents" === boundary ? getClippingParents(element) : [].concat(boundary);
            var clippingParents = [].concat(mainClippingParents, [ rootBoundary ]);
            var firstClippingParent = clippingParents[0];
            var clippingRect = clippingParents.reduce((function(accRect, clippingParent) {
                var rect = getClientRectFromMixedType(element, clippingParent);
                accRect.top = math_max(rect.top, accRect.top);
                accRect.right = math_min(rect.right, accRect.right);
                accRect.bottom = math_min(rect.bottom, accRect.bottom);
                accRect.left = math_max(rect.left, accRect.left);
                return accRect;
            }), getClientRectFromMixedType(element, firstClippingParent));
            clippingRect.width = clippingRect.right - clippingRect.left;
            clippingRect.height = clippingRect.bottom - clippingRect.top;
            clippingRect.x = clippingRect.left;
            clippingRect.y = clippingRect.top;
            return clippingRect;
        }
        function computeOffsets(_ref) {
            var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
            var basePlacement = placement ? getBasePlacement(placement) : null;
            var variation = placement ? getVariation(placement) : null;
            var commonX = reference.x + reference.width / 2 - element.width / 2;
            var commonY = reference.y + reference.height / 2 - element.height / 2;
            var offsets;
            switch (basePlacement) {
              case enums_top:
                offsets = {
                    x: commonX,
                    y: reference.y - element.height
                };
                break;

              case bottom:
                offsets = {
                    x: commonX,
                    y: reference.y + reference.height
                };
                break;

              case right:
                offsets = {
                    x: reference.x + reference.width,
                    y: commonY
                };
                break;

              case left:
                offsets = {
                    x: reference.x - element.width,
                    y: commonY
                };
                break;

              default:
                offsets = {
                    x: reference.x,
                    y: reference.y
                };
            }
            var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
            if (null != mainAxis) {
                var len = "y" === mainAxis ? "height" : "width";
                switch (variation) {
                  case start:
                    offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
                    break;

                  case end:
                    offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
                    break;

                  default:
                }
            }
            return offsets;
        }
        function detectOverflow(state, options) {
            if (void 0 === options) options = {};
            var _options = options, _options$placement = _options.placement, placement = void 0 === _options$placement ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = void 0 === _options$boundary ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = void 0 === _options$rootBoundary ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = void 0 === _options$elementConte ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = void 0 === _options$altBoundary ? false : _options$altBoundary, _options$padding = _options.padding, padding = void 0 === _options$padding ? 0 : _options$padding;
            var paddingObject = mergePaddingObject("number" !== typeof padding ? padding : expandToHashMap(padding, basePlacements));
            var altContext = elementContext === popper ? reference : popper;
            var popperRect = state.rects.popper;
            var element = state.elements[altBoundary ? altContext : elementContext];
            var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
            var referenceClientRect = getBoundingClientRect(state.elements.reference);
            var popperOffsets = computeOffsets({
                reference: referenceClientRect,
                element: popperRect,
                strategy: "absolute",
                placement
            });
            var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
            var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
            var overflowOffsets = {
                top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
                bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
                left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
                right: elementClientRect.right - clippingClientRect.right + paddingObject.right
            };
            var offsetData = state.modifiersData.offset;
            if (elementContext === popper && offsetData) {
                var offset = offsetData[placement];
                Object.keys(overflowOffsets).forEach((function(key) {
                    var multiply = [ right, bottom ].indexOf(key) >= 0 ? 1 : -1;
                    var axis = [ enums_top, bottom ].indexOf(key) >= 0 ? "y" : "x";
                    overflowOffsets[key] += offset[axis] * multiply;
                }));
            }
            return overflowOffsets;
        }
        function computeAutoPlacement(state, options) {
            if (void 0 === options) options = {};
            var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = void 0 === _options$allowedAutoP ? enums_placements : _options$allowedAutoP;
            var variation = getVariation(placement);
            var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter((function(placement) {
                return getVariation(placement) === variation;
            })) : basePlacements;
            var allowedPlacements = placements.filter((function(placement) {
                return allowedAutoPlacements.indexOf(placement) >= 0;
            }));
            if (0 === allowedPlacements.length) {
                allowedPlacements = placements;
                if (false) ;
            }
            var overflows = allowedPlacements.reduce((function(acc, placement) {
                acc[placement] = detectOverflow(state, {
                    placement,
                    boundary,
                    rootBoundary,
                    padding
                })[getBasePlacement(placement)];
                return acc;
            }), {});
            return Object.keys(overflows).sort((function(a, b) {
                return overflows[a] - overflows[b];
            }));
        }
        function getExpandedFallbackPlacements(placement) {
            if (getBasePlacement(placement) === auto) return [];
            var oppositePlacement = getOppositePlacement(placement);
            return [ getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement) ];
        }
        function flip(_ref) {
            var state = _ref.state, options = _ref.options, name = _ref.name;
            if (state.modifiersData[name]._skip) return;
            var _options$mainAxis = options.mainAxis, checkMainAxis = void 0 === _options$mainAxis ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = void 0 === _options$altAxis ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = void 0 === _options$flipVariatio ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
            var preferredPlacement = state.options.placement;
            var basePlacement = getBasePlacement(preferredPlacement);
            var isBasePlacement = basePlacement === preferredPlacement;
            var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [ getOppositePlacement(preferredPlacement) ] : getExpandedFallbackPlacements(preferredPlacement));
            var placements = [ preferredPlacement ].concat(fallbackPlacements).reduce((function(acc, placement) {
                return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
                    placement,
                    boundary,
                    rootBoundary,
                    padding,
                    flipVariations,
                    allowedAutoPlacements
                }) : placement);
            }), []);
            var referenceRect = state.rects.reference;
            var popperRect = state.rects.popper;
            var checksMap = new Map;
            var makeFallbackChecks = true;
            var firstFittingPlacement = placements[0];
            for (var i = 0; i < placements.length; i++) {
                var placement = placements[i];
                var _basePlacement = getBasePlacement(placement);
                var isStartVariation = getVariation(placement) === start;
                var isVertical = [ enums_top, bottom ].indexOf(_basePlacement) >= 0;
                var len = isVertical ? "width" : "height";
                var overflow = detectOverflow(state, {
                    placement,
                    boundary,
                    rootBoundary,
                    altBoundary,
                    padding
                });
                var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : enums_top;
                if (referenceRect[len] > popperRect[len]) mainVariationSide = getOppositePlacement(mainVariationSide);
                var altVariationSide = getOppositePlacement(mainVariationSide);
                var checks = [];
                if (checkMainAxis) checks.push(overflow[_basePlacement] <= 0);
                if (checkAltAxis) checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
                if (checks.every((function(check) {
                    return check;
                }))) {
                    firstFittingPlacement = placement;
                    makeFallbackChecks = false;
                    break;
                }
                checksMap.set(placement, checks);
            }
            if (makeFallbackChecks) {
                var numberOfChecks = flipVariations ? 3 : 1;
                var _loop = function _loop(_i) {
                    var fittingPlacement = placements.find((function(placement) {
                        var checks = checksMap.get(placement);
                        if (checks) return checks.slice(0, _i).every((function(check) {
                            return check;
                        }));
                    }));
                    if (fittingPlacement) {
                        firstFittingPlacement = fittingPlacement;
                        return "break";
                    }
                };
                for (var _i = numberOfChecks; _i > 0; _i--) {
                    var _ret = _loop(_i);
                    if ("break" === _ret) break;
                }
            }
            if (state.placement !== firstFittingPlacement) {
                state.modifiersData[name]._skip = true;
                state.placement = firstFittingPlacement;
                state.reset = true;
            }
        }
        const modifiers_flip = {
            name: "flip",
            enabled: true,
            phase: "main",
            fn: flip,
            requiresIfExists: [ "offset" ],
            data: {
                _skip: false
            }
        };
        function getSideOffsets(overflow, rect, preventedOffsets) {
            if (void 0 === preventedOffsets) preventedOffsets = {
                x: 0,
                y: 0
            };
            return {
                top: overflow.top - rect.height - preventedOffsets.y,
                right: overflow.right - rect.width + preventedOffsets.x,
                bottom: overflow.bottom - rect.height + preventedOffsets.y,
                left: overflow.left - rect.width - preventedOffsets.x
            };
        }
        function isAnySideFullyClipped(overflow) {
            return [ enums_top, right, bottom, left ].some((function(side) {
                return overflow[side] >= 0;
            }));
        }
        function hide_hide(_ref) {
            var state = _ref.state, name = _ref.name;
            var referenceRect = state.rects.reference;
            var popperRect = state.rects.popper;
            var preventedOffsets = state.modifiersData.preventOverflow;
            var referenceOverflow = detectOverflow(state, {
                elementContext: "reference"
            });
            var popperAltOverflow = detectOverflow(state, {
                altBoundary: true
            });
            var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
            var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
            var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
            var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
            state.modifiersData[name] = {
                referenceClippingOffsets,
                popperEscapeOffsets,
                isReferenceHidden,
                hasPopperEscaped
            };
            state.attributes.popper = Object.assign({}, state.attributes.popper, {
                "data-popper-reference-hidden": isReferenceHidden,
                "data-popper-escaped": hasPopperEscaped
            });
        }
        const modifiers_hide = {
            name: "hide",
            enabled: true,
            phase: "main",
            requiresIfExists: [ "preventOverflow" ],
            fn: hide_hide
        };
        function distanceAndSkiddingToXY(placement, rects, offset) {
            var basePlacement = getBasePlacement(placement);
            var invertDistance = [ left, enums_top ].indexOf(basePlacement) >= 0 ? -1 : 1;
            var _ref = "function" === typeof offset ? offset(Object.assign({}, rects, {
                placement
            })) : offset, skidding = _ref[0], distance = _ref[1];
            skidding = skidding || 0;
            distance = (distance || 0) * invertDistance;
            return [ left, right ].indexOf(basePlacement) >= 0 ? {
                x: distance,
                y: skidding
            } : {
                x: skidding,
                y: distance
            };
        }
        function offset_offset(_ref2) {
            var state = _ref2.state, options = _ref2.options, name = _ref2.name;
            var _options$offset = options.offset, offset = void 0 === _options$offset ? [ 0, 0 ] : _options$offset;
            var data = enums_placements.reduce((function(acc, placement) {
                acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
                return acc;
            }), {});
            var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
            if (null != state.modifiersData.popperOffsets) {
                state.modifiersData.popperOffsets.x += x;
                state.modifiersData.popperOffsets.y += y;
            }
            state.modifiersData[name] = data;
        }
        const modifiers_offset = {
            name: "offset",
            enabled: true,
            phase: "main",
            requires: [ "popperOffsets" ],
            fn: offset_offset
        };
        function popperOffsets(_ref) {
            var state = _ref.state, name = _ref.name;
            state.modifiersData[name] = computeOffsets({
                reference: state.rects.reference,
                element: state.rects.popper,
                strategy: "absolute",
                placement: state.placement
            });
        }
        const modifiers_popperOffsets = {
            name: "popperOffsets",
            enabled: true,
            phase: "read",
            fn: popperOffsets,
            data: {}
        };
        function getAltAxis(axis) {
            return "x" === axis ? "y" : "x";
        }
        function preventOverflow(_ref) {
            var state = _ref.state, options = _ref.options, name = _ref.name;
            var _options$mainAxis = options.mainAxis, checkMainAxis = void 0 === _options$mainAxis ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = void 0 === _options$altAxis ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = void 0 === _options$tether ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = void 0 === _options$tetherOffset ? 0 : _options$tetherOffset;
            var overflow = detectOverflow(state, {
                boundary,
                rootBoundary,
                padding,
                altBoundary
            });
            var basePlacement = getBasePlacement(state.placement);
            var variation = getVariation(state.placement);
            var isBasePlacement = !variation;
            var mainAxis = getMainAxisFromPlacement(basePlacement);
            var altAxis = getAltAxis(mainAxis);
            var popperOffsets = state.modifiersData.popperOffsets;
            var referenceRect = state.rects.reference;
            var popperRect = state.rects.popper;
            var tetherOffsetValue = "function" === typeof tetherOffset ? tetherOffset(Object.assign({}, state.rects, {
                placement: state.placement
            })) : tetherOffset;
            var normalizedTetherOffsetValue = "number" === typeof tetherOffsetValue ? {
                mainAxis: tetherOffsetValue,
                altAxis: tetherOffsetValue
            } : Object.assign({
                mainAxis: 0,
                altAxis: 0
            }, tetherOffsetValue);
            var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
            var data = {
                x: 0,
                y: 0
            };
            if (!popperOffsets) return;
            if (checkMainAxis) {
                var _offsetModifierState$;
                var mainSide = "y" === mainAxis ? enums_top : left;
                var altSide = "y" === mainAxis ? bottom : right;
                var len = "y" === mainAxis ? "height" : "width";
                var offset = popperOffsets[mainAxis];
                var min = offset + overflow[mainSide];
                var max = offset - overflow[altSide];
                var additive = tether ? -popperRect[len] / 2 : 0;
                var minLen = variation === start ? referenceRect[len] : popperRect[len];
                var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
                var arrowElement = state.elements.arrow;
                var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
                    width: 0,
                    height: 0
                };
                var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
                var arrowPaddingMin = arrowPaddingObject[mainSide];
                var arrowPaddingMax = arrowPaddingObject[altSide];
                var arrowLen = within(0, referenceRect[len], arrowRect[len]);
                var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
                var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
                var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
                var clientOffset = arrowOffsetParent ? "y" === mainAxis ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
                var offsetModifierValue = null != (_offsetModifierState$ = null == offsetModifierState ? void 0 : offsetModifierState[mainAxis]) ? _offsetModifierState$ : 0;
                var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
                var tetherMax = offset + maxOffset - offsetModifierValue;
                var preventedOffset = within(tether ? math_min(min, tetherMin) : min, offset, tether ? math_max(max, tetherMax) : max);
                popperOffsets[mainAxis] = preventedOffset;
                data[mainAxis] = preventedOffset - offset;
            }
            if (checkAltAxis) {
                var _offsetModifierState$2;
                var _mainSide = "x" === mainAxis ? enums_top : left;
                var _altSide = "x" === mainAxis ? bottom : right;
                var _offset = popperOffsets[altAxis];
                var _len = "y" === altAxis ? "height" : "width";
                var _min = _offset + overflow[_mainSide];
                var _max = _offset - overflow[_altSide];
                var isOriginSide = -1 !== [ enums_top, left ].indexOf(basePlacement);
                var _offsetModifierValue = null != (_offsetModifierState$2 = null == offsetModifierState ? void 0 : offsetModifierState[altAxis]) ? _offsetModifierState$2 : 0;
                var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
                var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
                var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
                popperOffsets[altAxis] = _preventedOffset;
                data[altAxis] = _preventedOffset - _offset;
            }
            state.modifiersData[name] = data;
        }
        const modifiers_preventOverflow = {
            name: "preventOverflow",
            enabled: true,
            phase: "main",
            fn: preventOverflow,
            requiresIfExists: [ "offset" ]
        };
        function getHTMLElementScroll(element) {
            return {
                scrollLeft: element.scrollLeft,
                scrollTop: element.scrollTop
            };
        }
        function getNodeScroll(node) {
            if (node === getWindow_getWindow(node) || !isHTMLElement(node)) return getWindowScroll(node); else return getHTMLElementScroll(node);
        }
        function isElementScaled(element) {
            var rect = element.getBoundingClientRect();
            var scaleX = round(rect.width) / element.offsetWidth || 1;
            var scaleY = round(rect.height) / element.offsetHeight || 1;
            return 1 !== scaleX || 1 !== scaleY;
        }
        function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
            if (void 0 === isFixed) isFixed = false;
            var isOffsetParentAnElement = isHTMLElement(offsetParent);
            var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
            var documentElement = getDocumentElement(offsetParent);
            var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
            var scroll = {
                scrollLeft: 0,
                scrollTop: 0
            };
            var offsets = {
                x: 0,
                y: 0
            };
            if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
                if ("body" !== getNodeName(offsetParent) || isScrollParent(documentElement)) scroll = getNodeScroll(offsetParent);
                if (isHTMLElement(offsetParent)) {
                    offsets = getBoundingClientRect(offsetParent, true);
                    offsets.x += offsetParent.clientLeft;
                    offsets.y += offsetParent.clientTop;
                } else if (documentElement) offsets.x = getWindowScrollBarX(documentElement);
            }
            return {
                x: rect.left + scroll.scrollLeft - offsets.x,
                y: rect.top + scroll.scrollTop - offsets.y,
                width: rect.width,
                height: rect.height
            };
        }
        function order(modifiers) {
            var map = new Map;
            var visited = new Set;
            var result = [];
            modifiers.forEach((function(modifier) {
                map.set(modifier.name, modifier);
            }));
            function sort(modifier) {
                visited.add(modifier.name);
                var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
                requires.forEach((function(dep) {
                    if (!visited.has(dep)) {
                        var depModifier = map.get(dep);
                        if (depModifier) sort(depModifier);
                    }
                }));
                result.push(modifier);
            }
            modifiers.forEach((function(modifier) {
                if (!visited.has(modifier.name)) sort(modifier);
            }));
            return result;
        }
        function orderModifiers(modifiers) {
            var orderedModifiers = order(modifiers);
            return modifierPhases.reduce((function(acc, phase) {
                return acc.concat(orderedModifiers.filter((function(modifier) {
                    return modifier.phase === phase;
                })));
            }), []);
        }
        function debounce(fn) {
            var pending;
            return function() {
                if (!pending) pending = new Promise((function(resolve) {
                    Promise.resolve().then((function() {
                        pending = void 0;
                        resolve(fn());
                    }));
                }));
                return pending;
            };
        }
        function mergeByName(modifiers) {
            var merged = modifiers.reduce((function(merged, current) {
                var existing = merged[current.name];
                merged[current.name] = existing ? Object.assign({}, existing, current, {
                    options: Object.assign({}, existing.options, current.options),
                    data: Object.assign({}, existing.data, current.data)
                }) : current;
                return merged;
            }), {});
            return Object.keys(merged).map((function(key) {
                return merged[key];
            }));
        }
        var DEFAULT_OPTIONS = {
            placement: "bottom",
            modifiers: [],
            strategy: "absolute"
        };
        function areValidElements() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return !args.some((function(element) {
                return !(element && "function" === typeof element.getBoundingClientRect);
            }));
        }
        function popperGenerator(generatorOptions) {
            if (void 0 === generatorOptions) generatorOptions = {};
            var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = void 0 === _generatorOptions$def ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = void 0 === _generatorOptions$def2 ? DEFAULT_OPTIONS : _generatorOptions$def2;
            return function createPopper(reference, popper, options) {
                if (void 0 === options) options = defaultOptions;
                var state = {
                    placement: "bottom",
                    orderedModifiers: [],
                    options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
                    modifiersData: {},
                    elements: {
                        reference,
                        popper
                    },
                    attributes: {},
                    styles: {}
                };
                var effectCleanupFns = [];
                var isDestroyed = false;
                var instance = {
                    state,
                    setOptions: function setOptions(setOptionsAction) {
                        var options = "function" === typeof setOptionsAction ? setOptionsAction(state.options) : setOptionsAction;
                        cleanupModifierEffects();
                        state.options = Object.assign({}, defaultOptions, state.options, options);
                        state.scrollParents = {
                            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
                            popper: listScrollParents(popper)
                        };
                        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers)));
                        state.orderedModifiers = orderedModifiers.filter((function(m) {
                            return m.enabled;
                        }));
                        if (false) ;
                        runModifierEffects();
                        return instance.update();
                    },
                    forceUpdate: function forceUpdate() {
                        if (isDestroyed) return;
                        var _state$elements = state.elements, reference = _state$elements.reference, popper = _state$elements.popper;
                        if (!areValidElements(reference, popper)) {
                            if (false) ;
                            return;
                        }
                        state.rects = {
                            reference: getCompositeRect(reference, getOffsetParent(popper), "fixed" === state.options.strategy),
                            popper: getLayoutRect(popper)
                        };
                        state.reset = false;
                        state.placement = state.options.placement;
                        state.orderedModifiers.forEach((function(modifier) {
                            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                        }));
                        for (var index = 0; index < state.orderedModifiers.length; index++) {
                            if (false) ;
                            if (true === state.reset) {
                                state.reset = false;
                                index = -1;
                                continue;
                            }
                            var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = void 0 === _state$orderedModifie2 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                            if ("function" === typeof fn) state = fn({
                                state,
                                options: _options,
                                name,
                                instance
                            }) || state;
                        }
                    },
                    update: debounce((function() {
                        return new Promise((function(resolve) {
                            instance.forceUpdate();
                            resolve(state);
                        }));
                    })),
                    destroy: function destroy() {
                        cleanupModifierEffects();
                        isDestroyed = true;
                    }
                };
                if (!areValidElements(reference, popper)) {
                    if (false) ;
                    return instance;
                }
                instance.setOptions(options).then((function(state) {
                    if (!isDestroyed && options.onFirstUpdate) options.onFirstUpdate(state);
                }));
                function runModifierEffects() {
                    state.orderedModifiers.forEach((function(_ref3) {
                        var name = _ref3.name, _ref3$options = _ref3.options, options = void 0 === _ref3$options ? {} : _ref3$options, effect = _ref3.effect;
                        if ("function" === typeof effect) {
                            var cleanupFn = effect({
                                state,
                                name,
                                instance,
                                options
                            });
                            var noopFn = function noopFn() {};
                            effectCleanupFns.push(cleanupFn || noopFn);
                        }
                    }));
                }
                function cleanupModifierEffects() {
                    effectCleanupFns.forEach((function(fn) {
                        return fn();
                    }));
                    effectCleanupFns = [];
                }
                return instance;
            };
        }
        var createPopper = popperGenerator();
        var defaultModifiers = [ eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles, modifiers_offset, modifiers_flip, modifiers_preventOverflow, modifiers_arrow, modifiers_hide ];
        var popper_createPopper = popperGenerator({
            defaultModifiers
        });
        var popper_lite_defaultModifiers = [ eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles ];
        var popper_lite_createPopper = popperGenerator({
            defaultModifiers: popper_lite_defaultModifiers
        });
        /*!
  * Bootstrap v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
        const MAX_UID = 1e6;
        const MILLISECONDS_MULTIPLIER = 1e3;
        const TRANSITION_END = "transitionend";
        const toType = obj => {
            if (null === obj || void 0 === obj) return `${obj}`;
            return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
        };
        const getUID = prefix => {
            do {
                prefix += Math.floor(Math.random() * MAX_UID);
            } while (document.getElementById(prefix));
            return prefix;
        };
        const getSelector = element => {
            let selector = element.getAttribute("data-bs-target");
            if (!selector || "#" === selector) {
                let hrefAttr = element.getAttribute("href");
                if (!hrefAttr || !hrefAttr.includes("#") && !hrefAttr.startsWith(".")) return null;
                if (hrefAttr.includes("#") && !hrefAttr.startsWith("#")) hrefAttr = `#${hrefAttr.split("#")[1]}`;
                selector = hrefAttr && "#" !== hrefAttr ? hrefAttr.trim() : null;
            }
            return selector;
        };
        const getSelectorFromElement = element => {
            const selector = getSelector(element);
            if (selector) return document.querySelector(selector) ? selector : null;
            return null;
        };
        const getElementFromSelector = element => {
            const selector = getSelector(element);
            return selector ? document.querySelector(selector) : null;
        };
        const getTransitionDurationFromElement = element => {
            if (!element) return 0;
            let {transitionDuration, transitionDelay} = window.getComputedStyle(element);
            const floatTransitionDuration = Number.parseFloat(transitionDuration);
            const floatTransitionDelay = Number.parseFloat(transitionDelay);
            if (!floatTransitionDuration && !floatTransitionDelay) return 0;
            transitionDuration = transitionDuration.split(",")[0];
            transitionDelay = transitionDelay.split(",")[0];
            return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
        };
        const triggerTransitionEnd = element => {
            element.dispatchEvent(new Event(TRANSITION_END));
        };
        const bootstrap_esm_isElement = obj => {
            if (!obj || "object" !== typeof obj) return false;
            if ("undefined" !== typeof obj.jquery) obj = obj[0];
            return "undefined" !== typeof obj.nodeType;
        };
        const getElement = obj => {
            if (bootstrap_esm_isElement(obj)) return obj.jquery ? obj[0] : obj;
            if ("string" === typeof obj && obj.length > 0) return document.querySelector(obj);
            return null;
        };
        const typeCheckConfig = (componentName, config, configTypes) => {
            Object.keys(configTypes).forEach((property => {
                const expectedTypes = configTypes[property];
                const value = config[property];
                const valueType = value && bootstrap_esm_isElement(value) ? "element" : toType(value);
                if (!new RegExp(expectedTypes).test(valueType)) throw new TypeError(`${componentName.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
            }));
        };
        const isVisible = element => {
            if (!bootstrap_esm_isElement(element) || 0 === element.getClientRects().length) return false;
            return "visible" === getComputedStyle(element).getPropertyValue("visibility");
        };
        const isDisabled = element => {
            if (!element || element.nodeType !== Node.ELEMENT_NODE) return true;
            if (element.classList.contains("disabled")) return true;
            if ("undefined" !== typeof element.disabled) return element.disabled;
            return element.hasAttribute("disabled") && "false" !== element.getAttribute("disabled");
        };
        const findShadowRoot = element => {
            if (!document.documentElement.attachShadow) return null;
            if ("function" === typeof element.getRootNode) {
                const root = element.getRootNode();
                return root instanceof ShadowRoot ? root : null;
            }
            if (element instanceof ShadowRoot) return element;
            if (!element.parentNode) return null;
            return findShadowRoot(element.parentNode);
        };
        const noop = () => {};
        const reflow = element => {
            element.offsetHeight;
        };
        const getjQuery = () => {
            const {jQuery} = window;
            if (jQuery && !document.body.hasAttribute("data-bs-no-jquery")) return jQuery;
            return null;
        };
        const DOMContentLoadedCallbacks = [];
        const onDOMContentLoaded = callback => {
            if ("loading" === document.readyState) {
                if (!DOMContentLoadedCallbacks.length) document.addEventListener("DOMContentLoaded", (() => {
                    DOMContentLoadedCallbacks.forEach((callback => callback()));
                }));
                DOMContentLoadedCallbacks.push(callback);
            } else callback();
        };
        const isRTL = () => "rtl" === document.documentElement.dir;
        const defineJQueryPlugin = plugin => {
            onDOMContentLoaded((() => {
                const $ = getjQuery();
                if ($) {
                    const name = plugin.NAME;
                    const JQUERY_NO_CONFLICT = $.fn[name];
                    $.fn[name] = plugin.jQueryInterface;
                    $.fn[name].Constructor = plugin;
                    $.fn[name].noConflict = () => {
                        $.fn[name] = JQUERY_NO_CONFLICT;
                        return plugin.jQueryInterface;
                    };
                }
            }));
        };
        const execute = callback => {
            if ("function" === typeof callback) callback();
        };
        const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
            if (!waitForTransition) {
                execute(callback);
                return;
            }
            const durationPadding = 5;
            const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
            let called = false;
            const handler = ({target}) => {
                if (target !== transitionElement) return;
                called = true;
                transitionElement.removeEventListener(TRANSITION_END, handler);
                execute(callback);
            };
            transitionElement.addEventListener(TRANSITION_END, handler);
            setTimeout((() => {
                if (!called) triggerTransitionEnd(transitionElement);
            }), emulatedDuration);
        };
        const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
            let index = list.indexOf(activeElement);
            if (-1 === index) return list[!shouldGetNext && isCycleAllowed ? list.length - 1 : 0];
            const listLength = list.length;
            index += shouldGetNext ? 1 : -1;
            if (isCycleAllowed) index = (index + listLength) % listLength;
            return list[Math.max(0, Math.min(index, listLength - 1))];
        };
        const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
        const stripNameRegex = /\..*/;
        const stripUidRegex = /::\d+$/;
        const eventRegistry = {};
        let uidEvent = 1;
        const customEvents = {
            mouseenter: "mouseover",
            mouseleave: "mouseout"
        };
        const customEventsRegex = /^(mouseenter|mouseleave)/i;
        const nativeEvents = new Set([ "click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll" ]);
        function getUidEvent(element, uid) {
            return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
        }
        function getEvent(element) {
            const uid = getUidEvent(element);
            element.uidEvent = uid;
            eventRegistry[uid] = eventRegistry[uid] || {};
            return eventRegistry[uid];
        }
        function bootstrapHandler(element, fn) {
            return function handler(event) {
                event.delegateTarget = element;
                if (handler.oneOff) EventHandler.off(element, event.type, fn);
                return fn.apply(element, [ event ]);
            };
        }
        function bootstrapDelegationHandler(element, selector, fn) {
            return function handler(event) {
                const domElements = element.querySelectorAll(selector);
                for (let {target} = event; target && target !== this; target = target.parentNode) for (let i = domElements.length; i--; ) if (domElements[i] === target) {
                    event.delegateTarget = target;
                    if (handler.oneOff) EventHandler.off(element, event.type, selector, fn);
                    return fn.apply(target, [ event ]);
                }
                return null;
            };
        }
        function findHandler(events, handler, delegationSelector = null) {
            const uidEventList = Object.keys(events);
            for (let i = 0, len = uidEventList.length; i < len; i++) {
                const event = events[uidEventList[i]];
                if (event.originalHandler === handler && event.delegationSelector === delegationSelector) return event;
            }
            return null;
        }
        function normalizeParams(originalTypeEvent, handler, delegationFn) {
            const delegation = "string" === typeof handler;
            const originalHandler = delegation ? delegationFn : handler;
            let typeEvent = getTypeEvent(originalTypeEvent);
            const isNative = nativeEvents.has(typeEvent);
            if (!isNative) typeEvent = originalTypeEvent;
            return [ delegation, originalHandler, typeEvent ];
        }
        function addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) {
            if ("string" !== typeof originalTypeEvent || !element) return;
            if (!handler) {
                handler = delegationFn;
                delegationFn = null;
            }
            if (customEventsRegex.test(originalTypeEvent)) {
                const wrapFn = fn => function(event) {
                    if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) return fn.call(this, event);
                };
                if (delegationFn) delegationFn = wrapFn(delegationFn); else handler = wrapFn(handler);
            }
            const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);
            const events = getEvent(element);
            const handlers = events[typeEvent] || (events[typeEvent] = {});
            const previousFn = findHandler(handlers, originalHandler, delegation ? handler : null);
            if (previousFn) {
                previousFn.oneOff = previousFn.oneOff && oneOff;
                return;
            }
            const uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex, ""));
            const fn = delegation ? bootstrapDelegationHandler(element, handler, delegationFn) : bootstrapHandler(element, handler);
            fn.delegationSelector = delegation ? handler : null;
            fn.originalHandler = originalHandler;
            fn.oneOff = oneOff;
            fn.uidEvent = uid;
            handlers[uid] = fn;
            element.addEventListener(typeEvent, fn, delegation);
        }
        function removeHandler(element, events, typeEvent, handler, delegationSelector) {
            const fn = findHandler(events[typeEvent], handler, delegationSelector);
            if (!fn) return;
            element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
            delete events[typeEvent][fn.uidEvent];
        }
        function removeNamespacedHandlers(element, events, typeEvent, namespace) {
            const storeElementEvent = events[typeEvent] || {};
            Object.keys(storeElementEvent).forEach((handlerKey => {
                if (handlerKey.includes(namespace)) {
                    const event = storeElementEvent[handlerKey];
                    removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
                }
            }));
        }
        function getTypeEvent(event) {
            event = event.replace(stripNameRegex, "");
            return customEvents[event] || event;
        }
        const EventHandler = {
            on(element, event, handler, delegationFn) {
                addHandler(element, event, handler, delegationFn, false);
            },
            one(element, event, handler, delegationFn) {
                addHandler(element, event, handler, delegationFn, true);
            },
            off(element, originalTypeEvent, handler, delegationFn) {
                if ("string" !== typeof originalTypeEvent || !element) return;
                const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);
                const inNamespace = typeEvent !== originalTypeEvent;
                const events = getEvent(element);
                const isNamespace = originalTypeEvent.startsWith(".");
                if ("undefined" !== typeof originalHandler) {
                    if (!events || !events[typeEvent]) return;
                    removeHandler(element, events, typeEvent, originalHandler, delegation ? handler : null);
                    return;
                }
                if (isNamespace) Object.keys(events).forEach((elementEvent => {
                    removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
                }));
                const storeElementEvent = events[typeEvent] || {};
                Object.keys(storeElementEvent).forEach((keyHandlers => {
                    const handlerKey = keyHandlers.replace(stripUidRegex, "");
                    if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
                        const event = storeElementEvent[keyHandlers];
                        removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
                    }
                }));
            },
            trigger(element, event, args) {
                if ("string" !== typeof event || !element) return null;
                const $ = getjQuery();
                const typeEvent = getTypeEvent(event);
                const inNamespace = event !== typeEvent;
                const isNative = nativeEvents.has(typeEvent);
                let jQueryEvent;
                let bubbles = true;
                let nativeDispatch = true;
                let defaultPrevented = false;
                let evt = null;
                if (inNamespace && $) {
                    jQueryEvent = $.Event(event, args);
                    $(element).trigger(jQueryEvent);
                    bubbles = !jQueryEvent.isPropagationStopped();
                    nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
                    defaultPrevented = jQueryEvent.isDefaultPrevented();
                }
                if (isNative) {
                    evt = document.createEvent("HTMLEvents");
                    evt.initEvent(typeEvent, bubbles, true);
                } else evt = new CustomEvent(event, {
                    bubbles,
                    cancelable: true
                });
                if ("undefined" !== typeof args) Object.keys(args).forEach((key => {
                    Object.defineProperty(evt, key, {
                        get() {
                            return args[key];
                        }
                    });
                }));
                if (defaultPrevented) evt.preventDefault();
                if (nativeDispatch) element.dispatchEvent(evt);
                if (evt.defaultPrevented && "undefined" !== typeof jQueryEvent) jQueryEvent.preventDefault();
                return evt;
            }
        };
        const elementMap = new Map;
        const Data = {
            set(element, key, instance) {
                if (!elementMap.has(element)) elementMap.set(element, new Map);
                const instanceMap = elementMap.get(element);
                if (!instanceMap.has(key) && 0 !== instanceMap.size) {
                    console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
                    return;
                }
                instanceMap.set(key, instance);
            },
            get(element, key) {
                if (elementMap.has(element)) return elementMap.get(element).get(key) || null;
                return null;
            },
            remove(element, key) {
                if (!elementMap.has(element)) return;
                const instanceMap = elementMap.get(element);
                instanceMap.delete(key);
                if (0 === instanceMap.size) elementMap.delete(element);
            }
        };
        const VERSION = "5.1.3";
        class BaseComponent {
            constructor(element) {
                element = getElement(element);
                if (!element) return;
                this._element = element;
                Data.set(this._element, this.constructor.DATA_KEY, this);
            }
            dispose() {
                Data.remove(this._element, this.constructor.DATA_KEY);
                EventHandler.off(this._element, this.constructor.EVENT_KEY);
                Object.getOwnPropertyNames(this).forEach((propertyName => {
                    this[propertyName] = null;
                }));
            }
            _queueCallback(callback, element, isAnimated = true) {
                executeAfterTransition(callback, element, isAnimated);
            }
            static getInstance(element) {
                return Data.get(getElement(element), this.DATA_KEY);
            }
            static getOrCreateInstance(element, config = {}) {
                return this.getInstance(element) || new this(element, "object" === typeof config ? config : null);
            }
            static get VERSION() {
                return VERSION;
            }
            static get NAME() {
                throw new Error('You have to implement the static method "NAME", for each component!');
            }
            static get DATA_KEY() {
                return `bs.${this.NAME}`;
            }
            static get EVENT_KEY() {
                return `.${this.DATA_KEY}`;
            }
        }
        const enableDismissTrigger = (component, method = "hide") => {
            const clickEvent = `click.dismiss${component.EVENT_KEY}`;
            const name = component.NAME;
            EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, (function(event) {
                if ([ "A", "AREA" ].includes(this.tagName)) event.preventDefault();
                if (isDisabled(this)) return;
                const target = getElementFromSelector(this) || this.closest(`.${name}`);
                const instance = component.getOrCreateInstance(target);
                instance[method]();
            }));
        };
        const NAME$d = "alert";
        const DATA_KEY$c = "bs.alert";
        const EVENT_KEY$c = `.${DATA_KEY$c}`;
        const EVENT_CLOSE = `close${EVENT_KEY$c}`;
        const EVENT_CLOSED = `closed${EVENT_KEY$c}`;
        const CLASS_NAME_FADE$5 = "fade";
        const CLASS_NAME_SHOW$8 = "show";
        class Alert extends BaseComponent {
            static get NAME() {
                return NAME$d;
            }
            close() {
                const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
                if (closeEvent.defaultPrevented) return;
                this._element.classList.remove(CLASS_NAME_SHOW$8);
                const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
                this._queueCallback((() => this._destroyElement()), this._element, isAnimated);
            }
            _destroyElement() {
                this._element.remove();
                EventHandler.trigger(this._element, EVENT_CLOSED);
                this.dispose();
            }
            static jQueryInterface(config) {
                return this.each((function() {
                    const data = Alert.getOrCreateInstance(this);
                    if ("string" !== typeof config) return;
                    if (void 0 === data[config] || config.startsWith("_") || "constructor" === config) throw new TypeError(`No method named "${config}"`);
                    data[config](this);
                }));
            }
        }
        enableDismissTrigger(Alert, "close");
        defineJQueryPlugin(Alert);
        const NAME$c = "button";
        const DATA_KEY$b = "bs.button";
        const EVENT_KEY$b = `.${DATA_KEY$b}`;
        const DATA_API_KEY$7 = ".data-api";
        const CLASS_NAME_ACTIVE$3 = "active";
        const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
        const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$b}${DATA_API_KEY$7}`;
        class Button extends BaseComponent {
            static get NAME() {
                return NAME$c;
            }
            toggle() {
                this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
            }
            static jQueryInterface(config) {
                return this.each((function() {
                    const data = Button.getOrCreateInstance(this);
                    if ("toggle" === config) data[config]();
                }));
            }
        }
        EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event => {
            event.preventDefault();
            const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
            const data = Button.getOrCreateInstance(button);
            data.toggle();
        }));
        defineJQueryPlugin(Button);
        function normalizeData(val) {
            if ("true" === val) return true;
            if ("false" === val) return false;
            if (val === Number(val).toString()) return Number(val);
            if ("" === val || "null" === val) return null;
            return val;
        }
        function normalizeDataKey(key) {
            return key.replace(/[A-Z]/g, (chr => `-${chr.toLowerCase()}`));
        }
        const Manipulator = {
            setDataAttribute(element, key, value) {
                element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
            },
            removeDataAttribute(element, key) {
                element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
            },
            getDataAttributes(element) {
                if (!element) return {};
                const attributes = {};
                Object.keys(element.dataset).filter((key => key.startsWith("bs"))).forEach((key => {
                    let pureKey = key.replace(/^bs/, "");
                    pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
                    attributes[pureKey] = normalizeData(element.dataset[key]);
                }));
                return attributes;
            },
            getDataAttribute(element, key) {
                return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
            },
            offset(element) {
                const rect = element.getBoundingClientRect();
                return {
                    top: rect.top + window.pageYOffset,
                    left: rect.left + window.pageXOffset
                };
            },
            position(element) {
                return {
                    top: element.offsetTop,
                    left: element.offsetLeft
                };
            }
        };
        const NODE_TEXT = 3;
        const SelectorEngine = {
            find(selector, element = document.documentElement) {
                return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
            },
            findOne(selector, element = document.documentElement) {
                return Element.prototype.querySelector.call(element, selector);
            },
            children(element, selector) {
                return [].concat(...element.children).filter((child => child.matches(selector)));
            },
            parents(element, selector) {
                const parents = [];
                let ancestor = element.parentNode;
                while (ancestor && ancestor.nodeType === Node.ELEMENT_NODE && ancestor.nodeType !== NODE_TEXT) {
                    if (ancestor.matches(selector)) parents.push(ancestor);
                    ancestor = ancestor.parentNode;
                }
                return parents;
            },
            prev(element, selector) {
                let previous = element.previousElementSibling;
                while (previous) {
                    if (previous.matches(selector)) return [ previous ];
                    previous = previous.previousElementSibling;
                }
                return [];
            },
            next(element, selector) {
                let next = element.nextElementSibling;
                while (next) {
                    if (next.matches(selector)) return [ next ];
                    next = next.nextElementSibling;
                }
                return [];
            },
            focusableChildren(element) {
                const focusables = [ "a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]' ].map((selector => `${selector}:not([tabindex^="-"])`)).join(", ");
                return this.find(focusables, element).filter((el => !isDisabled(el) && isVisible(el)));
            }
        };
        const NAME$b = "carousel";
        const DATA_KEY$a = "bs.carousel";
        const EVENT_KEY$a = `.${DATA_KEY$a}`;
        const DATA_API_KEY$6 = ".data-api";
        const ARROW_LEFT_KEY = "ArrowLeft";
        const ARROW_RIGHT_KEY = "ArrowRight";
        const TOUCHEVENT_COMPAT_WAIT = 500;
        const SWIPE_THRESHOLD = 40;
        const Default$a = {
            interval: 5e3,
            keyboard: true,
            slide: false,
            pause: "hover",
            wrap: true,
            touch: true
        };
        const DefaultType$a = {
            interval: "(number|boolean)",
            keyboard: "boolean",
            slide: "(boolean|string)",
            pause: "(string|boolean)",
            wrap: "boolean",
            touch: "boolean"
        };
        const ORDER_NEXT = "next";
        const ORDER_PREV = "prev";
        const DIRECTION_LEFT = "left";
        const DIRECTION_RIGHT = "right";
        const KEY_TO_DIRECTION = {
            [ARROW_LEFT_KEY]: DIRECTION_RIGHT,
            [ARROW_RIGHT_KEY]: DIRECTION_LEFT
        };
        const EVENT_SLIDE = `slide${EVENT_KEY$a}`;
        const EVENT_SLID = `slid${EVENT_KEY$a}`;
        const EVENT_KEYDOWN = `keydown${EVENT_KEY$a}`;
        const EVENT_MOUSEENTER = `mouseenter${EVENT_KEY$a}`;
        const EVENT_MOUSELEAVE = `mouseleave${EVENT_KEY$a}`;
        const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$a}`;
        const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$a}`;
        const EVENT_TOUCHEND = `touchend${EVENT_KEY$a}`;
        const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$a}`;
        const EVENT_POINTERUP = `pointerup${EVENT_KEY$a}`;
        const EVENT_DRAG_START = `dragstart${EVENT_KEY$a}`;
        const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$a}${DATA_API_KEY$6}`;
        const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
        const CLASS_NAME_CAROUSEL = "carousel";
        const CLASS_NAME_ACTIVE$2 = "active";
        const CLASS_NAME_SLIDE = "slide";
        const CLASS_NAME_END = "carousel-item-end";
        const CLASS_NAME_START = "carousel-item-start";
        const CLASS_NAME_NEXT = "carousel-item-next";
        const CLASS_NAME_PREV = "carousel-item-prev";
        const CLASS_NAME_POINTER_EVENT = "pointer-event";
        const SELECTOR_ACTIVE$1 = ".active";
        const SELECTOR_ACTIVE_ITEM = ".active.carousel-item";
        const SELECTOR_ITEM = ".carousel-item";
        const SELECTOR_ITEM_IMG = ".carousel-item img";
        const SELECTOR_NEXT_PREV = ".carousel-item-next, .carousel-item-prev";
        const SELECTOR_INDICATORS = ".carousel-indicators";
        const SELECTOR_INDICATOR = "[data-bs-target]";
        const SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
        const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
        const POINTER_TYPE_TOUCH = "touch";
        const POINTER_TYPE_PEN = "pen";
        class Carousel extends BaseComponent {
            constructor(element, config) {
                super(element);
                this._items = null;
                this._interval = null;
                this._activeElement = null;
                this._isPaused = false;
                this._isSliding = false;
                this.touchTimeout = null;
                this.touchStartX = 0;
                this.touchDeltaX = 0;
                this._config = this._getConfig(config);
                this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
                this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
                this._pointerEvent = Boolean(window.PointerEvent);
                this._addEventListeners();
            }
            static get Default() {
                return Default$a;
            }
            static get NAME() {
                return NAME$b;
            }
            next() {
                this._slide(ORDER_NEXT);
            }
            nextWhenVisible() {
                if (!document.hidden && isVisible(this._element)) this.next();
            }
            prev() {
                this._slide(ORDER_PREV);
            }
            pause(event) {
                if (!event) this._isPaused = true;
                if (SelectorEngine.findOne(SELECTOR_NEXT_PREV, this._element)) {
                    triggerTransitionEnd(this._element);
                    this.cycle(true);
                }
                clearInterval(this._interval);
                this._interval = null;
            }
            cycle(event) {
                if (!event) this._isPaused = false;
                if (this._interval) {
                    clearInterval(this._interval);
                    this._interval = null;
                }
                if (this._config && this._config.interval && !this._isPaused) {
                    this._updateInterval();
                    this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
                }
            }
            to(index) {
                this._activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
                const activeIndex = this._getItemIndex(this._activeElement);
                if (index > this._items.length - 1 || index < 0) return;
                if (this._isSliding) {
                    EventHandler.one(this._element, EVENT_SLID, (() => this.to(index)));
                    return;
                }
                if (activeIndex === index) {
                    this.pause();
                    this.cycle();
                    return;
                }
                const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
                this._slide(order, this._items[index]);
            }
            _getConfig(config) {
                config = {
                    ...Default$a,
                    ...Manipulator.getDataAttributes(this._element),
                    ..."object" === typeof config ? config : {}
                };
                typeCheckConfig(NAME$b, config, DefaultType$a);
                return config;
            }
            _handleSwipe() {
                const absDeltax = Math.abs(this.touchDeltaX);
                if (absDeltax <= SWIPE_THRESHOLD) return;
                const direction = absDeltax / this.touchDeltaX;
                this.touchDeltaX = 0;
                if (!direction) return;
                this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);
            }
            _addEventListeners() {
                if (this._config.keyboard) EventHandler.on(this._element, EVENT_KEYDOWN, (event => this._keydown(event)));
                if ("hover" === this._config.pause) {
                    EventHandler.on(this._element, EVENT_MOUSEENTER, (event => this.pause(event)));
                    EventHandler.on(this._element, EVENT_MOUSELEAVE, (event => this.cycle(event)));
                }
                if (this._config.touch && this._touchSupported) this._addTouchEventListeners();
            }
            _addTouchEventListeners() {
                const hasPointerPenTouch = event => this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
                const start = event => {
                    if (hasPointerPenTouch(event)) this.touchStartX = event.clientX; else if (!this._pointerEvent) this.touchStartX = event.touches[0].clientX;
                };
                const move = event => {
                    this.touchDeltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this.touchStartX;
                };
                const end = event => {
                    if (hasPointerPenTouch(event)) this.touchDeltaX = event.clientX - this.touchStartX;
                    this._handleSwipe();
                    if ("hover" === this._config.pause) {
                        this.pause();
                        if (this.touchTimeout) clearTimeout(this.touchTimeout);
                        this.touchTimeout = setTimeout((event => this.cycle(event)), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
                    }
                };
                SelectorEngine.find(SELECTOR_ITEM_IMG, this._element).forEach((itemImg => {
                    EventHandler.on(itemImg, EVENT_DRAG_START, (event => event.preventDefault()));
                }));
                if (this._pointerEvent) {
                    EventHandler.on(this._element, EVENT_POINTERDOWN, (event => start(event)));
                    EventHandler.on(this._element, EVENT_POINTERUP, (event => end(event)));
                    this._element.classList.add(CLASS_NAME_POINTER_EVENT);
                } else {
                    EventHandler.on(this._element, EVENT_TOUCHSTART, (event => start(event)));
                    EventHandler.on(this._element, EVENT_TOUCHMOVE, (event => move(event)));
                    EventHandler.on(this._element, EVENT_TOUCHEND, (event => end(event)));
                }
            }
            _keydown(event) {
                if (/input|textarea/i.test(event.target.tagName)) return;
                const direction = KEY_TO_DIRECTION[event.key];
                if (direction) {
                    event.preventDefault();
                    this._slide(direction);
                }
            }
            _getItemIndex(element) {
                this._items = element && element.parentNode ? SelectorEngine.find(SELECTOR_ITEM, element.parentNode) : [];
                return this._items.indexOf(element);
            }
            _getItemByOrder(order, activeElement) {
                const isNext = order === ORDER_NEXT;
                return getNextActiveElement(this._items, activeElement, isNext, this._config.wrap);
            }
            _triggerSlideEvent(relatedTarget, eventDirectionName) {
                const targetIndex = this._getItemIndex(relatedTarget);
                const fromIndex = this._getItemIndex(SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element));
                return EventHandler.trigger(this._element, EVENT_SLIDE, {
                    relatedTarget,
                    direction: eventDirectionName,
                    from: fromIndex,
                    to: targetIndex
                });
            }
            _setActiveIndicatorElement(element) {
                if (this._indicatorsElement) {
                    const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE$1, this._indicatorsElement);
                    activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
                    activeIndicator.removeAttribute("aria-current");
                    const indicators = SelectorEngine.find(SELECTOR_INDICATOR, this._indicatorsElement);
                    for (let i = 0; i < indicators.length; i++) if (Number.parseInt(indicators[i].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(element)) {
                        indicators[i].classList.add(CLASS_NAME_ACTIVE$2);
                        indicators[i].setAttribute("aria-current", "true");
                        break;
                    }
                }
            }
            _updateInterval() {
                const element = this._activeElement || SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
                if (!element) return;
                const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
                if (elementInterval) {
                    this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
                    this._config.interval = elementInterval;
                } else this._config.interval = this._config.defaultInterval || this._config.interval;
            }
            _slide(directionOrOrder, element) {
                const order = this._directionToOrder(directionOrOrder);
                const activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
                const activeElementIndex = this._getItemIndex(activeElement);
                const nextElement = element || this._getItemByOrder(order, activeElement);
                const nextElementIndex = this._getItemIndex(nextElement);
                const isCycling = Boolean(this._interval);
                const isNext = order === ORDER_NEXT;
                const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
                const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
                const eventDirectionName = this._orderToDirection(order);
                if (nextElement && nextElement.classList.contains(CLASS_NAME_ACTIVE$2)) {
                    this._isSliding = false;
                    return;
                }
                if (this._isSliding) return;
                const slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);
                if (slideEvent.defaultPrevented) return;
                if (!activeElement || !nextElement) return;
                this._isSliding = true;
                if (isCycling) this.pause();
                this._setActiveIndicatorElement(nextElement);
                this._activeElement = nextElement;
                const triggerSlidEvent = () => {
                    EventHandler.trigger(this._element, EVENT_SLID, {
                        relatedTarget: nextElement,
                        direction: eventDirectionName,
                        from: activeElementIndex,
                        to: nextElementIndex
                    });
                };
                if (this._element.classList.contains(CLASS_NAME_SLIDE)) {
                    nextElement.classList.add(orderClassName);
                    reflow(nextElement);
                    activeElement.classList.add(directionalClassName);
                    nextElement.classList.add(directionalClassName);
                    const completeCallBack = () => {
                        nextElement.classList.remove(directionalClassName, orderClassName);
                        nextElement.classList.add(CLASS_NAME_ACTIVE$2);
                        activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
                        this._isSliding = false;
                        setTimeout(triggerSlidEvent, 0);
                    };
                    this._queueCallback(completeCallBack, activeElement, true);
                } else {
                    activeElement.classList.remove(CLASS_NAME_ACTIVE$2);
                    nextElement.classList.add(CLASS_NAME_ACTIVE$2);
                    this._isSliding = false;
                    triggerSlidEvent();
                }
                if (isCycling) this.cycle();
            }
            _directionToOrder(direction) {
                if (![ DIRECTION_RIGHT, DIRECTION_LEFT ].includes(direction)) return direction;
                if (isRTL()) return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
                return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
            }
            _orderToDirection(order) {
                if (![ ORDER_NEXT, ORDER_PREV ].includes(order)) return order;
                if (isRTL()) return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
                return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
            }
            static carouselInterface(element, config) {
                const data = Carousel.getOrCreateInstance(element, config);
                let {_config} = data;
                if ("object" === typeof config) _config = {
                    ..._config,
                    ...config
                };
                const action = "string" === typeof config ? config : _config.slide;
                if ("number" === typeof config) data.to(config); else if ("string" === typeof action) {
                    if ("undefined" === typeof data[action]) throw new TypeError(`No method named "${action}"`);
                    data[action]();
                } else if (_config.interval && _config.ride) {
                    data.pause();
                    data.cycle();
                }
            }
            static jQueryInterface(config) {
                return this.each((function() {
                    Carousel.carouselInterface(this, config);
                }));
            }
            static dataApiClickHandler(event) {
                const target = getElementFromSelector(this);
                if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) return;
                const config = {
                    ...Manipulator.getDataAttributes(target),
                    ...Manipulator.getDataAttributes(this)
                };
                const slideIndex = this.getAttribute("data-bs-slide-to");
                if (slideIndex) config.interval = false;
                Carousel.carouselInterface(target, config);
                if (slideIndex) Carousel.getInstance(target).to(slideIndex);
                event.preventDefault();
            }
        }
        EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler);
        EventHandler.on(window, EVENT_LOAD_DATA_API$2, (() => {
            const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
            for (let i = 0, len = carousels.length; i < len; i++) Carousel.carouselInterface(carousels[i], Carousel.getInstance(carousels[i]));
        }));
        defineJQueryPlugin(Carousel);
        const NAME$a = "collapse";
        const DATA_KEY$9 = "bs.collapse";
        const EVENT_KEY$9 = `.${DATA_KEY$9}`;
        const DATA_API_KEY$5 = ".data-api";
        const Default$9 = {
            toggle: true,
            parent: null
        };
        const DefaultType$9 = {
            toggle: "boolean",
            parent: "(null|element)"
        };
        const EVENT_SHOW$5 = `show${EVENT_KEY$9}`;
        const EVENT_SHOWN$5 = `shown${EVENT_KEY$9}`;
        const EVENT_HIDE$5 = `hide${EVENT_KEY$9}`;
        const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$9}`;
        const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$9}${DATA_API_KEY$5}`;
        const CLASS_NAME_SHOW$7 = "show";
        const CLASS_NAME_COLLAPSE = "collapse";
        const CLASS_NAME_COLLAPSING = "collapsing";
        const CLASS_NAME_COLLAPSED = "collapsed";
        const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
        const CLASS_NAME_HORIZONTAL = "collapse-horizontal";
        const WIDTH = "width";
        const HEIGHT = "height";
        const SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
        const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
        class Collapse extends BaseComponent {
            constructor(element, config) {
                super(element);
                this._isTransitioning = false;
                this._config = this._getConfig(config);
                this._triggerArray = [];
                const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
                for (let i = 0, len = toggleList.length; i < len; i++) {
                    const elem = toggleList[i];
                    const selector = getSelectorFromElement(elem);
                    const filterElement = SelectorEngine.find(selector).filter((foundElem => foundElem === this._element));
                    if (null !== selector && filterElement.length) {
                        this._selector = selector;
                        this._triggerArray.push(elem);
                    }
                }
                this._initializeChildren();
                if (!this._config.parent) this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
                if (this._config.toggle) this.toggle();
            }
            static get Default() {
                return Default$9;
            }
            static get NAME() {
                return NAME$a;
            }
            toggle() {
                if (this._isShown()) this.hide(); else this.show();
            }
            show() {
                if (this._isTransitioning || this._isShown()) return;
                let actives = [];
                let activesData;
                if (this._config.parent) {
                    const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
                    actives = SelectorEngine.find(SELECTOR_ACTIVES, this._config.parent).filter((elem => !children.includes(elem)));
                }
                const container = SelectorEngine.findOne(this._selector);
                if (actives.length) {
                    const tempActiveData = actives.find((elem => container !== elem));
                    activesData = tempActiveData ? Collapse.getInstance(tempActiveData) : null;
                    if (activesData && activesData._isTransitioning) return;
                }
                const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$5);
                if (startEvent.defaultPrevented) return;
                actives.forEach((elemActive => {
                    if (container !== elemActive) Collapse.getOrCreateInstance(elemActive, {
                        toggle: false
                    }).hide();
                    if (!activesData) Data.set(elemActive, DATA_KEY$9, null);
                }));
                const dimension = this._getDimension();
                this._element.classList.remove(CLASS_NAME_COLLAPSE);
                this._element.classList.add(CLASS_NAME_COLLAPSING);
                this._element.style[dimension] = 0;
                this._addAriaAndCollapsedClass(this._triggerArray, true);
                this._isTransitioning = true;
                const complete = () => {
                    this._isTransitioning = false;
                    this._element.classList.remove(CLASS_NAME_COLLAPSING);
                    this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
                    this._element.style[dimension] = "";
                    EventHandler.trigger(this._element, EVENT_SHOWN$5);
                };
                const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
                const scrollSize = `scroll${capitalizedDimension}`;
                this._queueCallback(complete, this._element, true);
                this._element.style[dimension] = `${this._element[scrollSize]}px`;
            }
            hide() {
                if (this._isTransitioning || !this._isShown()) return;
                const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$5);
                if (startEvent.defaultPrevented) return;
                const dimension = this._getDimension();
                this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
                reflow(this._element);
                this._element.classList.add(CLASS_NAME_COLLAPSING);
                this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
                const triggerArrayLength = this._triggerArray.length;
                for (let i = 0; i < triggerArrayLength; i++) {
                    const trigger = this._triggerArray[i];
                    const elem = getElementFromSelector(trigger);
                    if (elem && !this._isShown(elem)) this._addAriaAndCollapsedClass([ trigger ], false);
                }
                this._isTransitioning = true;
                const complete = () => {
                    this._isTransitioning = false;
                    this._element.classList.remove(CLASS_NAME_COLLAPSING);
                    this._element.classList.add(CLASS_NAME_COLLAPSE);
                    EventHandler.trigger(this._element, EVENT_HIDDEN$5);
                };
                this._element.style[dimension] = "";
                this._queueCallback(complete, this._element, true);
            }
            _isShown(element = this._element) {
                return element.classList.contains(CLASS_NAME_SHOW$7);
            }
            _getConfig(config) {
                config = {
                    ...Default$9,
                    ...Manipulator.getDataAttributes(this._element),
                    ...config
                };
                config.toggle = Boolean(config.toggle);
                config.parent = getElement(config.parent);
                typeCheckConfig(NAME$a, config, DefaultType$9);
                return config;
            }
            _getDimension() {
                return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
            }
            _initializeChildren() {
                if (!this._config.parent) return;
                const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
                SelectorEngine.find(SELECTOR_DATA_TOGGLE$4, this._config.parent).filter((elem => !children.includes(elem))).forEach((element => {
                    const selected = getElementFromSelector(element);
                    if (selected) this._addAriaAndCollapsedClass([ element ], this._isShown(selected));
                }));
            }
            _addAriaAndCollapsedClass(triggerArray, isOpen) {
                if (!triggerArray.length) return;
                triggerArray.forEach((elem => {
                    if (isOpen) elem.classList.remove(CLASS_NAME_COLLAPSED); else elem.classList.add(CLASS_NAME_COLLAPSED);
                    elem.setAttribute("aria-expanded", isOpen);
                }));
            }
            static jQueryInterface(config) {
                return this.each((function() {
                    const _config = {};
                    if ("string" === typeof config && /show|hide/.test(config)) _config.toggle = false;
                    const data = Collapse.getOrCreateInstance(this, _config);
                    if ("string" === typeof config) {
                        if ("undefined" === typeof data[config]) throw new TypeError(`No method named "${config}"`);
                        data[config]();
                    }
                }));
            }
        }
        EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, (function(event) {
            if ("A" === event.target.tagName || event.delegateTarget && "A" === event.delegateTarget.tagName) event.preventDefault();
            const selector = getSelectorFromElement(this);
            const selectorElements = SelectorEngine.find(selector);
            selectorElements.forEach((element => {
                Collapse.getOrCreateInstance(element, {
                    toggle: false
                }).toggle();
            }));
        }));
        defineJQueryPlugin(Collapse);
        const NAME$9 = "dropdown";
        const DATA_KEY$8 = "bs.dropdown";
        const EVENT_KEY$8 = `.${DATA_KEY$8}`;
        const DATA_API_KEY$4 = ".data-api";
        const ESCAPE_KEY$2 = "Escape";
        const SPACE_KEY = "Space";
        const TAB_KEY$1 = "Tab";
        const ARROW_UP_KEY = "ArrowUp";
        const ARROW_DOWN_KEY = "ArrowDown";
        const RIGHT_MOUSE_BUTTON = 2;
        const REGEXP_KEYDOWN = new RegExp(`${ARROW_UP_KEY}|${ARROW_DOWN_KEY}|${ESCAPE_KEY$2}`);
        const EVENT_HIDE$4 = `hide${EVENT_KEY$8}`;
        const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$8}`;
        const EVENT_SHOW$4 = `show${EVENT_KEY$8}`;
        const EVENT_SHOWN$4 = `shown${EVENT_KEY$8}`;
        const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$8}${DATA_API_KEY$4}`;
        const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$8}${DATA_API_KEY$4}`;
        const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$8}${DATA_API_KEY$4}`;
        const CLASS_NAME_SHOW$6 = "show";
        const CLASS_NAME_DROPUP = "dropup";
        const CLASS_NAME_DROPEND = "dropend";
        const CLASS_NAME_DROPSTART = "dropstart";
        const CLASS_NAME_NAVBAR = "navbar";
        const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]';
        const SELECTOR_MENU = ".dropdown-menu";
        const SELECTOR_NAVBAR_NAV = ".navbar-nav";
        const SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
        const PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
        const PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
        const PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
        const PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
        const PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
        const PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
        const Default$8 = {
            offset: [ 0, 2 ],
            boundary: "clippingParents",
            reference: "toggle",
            display: "dynamic",
            popperConfig: null,
            autoClose: true
        };
        const DefaultType$8 = {
            offset: "(array|string|function)",
            boundary: "(string|element)",
            reference: "(string|element|object)",
            display: "string",
            popperConfig: "(null|object|function)",
            autoClose: "(boolean|string)"
        };
        class Dropdown extends BaseComponent {
            constructor(element, config) {
                super(element);
                this._popper = null;
                this._config = this._getConfig(config);
                this._menu = this._getMenuElement();
                this._inNavbar = this._detectNavbar();
            }
            static get Default() {
                return Default$8;
            }
            static get DefaultType() {
                return DefaultType$8;
            }
            static get NAME() {
                return NAME$9;
            }
            toggle() {
                return this._isShown() ? this.hide() : this.show();
            }
            show() {
                if (isDisabled(this._element) || this._isShown(this._menu)) return;
                const relatedTarget = {
                    relatedTarget: this._element
                };
                const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, relatedTarget);
                if (showEvent.defaultPrevented) return;
                const parent = Dropdown.getParentFromElement(this._element);
                if (this._inNavbar) Manipulator.setDataAttribute(this._menu, "popper", "none"); else this._createPopper(parent);
                if ("ontouchstart" in document.documentElement && !parent.closest(SELECTOR_NAVBAR_NAV)) [].concat(...document.body.children).forEach((elem => EventHandler.on(elem, "mouseover", noop)));
                this._element.focus();
                this._element.setAttribute("aria-expanded", true);
                this._menu.classList.add(CLASS_NAME_SHOW$6);
                this._element.classList.add(CLASS_NAME_SHOW$6);
                EventHandler.trigger(this._element, EVENT_SHOWN$4, relatedTarget);
            }
            hide() {
                if (isDisabled(this._element) || !this._isShown(this._menu)) return;
                const relatedTarget = {
                    relatedTarget: this._element
                };
                this._completeHide(relatedTarget);
            }
            dispose() {
                if (this._popper) this._popper.destroy();
                super.dispose();
            }
            update() {
                this._inNavbar = this._detectNavbar();
                if (this._popper) this._popper.update();
            }
            _completeHide(relatedTarget) {
                const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4, relatedTarget);
                if (hideEvent.defaultPrevented) return;
                if ("ontouchstart" in document.documentElement) [].concat(...document.body.children).forEach((elem => EventHandler.off(elem, "mouseover", noop)));
                if (this._popper) this._popper.destroy();
                this._menu.classList.remove(CLASS_NAME_SHOW$6);
                this._element.classList.remove(CLASS_NAME_SHOW$6);
                this._element.setAttribute("aria-expanded", "false");
                Manipulator.removeDataAttribute(this._menu, "popper");
                EventHandler.trigger(this._element, EVENT_HIDDEN$4, relatedTarget);
            }
            _getConfig(config) {
                config = {
                    ...this.constructor.Default,
                    ...Manipulator.getDataAttributes(this._element),
                    ...config
                };
                typeCheckConfig(NAME$9, config, this.constructor.DefaultType);
                if ("object" === typeof config.reference && !bootstrap_esm_isElement(config.reference) && "function" !== typeof config.reference.getBoundingClientRect) throw new TypeError(`${NAME$9.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
                return config;
            }
            _createPopper(parent) {
                if ("undefined" === typeof lib_namespaceObject) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
                let referenceElement = this._element;
                if ("parent" === this._config.reference) referenceElement = parent; else if (bootstrap_esm_isElement(this._config.reference)) referenceElement = getElement(this._config.reference); else if ("object" === typeof this._config.reference) referenceElement = this._config.reference;
                const popperConfig = this._getPopperConfig();
                const isDisplayStatic = popperConfig.modifiers.find((modifier => "applyStyles" === modifier.name && false === modifier.enabled));
                this._popper = popper_createPopper(referenceElement, this._menu, popperConfig);
                if (isDisplayStatic) Manipulator.setDataAttribute(this._menu, "popper", "static");
            }
            _isShown(element = this._element) {
                return element.classList.contains(CLASS_NAME_SHOW$6);
            }
            _getMenuElement() {
                return SelectorEngine.next(this._element, SELECTOR_MENU)[0];
            }
            _getPlacement() {
                const parentDropdown = this._element.parentNode;
                if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) return PLACEMENT_RIGHT;
                if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) return PLACEMENT_LEFT;
                const isEnd = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
                if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
                return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
            }
            _detectNavbar() {
                return null !== this._element.closest(`.${CLASS_NAME_NAVBAR}`);
            }
            _getOffset() {
                const {offset} = this._config;
                if ("string" === typeof offset) return offset.split(",").map((val => Number.parseInt(val, 10)));
                if ("function" === typeof offset) return popperData => offset(popperData, this._element);
                return offset;
            }
            _getPopperConfig() {
                const defaultBsPopperConfig = {
                    placement: this._getPlacement(),
                    modifiers: [ {
                        name: "preventOverflow",
                        options: {
                            boundary: this._config.boundary
                        }
                    }, {
                        name: "offset",
                        options: {
                            offset: this._getOffset()
                        }
                    } ]
                };
                if ("static" === this._config.display) defaultBsPopperConfig.modifiers = [ {
                    name: "applyStyles",
                    enabled: false
                } ];
                return {
                    ...defaultBsPopperConfig,
                    ..."function" === typeof this._config.popperConfig ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig
                };
            }
            _selectMenuItem({key, target}) {
                const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(isVisible);
                if (!items.length) return;
                getNextActiveElement(items, target, key === ARROW_DOWN_KEY, !items.includes(target)).focus();
            }
            static jQueryInterface(config) {
                return this.each((function() {
                    const data = Dropdown.getOrCreateInstance(this, config);
                    if ("string" !== typeof config) return;
                    if ("undefined" === typeof data[config]) throw new TypeError(`No method named "${config}"`);
                    data[config]();
                }));
            }
            static clearMenus(event) {
                if (event && (event.button === RIGHT_MOUSE_BUTTON || "keyup" === event.type && event.key !== TAB_KEY$1)) return;
                const toggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE$3);
                for (let i = 0, len = toggles.length; i < len; i++) {
                    const context = Dropdown.getInstance(toggles[i]);
                    if (!context || false === context._config.autoClose) continue;
                    if (!context._isShown()) continue;
                    const relatedTarget = {
                        relatedTarget: context._element
                    };
                    if (event) {
                        const composedPath = event.composedPath();
                        const isMenuTarget = composedPath.includes(context._menu);
                        if (composedPath.includes(context._element) || "inside" === context._config.autoClose && !isMenuTarget || "outside" === context._config.autoClose && isMenuTarget) continue;
                        if (context._menu.contains(event.target) && ("keyup" === event.type && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) continue;
                        if ("click" === event.type) relatedTarget.clickEvent = event;
                    }
                    context._completeHide(relatedTarget);
                }
            }
            static getParentFromElement(element) {
                return getElementFromSelector(element) || element.parentNode;
            }
            static dataApiKeydownHandler(event) {
                if (/input|textarea/i.test(event.target.tagName) ? event.key === SPACE_KEY || event.key !== ESCAPE_KEY$2 && (event.key !== ARROW_DOWN_KEY && event.key !== ARROW_UP_KEY || event.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(event.key)) return;
                const isActive = this.classList.contains(CLASS_NAME_SHOW$6);
                if (!isActive && event.key === ESCAPE_KEY$2) return;
                event.preventDefault();
                event.stopPropagation();
                if (isDisabled(this)) return;
                const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0];
                const instance = Dropdown.getOrCreateInstance(getToggleButton);
                if (event.key === ESCAPE_KEY$2) {
                    instance.hide();
                    return;
                }
                if (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY) {
                    if (!isActive) instance.show();
                    instance._selectMenuItem(event);
                    return;
                }
                if (!isActive || event.key === SPACE_KEY) Dropdown.clearMenus();
            }
        }
        EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
        EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
        EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
        EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
        EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, (function(event) {
            event.preventDefault();
            Dropdown.getOrCreateInstance(this).toggle();
        }));
        defineJQueryPlugin(Dropdown);
        const SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
        const SELECTOR_STICKY_CONTENT = ".sticky-top";
        class ScrollBarHelper {
            constructor() {
                this._element = document.body;
            }
            getWidth() {
                const documentWidth = document.documentElement.clientWidth;
                return Math.abs(window.innerWidth - documentWidth);
            }
            hide() {
                const width = this.getWidth();
                this._disableOverFlow();
                this._setElementAttributes(this._element, "paddingRight", (calculatedValue => calculatedValue + width));
                this._setElementAttributes(SELECTOR_FIXED_CONTENT, "paddingRight", (calculatedValue => calculatedValue + width));
                this._setElementAttributes(SELECTOR_STICKY_CONTENT, "marginRight", (calculatedValue => calculatedValue - width));
            }
            _disableOverFlow() {
                this._saveInitialAttribute(this._element, "overflow");
                this._element.style.overflow = "hidden";
            }
            _setElementAttributes(selector, styleProp, callback) {
                const scrollbarWidth = this.getWidth();
                const manipulationCallBack = element => {
                    if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) return;
                    this._saveInitialAttribute(element, styleProp);
                    const calculatedValue = window.getComputedStyle(element)[styleProp];
                    element.style[styleProp] = `${callback(Number.parseFloat(calculatedValue))}px`;
                };
                this._applyManipulationCallback(selector, manipulationCallBack);
            }
            reset() {
                this._resetElementAttributes(this._element, "overflow");
                this._resetElementAttributes(this._element, "paddingRight");
                this._resetElementAttributes(SELECTOR_FIXED_CONTENT, "paddingRight");
                this._resetElementAttributes(SELECTOR_STICKY_CONTENT, "marginRight");
            }
            _saveInitialAttribute(element, styleProp) {
                const actualValue = element.style[styleProp];
                if (actualValue) Manipulator.setDataAttribute(element, styleProp, actualValue);
            }
            _resetElementAttributes(selector, styleProp) {
                const manipulationCallBack = element => {
                    const value = Manipulator.getDataAttribute(element, styleProp);
                    if ("undefined" === typeof value) element.style.removeProperty(styleProp); else {
                        Manipulator.removeDataAttribute(element, styleProp);
                        element.style[styleProp] = value;
                    }
                };
                this._applyManipulationCallback(selector, manipulationCallBack);
            }
            _applyManipulationCallback(selector, callBack) {
                if (bootstrap_esm_isElement(selector)) callBack(selector); else SelectorEngine.find(selector, this._element).forEach(callBack);
            }
            isOverflowing() {
                return this.getWidth() > 0;
            }
        }
        const Default$7 = {
            className: "modal-backdrop",
            isVisible: true,
            isAnimated: false,
            rootElement: "body",
            clickCallback: null
        };
        const DefaultType$7 = {
            className: "string",
            isVisible: "boolean",
            isAnimated: "boolean",
            rootElement: "(element|string)",
            clickCallback: "(function|null)"
        };
        const NAME$8 = "backdrop";
        const CLASS_NAME_FADE$4 = "fade";
        const CLASS_NAME_SHOW$5 = "show";
        const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$8}`;
        class Backdrop {
            constructor(config) {
                this._config = this._getConfig(config);
                this._isAppended = false;
                this._element = null;
            }
            show(callback) {
                if (!this._config.isVisible) {
                    execute(callback);
                    return;
                }
                this._append();
                if (this._config.isAnimated) reflow(this._getElement());
                this._getElement().classList.add(CLASS_NAME_SHOW$5);
                this._emulateAnimation((() => {
                    execute(callback);
                }));
            }
            hide(callback) {
                if (!this._config.isVisible) {
                    execute(callback);
                    return;
                }
                this._getElement().classList.remove(CLASS_NAME_SHOW$5);
                this._emulateAnimation((() => {
                    this.dispose();
                    execute(callback);
                }));
            }
            _getElement() {
                if (!this._element) {
                    const backdrop = document.createElement("div");
                    backdrop.className = this._config.className;
                    if (this._config.isAnimated) backdrop.classList.add(CLASS_NAME_FADE$4);
                    this._element = backdrop;
                }
                return this._element;
            }
            _getConfig(config) {
                config = {
                    ...Default$7,
                    ..."object" === typeof config ? config : {}
                };
                config.rootElement = getElement(config.rootElement);
                typeCheckConfig(NAME$8, config, DefaultType$7);
                return config;
            }
            _append() {
                if (this._isAppended) return;
                this._config.rootElement.append(this._getElement());
                EventHandler.on(this._getElement(), EVENT_MOUSEDOWN, (() => {
                    execute(this._config.clickCallback);
                }));
                this._isAppended = true;
            }
            dispose() {
                if (!this._isAppended) return;
                EventHandler.off(this._element, EVENT_MOUSEDOWN);
                this._element.remove();
                this._isAppended = false;
            }
            _emulateAnimation(callback) {
                executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
            }
        }
        const Default$6 = {
            trapElement: null,
            autofocus: true
        };
        const DefaultType$6 = {
            trapElement: "element",
            autofocus: "boolean"
        };
        const NAME$7 = "focustrap";
        const DATA_KEY$7 = "bs.focustrap";
        const EVENT_KEY$7 = `.${DATA_KEY$7}`;
        const EVENT_FOCUSIN$1 = `focusin${EVENT_KEY$7}`;
        const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$7}`;
        const TAB_KEY = "Tab";
        const TAB_NAV_FORWARD = "forward";
        const TAB_NAV_BACKWARD = "backward";
        class FocusTrap {
            constructor(config) {
                this._config = this._getConfig(config);
                this._isActive = false;
                this._lastTabNavDirection = null;
            }
            activate() {
                const {trapElement, autofocus} = this._config;
                if (this._isActive) return;
                if (autofocus) trapElement.focus();
                EventHandler.off(document, EVENT_KEY$7);
                EventHandler.on(document, EVENT_FOCUSIN$1, (event => this._handleFocusin(event)));
                EventHandler.on(document, EVENT_KEYDOWN_TAB, (event => this._handleKeydown(event)));
                this._isActive = true;
            }
            deactivate() {
                if (!this._isActive) return;
                this._isActive = false;
                EventHandler.off(document, EVENT_KEY$7);
            }
            _handleFocusin(event) {
                const {target} = event;
                const {trapElement} = this._config;
                if (target === document || target === trapElement || trapElement.contains(target)) return;
                const elements = SelectorEngine.focusableChildren(trapElement);
                if (0 === elements.length) trapElement.focus(); else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) elements[elements.length - 1].focus(); else elements[0].focus();
            }
            _handleKeydown(event) {
                if (event.key !== TAB_KEY) return;
                this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
            }
            _getConfig(config) {
                config = {
                    ...Default$6,
                    ..."object" === typeof config ? config : {}
                };
                typeCheckConfig(NAME$7, config, DefaultType$6);
                return config;
            }
        }
        const NAME$6 = "modal";
        const DATA_KEY$6 = "bs.modal";
        const EVENT_KEY$6 = `.${DATA_KEY$6}`;
        const DATA_API_KEY$3 = ".data-api";
        const ESCAPE_KEY$1 = "Escape";
        const Default$5 = {
            backdrop: true,
            keyboard: true,
            focus: true
        };
        const DefaultType$5 = {
            backdrop: "(boolean|string)",
            keyboard: "boolean",
            focus: "boolean"
        };
        const EVENT_HIDE$3 = `hide${EVENT_KEY$6}`;
        const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$6}`;
        const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$6}`;
        const EVENT_SHOW$3 = `show${EVENT_KEY$6}`;
        const EVENT_SHOWN$3 = `shown${EVENT_KEY$6}`;
        const EVENT_RESIZE = `resize${EVENT_KEY$6}`;
        const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$6}`;
        const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$6}`;
        const EVENT_MOUSEUP_DISMISS = `mouseup.dismiss${EVENT_KEY$6}`;
        const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$6}`;
        const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
        const CLASS_NAME_OPEN = "modal-open";
        const CLASS_NAME_FADE$3 = "fade";
        const CLASS_NAME_SHOW$4 = "show";
        const CLASS_NAME_STATIC = "modal-static";
        const OPEN_SELECTOR$1 = ".modal.show";
        const SELECTOR_DIALOG = ".modal-dialog";
        const SELECTOR_MODAL_BODY = ".modal-body";
        const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
        class Modal extends BaseComponent {
            constructor(element, config) {
                super(element);
                this._config = this._getConfig(config);
                this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
                this._backdrop = this._initializeBackDrop();
                this._focustrap = this._initializeFocusTrap();
                this._isShown = false;
                this._ignoreBackdropClick = false;
                this._isTransitioning = false;
                this._scrollBar = new ScrollBarHelper;
            }
            static get Default() {
                return Default$5;
            }
            static get NAME() {
                return NAME$6;
            }
            toggle(relatedTarget) {
                return this._isShown ? this.hide() : this.show(relatedTarget);
            }
            show(relatedTarget) {
                if (this._isShown || this._isTransitioning) return;
                const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
                    relatedTarget
                });
                if (showEvent.defaultPrevented) return;
                this._isShown = true;
                if (this._isAnimated()) this._isTransitioning = true;
                this._scrollBar.hide();
                document.body.classList.add(CLASS_NAME_OPEN);
                this._adjustDialog();
                this._setEscapeEvent();
                this._setResizeEvent();
                EventHandler.on(this._dialog, EVENT_MOUSEDOWN_DISMISS, (() => {
                    EventHandler.one(this._element, EVENT_MOUSEUP_DISMISS, (event => {
                        if (event.target === this._element) this._ignoreBackdropClick = true;
                    }));
                }));
                this._showBackdrop((() => this._showElement(relatedTarget)));
            }
            hide() {
                if (!this._isShown || this._isTransitioning) return;
                const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
                if (hideEvent.defaultPrevented) return;
                this._isShown = false;
                const isAnimated = this._isAnimated();
                if (isAnimated) this._isTransitioning = true;
                this._setEscapeEvent();
                this._setResizeEvent();
                this._focustrap.deactivate();
                this._element.classList.remove(CLASS_NAME_SHOW$4);
                EventHandler.off(this._element, EVENT_CLICK_DISMISS);
                EventHandler.off(this._dialog, EVENT_MOUSEDOWN_DISMISS);
                this._queueCallback((() => this._hideModal()), this._element, isAnimated);
            }
            dispose() {
                [ window, this._dialog ].forEach((htmlElement => EventHandler.off(htmlElement, EVENT_KEY$6)));
                this._backdrop.dispose();
                this._focustrap.deactivate();
                super.dispose();
            }
            handleUpdate() {
                this._adjustDialog();
            }
            _initializeBackDrop() {
                return new Backdrop({
                    isVisible: Boolean(this._config.backdrop),
                    isAnimated: this._isAnimated()
                });
            }
            _initializeFocusTrap() {
                return new FocusTrap({
                    trapElement: this._element
                });
            }
            _getConfig(config) {
                config = {
                    ...Default$5,
                    ...Manipulator.getDataAttributes(this._element),
                    ..."object" === typeof config ? config : {}
                };
                typeCheckConfig(NAME$6, config, DefaultType$5);
                return config;
            }
            _showElement(relatedTarget) {
                const isAnimated = this._isAnimated();
                const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
                if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) document.body.append(this._element);
                this._element.style.display = "block";
                this._element.removeAttribute("aria-hidden");
                this._element.setAttribute("aria-modal", true);
                this._element.setAttribute("role", "dialog");
                this._element.scrollTop = 0;
                if (modalBody) modalBody.scrollTop = 0;
                if (isAnimated) reflow(this._element);
                this._element.classList.add(CLASS_NAME_SHOW$4);
                const transitionComplete = () => {
                    if (this._config.focus) this._focustrap.activate();
                    this._isTransitioning = false;
                    EventHandler.trigger(this._element, EVENT_SHOWN$3, {
                        relatedTarget
                    });
                };
                this._queueCallback(transitionComplete, this._dialog, isAnimated);
            }
            _setEscapeEvent() {
                if (this._isShown) EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event => {
                    if (this._config.keyboard && event.key === ESCAPE_KEY$1) {
                        event.preventDefault();
                        this.hide();
                    } else if (!this._config.keyboard && event.key === ESCAPE_KEY$1) this._triggerBackdropTransition();
                })); else EventHandler.off(this._element, EVENT_KEYDOWN_DISMISS$1);
            }
            _setResizeEvent() {
                if (this._isShown) EventHandler.on(window, EVENT_RESIZE, (() => this._adjustDialog())); else EventHandler.off(window, EVENT_RESIZE);
            }
            _hideModal() {
                this._element.style.display = "none";
                this._element.setAttribute("aria-hidden", true);
                this._element.removeAttribute("aria-modal");
                this._element.removeAttribute("role");
                this._isTransitioning = false;
                this._backdrop.hide((() => {
                    document.body.classList.remove(CLASS_NAME_OPEN);
                    this._resetAdjustments();
                    this._scrollBar.reset();
                    EventHandler.trigger(this._element, EVENT_HIDDEN$3);
                }));
            }
            _showBackdrop(callback) {
                EventHandler.on(this._element, EVENT_CLICK_DISMISS, (event => {
                    if (this._ignoreBackdropClick) {
                        this._ignoreBackdropClick = false;
                        return;
                    }
                    if (event.target !== event.currentTarget) return;
                    if (true === this._config.backdrop) this.hide(); else if ("static" === this._config.backdrop) this._triggerBackdropTransition();
                }));
                this._backdrop.show(callback);
            }
            _isAnimated() {
                return this._element.classList.contains(CLASS_NAME_FADE$3);
            }
            _triggerBackdropTransition() {
                const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
                if (hideEvent.defaultPrevented) return;
                const {classList, scrollHeight, style} = this._element;
                const isModalOverflowing = scrollHeight > document.documentElement.clientHeight;
                if (!isModalOverflowing && "hidden" === style.overflowY || classList.contains(CLASS_NAME_STATIC)) return;
                if (!isModalOverflowing) style.overflowY = "hidden";
                classList.add(CLASS_NAME_STATIC);
                this._queueCallback((() => {
                    classList.remove(CLASS_NAME_STATIC);
                    if (!isModalOverflowing) this._queueCallback((() => {
                        style.overflowY = "";
                    }), this._dialog);
                }), this._dialog);
                this._element.focus();
            }
            _adjustDialog() {
                const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
                const scrollbarWidth = this._scrollBar.getWidth();
                const isBodyOverflowing = scrollbarWidth > 0;
                if (!isBodyOverflowing && isModalOverflowing && !isRTL() || isBodyOverflowing && !isModalOverflowing && isRTL()) this._element.style.paddingLeft = `${scrollbarWidth}px`;
                if (isBodyOverflowing && !isModalOverflowing && !isRTL() || !isBodyOverflowing && isModalOverflowing && isRTL()) this._element.style.paddingRight = `${scrollbarWidth}px`;
            }
            _resetAdjustments() {
                this._element.style.paddingLeft = "";
                this._element.style.paddingRight = "";
            }
            static jQueryInterface(config, relatedTarget) {
                return this.each((function() {
                    const data = Modal.getOrCreateInstance(this, config);
                    if ("string" !== typeof config) return;
                    if ("undefined" === typeof data[config]) throw new TypeError(`No method named "${config}"`);
                    data[config](relatedTarget);
                }));
            }
        }
        EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, (function(event) {
            const target = getElementFromSelector(this);
            if ([ "A", "AREA" ].includes(this.tagName)) event.preventDefault();
            EventHandler.one(target, EVENT_SHOW$3, (showEvent => {
                if (showEvent.defaultPrevented) return;
                EventHandler.one(target, EVENT_HIDDEN$3, (() => {
                    if (isVisible(this)) this.focus();
                }));
            }));
            const allReadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
            if (allReadyOpen) Modal.getInstance(allReadyOpen).hide();
            const data = Modal.getOrCreateInstance(target);
            data.toggle(this);
        }));
        enableDismissTrigger(Modal);
        defineJQueryPlugin(Modal);
        const NAME$5 = "offcanvas";
        const DATA_KEY$5 = "bs.offcanvas";
        const EVENT_KEY$5 = `.${DATA_KEY$5}`;
        const DATA_API_KEY$2 = ".data-api";
        const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$5}${DATA_API_KEY$2}`;
        const ESCAPE_KEY = "Escape";
        const Default$4 = {
            backdrop: true,
            keyboard: true,
            scroll: false
        };
        const DefaultType$4 = {
            backdrop: "boolean",
            keyboard: "boolean",
            scroll: "boolean"
        };
        const CLASS_NAME_SHOW$3 = "show";
        const CLASS_NAME_BACKDROP = "offcanvas-backdrop";
        const OPEN_SELECTOR = ".offcanvas.show";
        const EVENT_SHOW$2 = `show${EVENT_KEY$5}`;
        const EVENT_SHOWN$2 = `shown${EVENT_KEY$5}`;
        const EVENT_HIDE$2 = `hide${EVENT_KEY$5}`;
        const EVENT_HIDDEN$2 = `hidden${EVENT_KEY$5}`;
        const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$5}${DATA_API_KEY$2}`;
        const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$5}`;
        const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
        class Offcanvas extends BaseComponent {
            constructor(element, config) {
                super(element);
                this._config = this._getConfig(config);
                this._isShown = false;
                this._backdrop = this._initializeBackDrop();
                this._focustrap = this._initializeFocusTrap();
                this._addEventListeners();
            }
            static get NAME() {
                return NAME$5;
            }
            static get Default() {
                return Default$4;
            }
            toggle(relatedTarget) {
                return this._isShown ? this.hide() : this.show(relatedTarget);
            }
            show(relatedTarget) {
                if (this._isShown) return;
                const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$2, {
                    relatedTarget
                });
                if (showEvent.defaultPrevented) return;
                this._isShown = true;
                this._element.style.visibility = "visible";
                this._backdrop.show();
                if (!this._config.scroll) (new ScrollBarHelper).hide();
                this._element.removeAttribute("aria-hidden");
                this._element.setAttribute("aria-modal", true);
                this._element.setAttribute("role", "dialog");
                this._element.classList.add(CLASS_NAME_SHOW$3);
                const completeCallBack = () => {
                    if (!this._config.scroll) this._focustrap.activate();
                    EventHandler.trigger(this._element, EVENT_SHOWN$2, {
                        relatedTarget
                    });
                };
                this._queueCallback(completeCallBack, this._element, true);
            }
            hide() {
                if (!this._isShown) return;
                const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$2);
                if (hideEvent.defaultPrevented) return;
                this._focustrap.deactivate();
                this._element.blur();
                this._isShown = false;
                this._element.classList.remove(CLASS_NAME_SHOW$3);
                this._backdrop.hide();
                const completeCallback = () => {
                    this._element.setAttribute("aria-hidden", true);
                    this._element.removeAttribute("aria-modal");
                    this._element.removeAttribute("role");
                    this._element.style.visibility = "hidden";
                    if (!this._config.scroll) (new ScrollBarHelper).reset();
                    EventHandler.trigger(this._element, EVENT_HIDDEN$2);
                };
                this._queueCallback(completeCallback, this._element, true);
            }
            dispose() {
                this._backdrop.dispose();
                this._focustrap.deactivate();
                super.dispose();
            }
            _getConfig(config) {
                config = {
                    ...Default$4,
                    ...Manipulator.getDataAttributes(this._element),
                    ..."object" === typeof config ? config : {}
                };
                typeCheckConfig(NAME$5, config, DefaultType$4);
                return config;
            }
            _initializeBackDrop() {
                return new Backdrop({
                    className: CLASS_NAME_BACKDROP,
                    isVisible: this._config.backdrop,
                    isAnimated: true,
                    rootElement: this._element.parentNode,
                    clickCallback: () => this.hide()
                });
            }
            _initializeFocusTrap() {
                return new FocusTrap({
                    trapElement: this._element
                });
            }
            _addEventListeners() {
                EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event => {
                    if (this._config.keyboard && event.key === ESCAPE_KEY) this.hide();
                }));
            }
            static jQueryInterface(config) {
                return this.each((function() {
                    const data = Offcanvas.getOrCreateInstance(this, config);
                    if ("string" !== typeof config) return;
                    if (void 0 === data[config] || config.startsWith("_") || "constructor" === config) throw new TypeError(`No method named "${config}"`);
                    data[config](this);
                }));
            }
        }
        EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, (function(event) {
            const target = getElementFromSelector(this);
            if ([ "A", "AREA" ].includes(this.tagName)) event.preventDefault();
            if (isDisabled(this)) return;
            EventHandler.one(target, EVENT_HIDDEN$2, (() => {
                if (isVisible(this)) this.focus();
            }));
            const allReadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
            if (allReadyOpen && allReadyOpen !== target) Offcanvas.getInstance(allReadyOpen).hide();
            const data = Offcanvas.getOrCreateInstance(target);
            data.toggle(this);
        }));
        EventHandler.on(window, EVENT_LOAD_DATA_API$1, (() => SelectorEngine.find(OPEN_SELECTOR).forEach((el => Offcanvas.getOrCreateInstance(el).show()))));
        enableDismissTrigger(Offcanvas);
        defineJQueryPlugin(Offcanvas);
        const uriAttributes = new Set([ "background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href" ]);
        const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
        const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
        const DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
        const allowedAttribute = (attribute, allowedAttributeList) => {
            const attributeName = attribute.nodeName.toLowerCase();
            if (allowedAttributeList.includes(attributeName)) {
                if (uriAttributes.has(attributeName)) return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));
                return true;
            }
            const regExp = allowedAttributeList.filter((attributeRegex => attributeRegex instanceof RegExp));
            for (let i = 0, len = regExp.length; i < len; i++) if (regExp[i].test(attributeName)) return true;
            return false;
        };
        const DefaultAllowlist = {
            "*": [ "class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN ],
            a: [ "target", "href", "title", "rel" ],
            area: [],
            b: [],
            br: [],
            col: [],
            code: [],
            div: [],
            em: [],
            hr: [],
            h1: [],
            h2: [],
            h3: [],
            h4: [],
            h5: [],
            h6: [],
            i: [],
            img: [ "src", "srcset", "alt", "title", "width", "height" ],
            li: [],
            ol: [],
            p: [],
            pre: [],
            s: [],
            small: [],
            span: [],
            sub: [],
            sup: [],
            strong: [],
            u: [],
            ul: []
        };
        function sanitizeHtml(unsafeHtml, allowList, sanitizeFn) {
            if (!unsafeHtml.length) return unsafeHtml;
            if (sanitizeFn && "function" === typeof sanitizeFn) return sanitizeFn(unsafeHtml);
            const domParser = new window.DOMParser;
            const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
            const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
            for (let i = 0, len = elements.length; i < len; i++) {
                const element = elements[i];
                const elementName = element.nodeName.toLowerCase();
                if (!Object.keys(allowList).includes(elementName)) {
                    element.remove();
                    continue;
                }
                const attributeList = [].concat(...element.attributes);
                const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
                attributeList.forEach((attribute => {
                    if (!allowedAttribute(attribute, allowedAttributes)) element.removeAttribute(attribute.nodeName);
                }));
            }
            return createdDocument.body.innerHTML;
        }
        const NAME$4 = "tooltip";
        const DATA_KEY$4 = "bs.tooltip";
        const EVENT_KEY$4 = `.${DATA_KEY$4}`;
        const CLASS_PREFIX$1 = "bs-tooltip";
        const DISALLOWED_ATTRIBUTES = new Set([ "sanitize", "allowList", "sanitizeFn" ]);
        const DefaultType$3 = {
            animation: "boolean",
            template: "string",
            title: "(string|element|function)",
            trigger: "string",
            delay: "(number|object)",
            html: "boolean",
            selector: "(string|boolean)",
            placement: "(string|function)",
            offset: "(array|string|function)",
            container: "(string|element|boolean)",
            fallbackPlacements: "array",
            boundary: "(string|element)",
            customClass: "(string|function)",
            sanitize: "boolean",
            sanitizeFn: "(null|function)",
            allowList: "object",
            popperConfig: "(null|object|function)"
        };
        const AttachmentMap = {
            AUTO: "auto",
            TOP: "top",
            RIGHT: isRTL() ? "left" : "right",
            BOTTOM: "bottom",
            LEFT: isRTL() ? "right" : "left"
        };
        const Default$3 = {
            animation: true,
            template: '<div class="tooltip" role="tooltip">' + '<div class="tooltip-arrow"></div>' + '<div class="tooltip-inner"></div>' + "</div>",
            trigger: "hover focus",
            title: "",
            delay: 0,
            html: false,
            selector: false,
            placement: "top",
            offset: [ 0, 0 ],
            container: false,
            fallbackPlacements: [ "top", "right", "bottom", "left" ],
            boundary: "clippingParents",
            customClass: "",
            sanitize: true,
            sanitizeFn: null,
            allowList: DefaultAllowlist,
            popperConfig: null
        };
        const Event$2 = {
            HIDE: `hide${EVENT_KEY$4}`,
            HIDDEN: `hidden${EVENT_KEY$4}`,
            SHOW: `show${EVENT_KEY$4}`,
            SHOWN: `shown${EVENT_KEY$4}`,
            INSERTED: `inserted${EVENT_KEY$4}`,
            CLICK: `click${EVENT_KEY$4}`,
            FOCUSIN: `focusin${EVENT_KEY$4}`,
            FOCUSOUT: `focusout${EVENT_KEY$4}`,
            MOUSEENTER: `mouseenter${EVENT_KEY$4}`,
            MOUSELEAVE: `mouseleave${EVENT_KEY$4}`
        };
        const CLASS_NAME_FADE$2 = "fade";
        const CLASS_NAME_MODAL = "modal";
        const CLASS_NAME_SHOW$2 = "show";
        const HOVER_STATE_SHOW = "show";
        const HOVER_STATE_OUT = "out";
        const SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
        const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
        const EVENT_MODAL_HIDE = "hide.bs.modal";
        const TRIGGER_HOVER = "hover";
        const TRIGGER_FOCUS = "focus";
        const TRIGGER_CLICK = "click";
        const TRIGGER_MANUAL = "manual";
        class Tooltip extends BaseComponent {
            constructor(element, config) {
                if ("undefined" === typeof lib_namespaceObject) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
                super(element);
                this._isEnabled = true;
                this._timeout = 0;
                this._hoverState = "";
                this._activeTrigger = {};
                this._popper = null;
                this._config = this._getConfig(config);
                this.tip = null;
                this._setListeners();
            }
            static get Default() {
                return Default$3;
            }
            static get NAME() {
                return NAME$4;
            }
            static get Event() {
                return Event$2;
            }
            static get DefaultType() {
                return DefaultType$3;
            }
            enable() {
                this._isEnabled = true;
            }
            disable() {
                this._isEnabled = false;
            }
            toggleEnabled() {
                this._isEnabled = !this._isEnabled;
            }
            toggle(event) {
                if (!this._isEnabled) return;
                if (event) {
                    const context = this._initializeOnDelegatedTarget(event);
                    context._activeTrigger.click = !context._activeTrigger.click;
                    if (context._isWithActiveTrigger()) context._enter(null, context); else context._leave(null, context);
                } else {
                    if (this.getTipElement().classList.contains(CLASS_NAME_SHOW$2)) {
                        this._leave(null, this);
                        return;
                    }
                    this._enter(null, this);
                }
            }
            dispose() {
                clearTimeout(this._timeout);
                EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
                if (this.tip) this.tip.remove();
                this._disposePopper();
                super.dispose();
            }
            show() {
                if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
                if (!(this.isWithContent() && this._isEnabled)) return;
                const showEvent = EventHandler.trigger(this._element, this.constructor.Event.SHOW);
                const shadowRoot = findShadowRoot(this._element);
                const isInTheDom = null === shadowRoot ? this._element.ownerDocument.documentElement.contains(this._element) : shadowRoot.contains(this._element);
                if (showEvent.defaultPrevented || !isInTheDom) return;
                if ("tooltip" === this.constructor.NAME && this.tip && this.getTitle() !== this.tip.querySelector(SELECTOR_TOOLTIP_INNER).innerHTML) {
                    this._disposePopper();
                    this.tip.remove();
                    this.tip = null;
                }
                const tip = this.getTipElement();
                const tipId = getUID(this.constructor.NAME);
                tip.setAttribute("id", tipId);
                this._element.setAttribute("aria-describedby", tipId);
                if (this._config.animation) tip.classList.add(CLASS_NAME_FADE$2);
                const placement = "function" === typeof this._config.placement ? this._config.placement.call(this, tip, this._element) : this._config.placement;
                const attachment = this._getAttachment(placement);
                this._addAttachmentClass(attachment);
                const {container} = this._config;
                Data.set(tip, this.constructor.DATA_KEY, this);
                if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
                    container.append(tip);
                    EventHandler.trigger(this._element, this.constructor.Event.INSERTED);
                }
                if (this._popper) this._popper.update(); else this._popper = popper_createPopper(this._element, tip, this._getPopperConfig(attachment));
                tip.classList.add(CLASS_NAME_SHOW$2);
                const customClass = this._resolvePossibleFunction(this._config.customClass);
                if (customClass) tip.classList.add(...customClass.split(" "));
                if ("ontouchstart" in document.documentElement) [].concat(...document.body.children).forEach((element => {
                    EventHandler.on(element, "mouseover", noop);
                }));
                const complete = () => {
                    const prevHoverState = this._hoverState;
                    this._hoverState = null;
                    EventHandler.trigger(this._element, this.constructor.Event.SHOWN);
                    if (prevHoverState === HOVER_STATE_OUT) this._leave(null, this);
                };
                const isAnimated = this.tip.classList.contains(CLASS_NAME_FADE$2);
                this._queueCallback(complete, this.tip, isAnimated);
            }
            hide() {
                if (!this._popper) return;
                const tip = this.getTipElement();
                const complete = () => {
                    if (this._isWithActiveTrigger()) return;
                    if (this._hoverState !== HOVER_STATE_SHOW) tip.remove();
                    this._cleanTipClass();
                    this._element.removeAttribute("aria-describedby");
                    EventHandler.trigger(this._element, this.constructor.Event.HIDDEN);
                    this._disposePopper();
                };
                const hideEvent = EventHandler.trigger(this._element, this.constructor.Event.HIDE);
                if (hideEvent.defaultPrevented) return;
                tip.classList.remove(CLASS_NAME_SHOW$2);
                if ("ontouchstart" in document.documentElement) [].concat(...document.body.children).forEach((element => EventHandler.off(element, "mouseover", noop)));
                this._activeTrigger[TRIGGER_CLICK] = false;
                this._activeTrigger[TRIGGER_FOCUS] = false;
                this._activeTrigger[TRIGGER_HOVER] = false;
                const isAnimated = this.tip.classList.contains(CLASS_NAME_FADE$2);
                this._queueCallback(complete, this.tip, isAnimated);
                this._hoverState = "";
            }
            update() {
                if (null !== this._popper) this._popper.update();
            }
            isWithContent() {
                return Boolean(this.getTitle());
            }
            getTipElement() {
                if (this.tip) return this.tip;
                const element = document.createElement("div");
                element.innerHTML = this._config.template;
                const tip = element.children[0];
                this.setContent(tip);
                tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
                this.tip = tip;
                return this.tip;
            }
            setContent(tip) {
                this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TOOLTIP_INNER);
            }
            _sanitizeAndSetContent(template, content, selector) {
                const templateElement = SelectorEngine.findOne(selector, template);
                if (!content && templateElement) {
                    templateElement.remove();
                    return;
                }
                this.setElementContent(templateElement, content);
            }
            setElementContent(element, content) {
                if (null === element) return;
                if (bootstrap_esm_isElement(content)) {
                    content = getElement(content);
                    if (this._config.html) {
                        if (content.parentNode !== element) {
                            element.innerHTML = "";
                            element.append(content);
                        }
                    } else element.textContent = content.textContent;
                    return;
                }
                if (this._config.html) {
                    if (this._config.sanitize) content = sanitizeHtml(content, this._config.allowList, this._config.sanitizeFn);
                    element.innerHTML = content;
                } else element.textContent = content;
            }
            getTitle() {
                const title = this._element.getAttribute("data-bs-original-title") || this._config.title;
                return this._resolvePossibleFunction(title);
            }
            updateAttachment(attachment) {
                if ("right" === attachment) return "end";
                if ("left" === attachment) return "start";
                return attachment;
            }
            _initializeOnDelegatedTarget(event, context) {
                return context || this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
            }
            _getOffset() {
                const {offset} = this._config;
                if ("string" === typeof offset) return offset.split(",").map((val => Number.parseInt(val, 10)));
                if ("function" === typeof offset) return popperData => offset(popperData, this._element);
                return offset;
            }
            _resolvePossibleFunction(content) {
                return "function" === typeof content ? content.call(this._element) : content;
            }
            _getPopperConfig(attachment) {
                const defaultBsPopperConfig = {
                    placement: attachment,
                    modifiers: [ {
                        name: "flip",
                        options: {
                            fallbackPlacements: this._config.fallbackPlacements
                        }
                    }, {
                        name: "offset",
                        options: {
                            offset: this._getOffset()
                        }
                    }, {
                        name: "preventOverflow",
                        options: {
                            boundary: this._config.boundary
                        }
                    }, {
                        name: "arrow",
                        options: {
                            element: `.${this.constructor.NAME}-arrow`
                        }
                    }, {
                        name: "onChange",
                        enabled: true,
                        phase: "afterWrite",
                        fn: data => this._handlePopperPlacementChange(data)
                    } ],
                    onFirstUpdate: data => {
                        if (data.options.placement !== data.placement) this._handlePopperPlacementChange(data);
                    }
                };
                return {
                    ...defaultBsPopperConfig,
                    ..."function" === typeof this._config.popperConfig ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig
                };
            }
            _addAttachmentClass(attachment) {
                this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(attachment)}`);
            }
            _getAttachment(placement) {
                return AttachmentMap[placement.toUpperCase()];
            }
            _setListeners() {
                const triggers = this._config.trigger.split(" ");
                triggers.forEach((trigger => {
                    if ("click" === trigger) EventHandler.on(this._element, this.constructor.Event.CLICK, this._config.selector, (event => this.toggle(event))); else if (trigger !== TRIGGER_MANUAL) {
                        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN;
                        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
                        EventHandler.on(this._element, eventIn, this._config.selector, (event => this._enter(event)));
                        EventHandler.on(this._element, eventOut, this._config.selector, (event => this._leave(event)));
                    }
                }));
                this._hideModalHandler = () => {
                    if (this._element) this.hide();
                };
                EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
                if (this._config.selector) this._config = {
                    ...this._config,
                    trigger: "manual",
                    selector: ""
                }; else this._fixTitle();
            }
            _fixTitle() {
                const title = this._element.getAttribute("title");
                const originalTitleType = typeof this._element.getAttribute("data-bs-original-title");
                if (title || "string" !== originalTitleType) {
                    this._element.setAttribute("data-bs-original-title", title || "");
                    if (title && !this._element.getAttribute("aria-label") && !this._element.textContent) this._element.setAttribute("aria-label", title);
                    this._element.setAttribute("title", "");
                }
            }
            _enter(event, context) {
                context = this._initializeOnDelegatedTarget(event, context);
                if (event) context._activeTrigger["focusin" === event.type ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
                if (context.getTipElement().classList.contains(CLASS_NAME_SHOW$2) || context._hoverState === HOVER_STATE_SHOW) {
                    context._hoverState = HOVER_STATE_SHOW;
                    return;
                }
                clearTimeout(context._timeout);
                context._hoverState = HOVER_STATE_SHOW;
                if (!context._config.delay || !context._config.delay.show) {
                    context.show();
                    return;
                }
                context._timeout = setTimeout((() => {
                    if (context._hoverState === HOVER_STATE_SHOW) context.show();
                }), context._config.delay.show);
            }
            _leave(event, context) {
                context = this._initializeOnDelegatedTarget(event, context);
                if (event) context._activeTrigger["focusout" === event.type ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
                if (context._isWithActiveTrigger()) return;
                clearTimeout(context._timeout);
                context._hoverState = HOVER_STATE_OUT;
                if (!context._config.delay || !context._config.delay.hide) {
                    context.hide();
                    return;
                }
                context._timeout = setTimeout((() => {
                    if (context._hoverState === HOVER_STATE_OUT) context.hide();
                }), context._config.delay.hide);
            }
            _isWithActiveTrigger() {
                for (const trigger in this._activeTrigger) if (this._activeTrigger[trigger]) return true;
                return false;
            }
            _getConfig(config) {
                const dataAttributes = Manipulator.getDataAttributes(this._element);
                Object.keys(dataAttributes).forEach((dataAttr => {
                    if (DISALLOWED_ATTRIBUTES.has(dataAttr)) delete dataAttributes[dataAttr];
                }));
                config = {
                    ...this.constructor.Default,
                    ...dataAttributes,
                    ..."object" === typeof config && config ? config : {}
                };
                config.container = false === config.container ? document.body : getElement(config.container);
                if ("number" === typeof config.delay) config.delay = {
                    show: config.delay,
                    hide: config.delay
                };
                if ("number" === typeof config.title) config.title = config.title.toString();
                if ("number" === typeof config.content) config.content = config.content.toString();
                typeCheckConfig(NAME$4, config, this.constructor.DefaultType);
                if (config.sanitize) config.template = sanitizeHtml(config.template, config.allowList, config.sanitizeFn);
                return config;
            }
            _getDelegateConfig() {
                const config = {};
                for (const key in this._config) if (this.constructor.Default[key] !== this._config[key]) config[key] = this._config[key];
                return config;
            }
            _cleanTipClass() {
                const tip = this.getTipElement();
                const basicClassPrefixRegex = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, "g");
                const tabClass = tip.getAttribute("class").match(basicClassPrefixRegex);
                if (null !== tabClass && tabClass.length > 0) tabClass.map((token => token.trim())).forEach((tClass => tip.classList.remove(tClass)));
            }
            _getBasicClassPrefix() {
                return CLASS_PREFIX$1;
            }
            _handlePopperPlacementChange(popperData) {
                const {state} = popperData;
                if (!state) return;
                this.tip = state.elements.popper;
                this._cleanTipClass();
                this._addAttachmentClass(this._getAttachment(state.placement));
            }
            _disposePopper() {
                if (this._popper) {
                    this._popper.destroy();
                    this._popper = null;
                }
            }
            static jQueryInterface(config) {
                return this.each((function() {
                    const data = Tooltip.getOrCreateInstance(this, config);
                    if ("string" === typeof config) {
                        if ("undefined" === typeof data[config]) throw new TypeError(`No method named "${config}"`);
                        data[config]();
                    }
                }));
            }
        }
        defineJQueryPlugin(Tooltip);
        const NAME$3 = "popover";
        const DATA_KEY$3 = "bs.popover";
        const EVENT_KEY$3 = `.${DATA_KEY$3}`;
        const CLASS_PREFIX = "bs-popover";
        const Default$2 = {
            ...Tooltip.Default,
            placement: "right",
            offset: [ 0, 8 ],
            trigger: "click",
            content: "",
            template: '<div class="popover" role="tooltip">' + '<div class="popover-arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div>' + "</div>"
        };
        const DefaultType$2 = {
            ...Tooltip.DefaultType,
            content: "(string|element|function)"
        };
        const Event$1 = {
            HIDE: `hide${EVENT_KEY$3}`,
            HIDDEN: `hidden${EVENT_KEY$3}`,
            SHOW: `show${EVENT_KEY$3}`,
            SHOWN: `shown${EVENT_KEY$3}`,
            INSERTED: `inserted${EVENT_KEY$3}`,
            CLICK: `click${EVENT_KEY$3}`,
            FOCUSIN: `focusin${EVENT_KEY$3}`,
            FOCUSOUT: `focusout${EVENT_KEY$3}`,
            MOUSEENTER: `mouseenter${EVENT_KEY$3}`,
            MOUSELEAVE: `mouseleave${EVENT_KEY$3}`
        };
        const SELECTOR_TITLE = ".popover-header";
        const SELECTOR_CONTENT = ".popover-body";
        class Popover extends Tooltip {
            static get Default() {
                return Default$2;
            }
            static get NAME() {
                return NAME$3;
            }
            static get Event() {
                return Event$1;
            }
            static get DefaultType() {
                return DefaultType$2;
            }
            isWithContent() {
                return this.getTitle() || this._getContent();
            }
            setContent(tip) {
                this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TITLE);
                this._sanitizeAndSetContent(tip, this._getContent(), SELECTOR_CONTENT);
            }
            _getContent() {
                return this._resolvePossibleFunction(this._config.content);
            }
            _getBasicClassPrefix() {
                return CLASS_PREFIX;
            }
            static jQueryInterface(config) {
                return this.each((function() {
                    const data = Popover.getOrCreateInstance(this, config);
                    if ("string" === typeof config) {
                        if ("undefined" === typeof data[config]) throw new TypeError(`No method named "${config}"`);
                        data[config]();
                    }
                }));
            }
        }
        defineJQueryPlugin(Popover);
        const NAME$2 = "scrollspy";
        const DATA_KEY$2 = "bs.scrollspy";
        const EVENT_KEY$2 = `.${DATA_KEY$2}`;
        const DATA_API_KEY$1 = ".data-api";
        const Default$1 = {
            offset: 10,
            method: "auto",
            target: ""
        };
        const DefaultType$1 = {
            offset: "number",
            method: "string",
            target: "(string|element)"
        };
        const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
        const EVENT_SCROLL = `scroll${EVENT_KEY$2}`;
        const EVENT_LOAD_DATA_API = `load${EVENT_KEY$2}${DATA_API_KEY$1}`;
        const CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
        const CLASS_NAME_ACTIVE$1 = "active";
        const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
        const SELECTOR_NAV_LIST_GROUP$1 = ".nav, .list-group";
        const SELECTOR_NAV_LINKS = ".nav-link";
        const SELECTOR_NAV_ITEMS = ".nav-item";
        const SELECTOR_LIST_ITEMS = ".list-group-item";
        const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}, .${CLASS_NAME_DROPDOWN_ITEM}`;
        const SELECTOR_DROPDOWN$1 = ".dropdown";
        const SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
        const METHOD_OFFSET = "offset";
        const METHOD_POSITION = "position";
        class ScrollSpy extends BaseComponent {
            constructor(element, config) {
                super(element);
                this._scrollElement = "BODY" === this._element.tagName ? window : this._element;
                this._config = this._getConfig(config);
                this._offsets = [];
                this._targets = [];
                this._activeTarget = null;
                this._scrollHeight = 0;
                EventHandler.on(this._scrollElement, EVENT_SCROLL, (() => this._process()));
                this.refresh();
                this._process();
            }
            static get Default() {
                return Default$1;
            }
            static get NAME() {
                return NAME$2;
            }
            refresh() {
                const autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;
                const offsetMethod = "auto" === this._config.method ? autoMethod : this._config.method;
                const offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;
                this._offsets = [];
                this._targets = [];
                this._scrollHeight = this._getScrollHeight();
                const targets = SelectorEngine.find(SELECTOR_LINK_ITEMS, this._config.target);
                targets.map((element => {
                    const targetSelector = getSelectorFromElement(element);
                    const target = targetSelector ? SelectorEngine.findOne(targetSelector) : null;
                    if (target) {
                        const targetBCR = target.getBoundingClientRect();
                        if (targetBCR.width || targetBCR.height) return [ Manipulator[offsetMethod](target).top + offsetBase, targetSelector ];
                    }
                    return null;
                })).filter((item => item)).sort(((a, b) => a[0] - b[0])).forEach((item => {
                    this._offsets.push(item[0]);
                    this._targets.push(item[1]);
                }));
            }
            dispose() {
                EventHandler.off(this._scrollElement, EVENT_KEY$2);
                super.dispose();
            }
            _getConfig(config) {
                config = {
                    ...Default$1,
                    ...Manipulator.getDataAttributes(this._element),
                    ..."object" === typeof config && config ? config : {}
                };
                config.target = getElement(config.target) || document.documentElement;
                typeCheckConfig(NAME$2, config, DefaultType$1);
                return config;
            }
            _getScrollTop() {
                return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
            }
            _getScrollHeight() {
                return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
            }
            _getOffsetHeight() {
                return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
            }
            _process() {
                const scrollTop = this._getScrollTop() + this._config.offset;
                const scrollHeight = this._getScrollHeight();
                const maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();
                if (this._scrollHeight !== scrollHeight) this.refresh();
                if (scrollTop >= maxScroll) {
                    const target = this._targets[this._targets.length - 1];
                    if (this._activeTarget !== target) this._activate(target);
                    return;
                }
                if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
                    this._activeTarget = null;
                    this._clear();
                    return;
                }
                for (let i = this._offsets.length; i--; ) {
                    const isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && ("undefined" === typeof this._offsets[i + 1] || scrollTop < this._offsets[i + 1]);
                    if (isActiveTarget) this._activate(this._targets[i]);
                }
            }
            _activate(target) {
                this._activeTarget = target;
                this._clear();
                const queries = SELECTOR_LINK_ITEMS.split(",").map((selector => `${selector}[data-bs-target="${target}"],${selector}[href="${target}"]`));
                const link = SelectorEngine.findOne(queries.join(","), this._config.target);
                link.classList.add(CLASS_NAME_ACTIVE$1);
                if (link.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, link.closest(SELECTOR_DROPDOWN$1)).classList.add(CLASS_NAME_ACTIVE$1); else SelectorEngine.parents(link, SELECTOR_NAV_LIST_GROUP$1).forEach((listGroup => {
                    SelectorEngine.prev(listGroup, `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`).forEach((item => item.classList.add(CLASS_NAME_ACTIVE$1)));
                    SelectorEngine.prev(listGroup, SELECTOR_NAV_ITEMS).forEach((navItem => {
                        SelectorEngine.children(navItem, SELECTOR_NAV_LINKS).forEach((item => item.classList.add(CLASS_NAME_ACTIVE$1)));
                    }));
                }));
                EventHandler.trigger(this._scrollElement, EVENT_ACTIVATE, {
                    relatedTarget: target
                });
            }
            _clear() {
                SelectorEngine.find(SELECTOR_LINK_ITEMS, this._config.target).filter((node => node.classList.contains(CLASS_NAME_ACTIVE$1))).forEach((node => node.classList.remove(CLASS_NAME_ACTIVE$1)));
            }
            static jQueryInterface(config) {
                return this.each((function() {
                    const data = ScrollSpy.getOrCreateInstance(this, config);
                    if ("string" !== typeof config) return;
                    if ("undefined" === typeof data[config]) throw new TypeError(`No method named "${config}"`);
                    data[config]();
                }));
            }
        }
        EventHandler.on(window, EVENT_LOAD_DATA_API, (() => {
            SelectorEngine.find(SELECTOR_DATA_SPY).forEach((spy => new ScrollSpy(spy)));
        }));
        defineJQueryPlugin(ScrollSpy);
        const NAME$1 = "tab";
        const DATA_KEY$1 = "bs.tab";
        const EVENT_KEY$1 = `.${DATA_KEY$1}`;
        const DATA_API_KEY = ".data-api";
        const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
        const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
        const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
        const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
        const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}${DATA_API_KEY}`;
        const CLASS_NAME_DROPDOWN_MENU = "dropdown-menu";
        const CLASS_NAME_ACTIVE = "active";
        const CLASS_NAME_FADE$1 = "fade";
        const CLASS_NAME_SHOW$1 = "show";
        const SELECTOR_DROPDOWN = ".dropdown";
        const SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
        const SELECTOR_ACTIVE = ".active";
        const SELECTOR_ACTIVE_UL = ":scope > li > .active";
        const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
        const SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
        const SELECTOR_DROPDOWN_ACTIVE_CHILD = ":scope > .dropdown-menu .active";
        class Tab extends BaseComponent {
            static get NAME() {
                return NAME$1;
            }
            show() {
                if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(CLASS_NAME_ACTIVE)) return;
                let previous;
                const target = getElementFromSelector(this._element);
                const listElement = this._element.closest(SELECTOR_NAV_LIST_GROUP);
                if (listElement) {
                    const itemSelector = "UL" === listElement.nodeName || "OL" === listElement.nodeName ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;
                    previous = SelectorEngine.find(itemSelector, listElement);
                    previous = previous[previous.length - 1];
                }
                const hideEvent = previous ? EventHandler.trigger(previous, EVENT_HIDE$1, {
                    relatedTarget: this._element
                }) : null;
                const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$1, {
                    relatedTarget: previous
                });
                if (showEvent.defaultPrevented || null !== hideEvent && hideEvent.defaultPrevented) return;
                this._activate(this._element, listElement);
                const complete = () => {
                    EventHandler.trigger(previous, EVENT_HIDDEN$1, {
                        relatedTarget: this._element
                    });
                    EventHandler.trigger(this._element, EVENT_SHOWN$1, {
                        relatedTarget: previous
                    });
                };
                if (target) this._activate(target, target.parentNode, complete); else complete();
            }
            _activate(element, container, callback) {
                const activeElements = container && ("UL" === container.nodeName || "OL" === container.nodeName) ? SelectorEngine.find(SELECTOR_ACTIVE_UL, container) : SelectorEngine.children(container, SELECTOR_ACTIVE);
                const active = activeElements[0];
                const isTransitioning = callback && active && active.classList.contains(CLASS_NAME_FADE$1);
                const complete = () => this._transitionComplete(element, active, callback);
                if (active && isTransitioning) {
                    active.classList.remove(CLASS_NAME_SHOW$1);
                    this._queueCallback(complete, element, true);
                } else complete();
            }
            _transitionComplete(element, active, callback) {
                if (active) {
                    active.classList.remove(CLASS_NAME_ACTIVE);
                    const dropdownChild = SelectorEngine.findOne(SELECTOR_DROPDOWN_ACTIVE_CHILD, active.parentNode);
                    if (dropdownChild) dropdownChild.classList.remove(CLASS_NAME_ACTIVE);
                    if ("tab" === active.getAttribute("role")) active.setAttribute("aria-selected", false);
                }
                element.classList.add(CLASS_NAME_ACTIVE);
                if ("tab" === element.getAttribute("role")) element.setAttribute("aria-selected", true);
                reflow(element);
                if (element.classList.contains(CLASS_NAME_FADE$1)) element.classList.add(CLASS_NAME_SHOW$1);
                let parent = element.parentNode;
                if (parent && "LI" === parent.nodeName) parent = parent.parentNode;
                if (parent && parent.classList.contains(CLASS_NAME_DROPDOWN_MENU)) {
                    const dropdownElement = element.closest(SELECTOR_DROPDOWN);
                    if (dropdownElement) SelectorEngine.find(SELECTOR_DROPDOWN_TOGGLE, dropdownElement).forEach((dropdown => dropdown.classList.add(CLASS_NAME_ACTIVE)));
                    element.setAttribute("aria-expanded", true);
                }
                if (callback) callback();
            }
            static jQueryInterface(config) {
                return this.each((function() {
                    const data = Tab.getOrCreateInstance(this);
                    if ("string" === typeof config) {
                        if ("undefined" === typeof data[config]) throw new TypeError(`No method named "${config}"`);
                        data[config]();
                    }
                }));
            }
        }
        EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, (function(event) {
            if ([ "A", "AREA" ].includes(this.tagName)) event.preventDefault();
            if (isDisabled(this)) return;
            const data = Tab.getOrCreateInstance(this);
            data.show();
        }));
        defineJQueryPlugin(Tab);
        const NAME = "toast";
        const DATA_KEY = "bs.toast";
        const EVENT_KEY = `.${DATA_KEY}`;
        const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
        const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
        const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
        const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
        const EVENT_HIDE = `hide${EVENT_KEY}`;
        const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
        const EVENT_SHOW = `show${EVENT_KEY}`;
        const EVENT_SHOWN = `shown${EVENT_KEY}`;
        const CLASS_NAME_FADE = "fade";
        const CLASS_NAME_HIDE = "hide";
        const CLASS_NAME_SHOW = "show";
        const CLASS_NAME_SHOWING = "showing";
        const DefaultType = {
            animation: "boolean",
            autohide: "boolean",
            delay: "number"
        };
        const Default = {
            animation: true,
            autohide: true,
            delay: 5e3
        };
        class Toast extends BaseComponent {
            constructor(element, config) {
                super(element);
                this._config = this._getConfig(config);
                this._timeout = null;
                this._hasMouseInteraction = false;
                this._hasKeyboardInteraction = false;
                this._setListeners();
            }
            static get DefaultType() {
                return DefaultType;
            }
            static get Default() {
                return Default;
            }
            static get NAME() {
                return NAME;
            }
            show() {
                const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
                if (showEvent.defaultPrevented) return;
                this._clearTimeout();
                if (this._config.animation) this._element.classList.add(CLASS_NAME_FADE);
                const complete = () => {
                    this._element.classList.remove(CLASS_NAME_SHOWING);
                    EventHandler.trigger(this._element, EVENT_SHOWN);
                    this._maybeScheduleHide();
                };
                this._element.classList.remove(CLASS_NAME_HIDE);
                reflow(this._element);
                this._element.classList.add(CLASS_NAME_SHOW);
                this._element.classList.add(CLASS_NAME_SHOWING);
                this._queueCallback(complete, this._element, this._config.animation);
            }
            hide() {
                if (!this._element.classList.contains(CLASS_NAME_SHOW)) return;
                const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
                if (hideEvent.defaultPrevented) return;
                const complete = () => {
                    this._element.classList.add(CLASS_NAME_HIDE);
                    this._element.classList.remove(CLASS_NAME_SHOWING);
                    this._element.classList.remove(CLASS_NAME_SHOW);
                    EventHandler.trigger(this._element, EVENT_HIDDEN);
                };
                this._element.classList.add(CLASS_NAME_SHOWING);
                this._queueCallback(complete, this._element, this._config.animation);
            }
            dispose() {
                this._clearTimeout();
                if (this._element.classList.contains(CLASS_NAME_SHOW)) this._element.classList.remove(CLASS_NAME_SHOW);
                super.dispose();
            }
            _getConfig(config) {
                config = {
                    ...Default,
                    ...Manipulator.getDataAttributes(this._element),
                    ..."object" === typeof config && config ? config : {}
                };
                typeCheckConfig(NAME, config, this.constructor.DefaultType);
                return config;
            }
            _maybeScheduleHide() {
                if (!this._config.autohide) return;
                if (this._hasMouseInteraction || this._hasKeyboardInteraction) return;
                this._timeout = setTimeout((() => {
                    this.hide();
                }), this._config.delay);
            }
            _onInteraction(event, isInteracting) {
                switch (event.type) {
                  case "mouseover":
                  case "mouseout":
                    this._hasMouseInteraction = isInteracting;
                    break;

                  case "focusin":
                  case "focusout":
                    this._hasKeyboardInteraction = isInteracting;
                    break;
                }
                if (isInteracting) {
                    this._clearTimeout();
                    return;
                }
                const nextElement = event.relatedTarget;
                if (this._element === nextElement || this._element.contains(nextElement)) return;
                this._maybeScheduleHide();
            }
            _setListeners() {
                EventHandler.on(this._element, EVENT_MOUSEOVER, (event => this._onInteraction(event, true)));
                EventHandler.on(this._element, EVENT_MOUSEOUT, (event => this._onInteraction(event, false)));
                EventHandler.on(this._element, EVENT_FOCUSIN, (event => this._onInteraction(event, true)));
                EventHandler.on(this._element, EVENT_FOCUSOUT, (event => this._onInteraction(event, false)));
            }
            _clearTimeout() {
                clearTimeout(this._timeout);
                this._timeout = null;
            }
            static jQueryInterface(config) {
                return this.each((function() {
                    const data = Toast.getOrCreateInstance(this, config);
                    if ("string" === typeof config) {
                        if ("undefined" === typeof data[config]) throw new TypeError(`No method named "${config}"`);
                        data[config](this);
                    }
                }));
            }
        }
        enableDismissTrigger(Toast);
        defineJQueryPlugin(Toast);
        __webpack_require__(70);
        var HOOKS = [ "onChange", "onClose", "onDayCreate", "onDestroy", "onKeyDown", "onMonthChange", "onOpen", "onParseConfig", "onReady", "onValueUpdate", "onYearChange", "onPreCalendarPosition" ];
        var options_defaults = {
            _disable: [],
            allowInput: false,
            allowInvalidPreload: false,
            altFormat: "F j, Y",
            altInput: false,
            altInputClass: "form-control input",
            animate: "object" === typeof window && -1 === window.navigator.userAgent.indexOf("MSIE"),
            ariaDateFormat: "F j, Y",
            autoFillDefaultTime: true,
            clickOpens: true,
            closeOnSelect: true,
            conjunction: ", ",
            dateFormat: "Y-m-d",
            defaultHour: 12,
            defaultMinute: 0,
            defaultSeconds: 0,
            disable: [],
            disableMobile: false,
            enableSeconds: false,
            enableTime: false,
            errorHandler: function(err) {
                return "undefined" !== typeof console && console.warn(err);
            },
            getWeek: function(givenDate) {
                var date = new Date(givenDate.getTime());
                date.setHours(0, 0, 0, 0);
                date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
                var week1 = new Date(date.getFullYear(), 0, 4);
                return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
            },
            hourIncrement: 1,
            ignoredFocusElements: [],
            inline: false,
            locale: "default",
            minuteIncrement: 5,
            mode: "single",
            monthSelectorType: "dropdown",
            nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
            noCalendar: false,
            now: new Date,
            onChange: [],
            onClose: [],
            onDayCreate: [],
            onDestroy: [],
            onKeyDown: [],
            onMonthChange: [],
            onOpen: [],
            onParseConfig: [],
            onReady: [],
            onValueUpdate: [],
            onYearChange: [],
            onPreCalendarPosition: [],
            plugins: [],
            position: "auto",
            positionElement: void 0,
            prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
            shorthandCurrentMonth: false,
            showMonths: 1,
            static: false,
            time_24hr: false,
            weekNumbers: false,
            wrap: false
        };
        var english = {
            weekdays: {
                shorthand: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                longhand: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ]
            },
            months: {
                shorthand: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
                longhand: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ]
            },
            daysInMonth: [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ],
            firstDayOfWeek: 0,
            ordinal: function(nth) {
                var s = nth % 100;
                if (s > 3 && s < 21) return "th";
                switch (s % 10) {
                  case 1:
                    return "st";

                  case 2:
                    return "nd";

                  case 3:
                    return "rd";

                  default:
                    return "th";
                }
            },
            rangeSeparator: " to ",
            weekAbbreviation: "Wk",
            scrollTitle: "Scroll to increment",
            toggleTitle: "Click to toggle",
            amPM: [ "AM", "PM" ],
            yearAriaLabel: "Year",
            monthAriaLabel: "Month",
            hourAriaLabel: "Hour",
            minuteAriaLabel: "Minute",
            time_24hr: false
        };
        const l10n_default = english;
        var pad = function(number, length) {
            if (void 0 === length) length = 2;
            return ("000" + number).slice(-1 * length);
        };
        var utils_int = function(bool) {
            return true === bool ? 1 : 0;
        };
        function utils_debounce(fn, wait) {
            var t;
            return function() {
                var _this = this;
                var args = arguments;
                clearTimeout(t);
                t = setTimeout((function() {
                    return fn.apply(_this, args);
                }), wait);
            };
        }
        var arrayify = function(obj) {
            return obj instanceof Array ? obj : [ obj ];
        };
        function dom_toggleClass(elem, className, bool) {
            if (true === bool) return elem.classList.add(className);
            elem.classList.remove(className);
        }
        function createElement(tag, className, content) {
            var e = window.document.createElement(tag);
            className = className || "";
            content = content || "";
            e.className = className;
            if (void 0 !== content) e.textContent = content;
            return e;
        }
        function clearNode(node) {
            while (node.firstChild) node.removeChild(node.firstChild);
        }
        function findParent(node, condition) {
            if (condition(node)) return node; else if (node.parentNode) return findParent(node.parentNode, condition);
            return;
        }
        function createNumberInput(inputClassName, opts) {
            var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
            if (-1 === navigator.userAgent.indexOf("MSIE 9.0")) numInput.type = "number"; else {
                numInput.type = "text";
                numInput.pattern = "\\d*";
            }
            if (void 0 !== opts) for (var key in opts) numInput.setAttribute(key, opts[key]);
            wrapper.appendChild(numInput);
            wrapper.appendChild(arrowUp);
            wrapper.appendChild(arrowDown);
            return wrapper;
        }
        function getEventTarget(event) {
            try {
                if ("function" === typeof event.composedPath) {
                    var path = event.composedPath();
                    return path[0];
                }
                return event.target;
            } catch (error) {
                return event.target;
            }
        }
        var doNothing = function() {
            return;
        };
        var monthToStr = function(monthNumber, shorthand, locale) {
            return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
        };
        var revFormat = {
            D: doNothing,
            F: function(dateObj, monthName, locale) {
                dateObj.setMonth(locale.months.longhand.indexOf(monthName));
            },
            G: function(dateObj, hour) {
                dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
            },
            H: function(dateObj, hour) {
                dateObj.setHours(parseFloat(hour));
            },
            J: function(dateObj, day) {
                dateObj.setDate(parseFloat(day));
            },
            K: function(dateObj, amPM, locale) {
                dateObj.setHours(dateObj.getHours() % 12 + 12 * utils_int(new RegExp(locale.amPM[1], "i").test(amPM)));
            },
            M: function(dateObj, shortMonth, locale) {
                dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
            },
            S: function(dateObj, seconds) {
                dateObj.setSeconds(parseFloat(seconds));
            },
            U: function(_, unixSeconds) {
                return new Date(1e3 * parseFloat(unixSeconds));
            },
            W: function(dateObj, weekNum, locale) {
                var weekNumber = parseInt(weekNum);
                var date = new Date(dateObj.getFullYear(), 0, 2 + 7 * (weekNumber - 1), 0, 0, 0, 0);
                date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
                return date;
            },
            Y: function(dateObj, year) {
                dateObj.setFullYear(parseFloat(year));
            },
            Z: function(_, ISODate) {
                return new Date(ISODate);
            },
            d: function(dateObj, day) {
                dateObj.setDate(parseFloat(day));
            },
            h: function(dateObj, hour) {
                dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
            },
            i: function(dateObj, minutes) {
                dateObj.setMinutes(parseFloat(minutes));
            },
            j: function(dateObj, day) {
                dateObj.setDate(parseFloat(day));
            },
            l: doNothing,
            m: function(dateObj, month) {
                dateObj.setMonth(parseFloat(month) - 1);
            },
            n: function(dateObj, month) {
                dateObj.setMonth(parseFloat(month) - 1);
            },
            s: function(dateObj, seconds) {
                dateObj.setSeconds(parseFloat(seconds));
            },
            u: function(_, unixMillSeconds) {
                return new Date(parseFloat(unixMillSeconds));
            },
            w: doNothing,
            y: function(dateObj, year) {
                dateObj.setFullYear(2e3 + parseFloat(year));
            }
        };
        var tokenRegex = {
            D: "",
            F: "",
            G: "(\\d\\d|\\d)",
            H: "(\\d\\d|\\d)",
            J: "(\\d\\d|\\d)\\w+",
            K: "",
            M: "",
            S: "(\\d\\d|\\d)",
            U: "(.+)",
            W: "(\\d\\d|\\d)",
            Y: "(\\d{4})",
            Z: "(.+)",
            d: "(\\d\\d|\\d)",
            h: "(\\d\\d|\\d)",
            i: "(\\d\\d|\\d)",
            j: "(\\d\\d|\\d)",
            l: "",
            m: "(\\d\\d|\\d)",
            n: "(\\d\\d|\\d)",
            s: "(\\d\\d|\\d)",
            u: "(.+)",
            w: "(\\d\\d|\\d)",
            y: "(\\d{2})"
        };
        var formats = {
            Z: function(date) {
                return date.toISOString();
            },
            D: function(date, locale, options) {
                return locale.weekdays.shorthand[formats.w(date, locale, options)];
            },
            F: function(date, locale, options) {
                return monthToStr(formats.n(date, locale, options) - 1, false, locale);
            },
            G: function(date, locale, options) {
                return pad(formats.h(date, locale, options));
            },
            H: function(date) {
                return pad(date.getHours());
            },
            J: function(date, locale) {
                return void 0 !== locale.ordinal ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
            },
            K: function(date, locale) {
                return locale.amPM[utils_int(date.getHours() > 11)];
            },
            M: function(date, locale) {
                return monthToStr(date.getMonth(), true, locale);
            },
            S: function(date) {
                return pad(date.getSeconds());
            },
            U: function(date) {
                return date.getTime() / 1e3;
            },
            W: function(date, _, options) {
                return options.getWeek(date);
            },
            Y: function(date) {
                return pad(date.getFullYear(), 4);
            },
            d: function(date) {
                return pad(date.getDate());
            },
            h: function(date) {
                return date.getHours() % 12 ? date.getHours() % 12 : 12;
            },
            i: function(date) {
                return pad(date.getMinutes());
            },
            j: function(date) {
                return date.getDate();
            },
            l: function(date, locale) {
                return locale.weekdays.longhand[date.getDay()];
            },
            m: function(date) {
                return pad(date.getMonth() + 1);
            },
            n: function(date) {
                return date.getMonth() + 1;
            },
            s: function(date) {
                return date.getSeconds();
            },
            u: function(date) {
                return date.getTime();
            },
            w: function(date) {
                return date.getDay();
            },
            y: function(date) {
                return String(date.getFullYear()).substring(2);
            }
        };
        var createDateFormatter = function(_a) {
            var _b = _a.config, config = void 0 === _b ? options_defaults : _b, _c = _a.l10n, l10n = void 0 === _c ? english : _c, _d = _a.isMobile, isMobile = void 0 === _d ? false : _d;
            return function(dateObj, frmt, overrideLocale) {
                var locale = overrideLocale || l10n;
                if (void 0 !== config.formatDate && !isMobile) return config.formatDate(dateObj, frmt, locale);
                return frmt.split("").map((function(c, i, arr) {
                    return formats[c] && "\\" !== arr[i - 1] ? formats[c](dateObj, locale, config) : "\\" !== c ? c : "";
                })).join("");
            };
        };
        var createDateParser = function(_a) {
            var _b = _a.config, config = void 0 === _b ? options_defaults : _b, _c = _a.l10n, l10n = void 0 === _c ? english : _c;
            return function(date, givenFormat, timeless, customLocale) {
                if (0 !== date && !date) return;
                var locale = customLocale || l10n;
                var parsedDate;
                var dateOrig = date;
                if (date instanceof Date) parsedDate = new Date(date.getTime()); else if ("string" !== typeof date && void 0 !== date.toFixed) parsedDate = new Date(date); else if ("string" === typeof date) {
                    var format = givenFormat || (config || options_defaults).dateFormat;
                    var datestr = String(date).trim();
                    if ("today" === datestr) {
                        parsedDate = new Date;
                        timeless = true;
                    } else if (config && config.parseDate) parsedDate = config.parseDate(date, format); else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) parsedDate = new Date(date); else {
                        var matched = void 0, ops = [];
                        for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
                            var token = format[i];
                            var isBackSlash = "\\" === token;
                            var escaped = "\\" === format[i - 1] || isBackSlash;
                            if (tokenRegex[token] && !escaped) {
                                regexStr += tokenRegex[token];
                                var match = new RegExp(regexStr).exec(date);
                                if (match && (matched = true)) ops["Y" !== token ? "push" : "unshift"]({
                                    fn: revFormat[token],
                                    val: match[++matchIndex]
                                });
                            } else if (!isBackSlash) regexStr += ".";
                        }
                        parsedDate = !config || !config.noCalendar ? new Date((new Date).getFullYear(), 0, 1, 0, 0, 0, 0) : new Date((new Date).setHours(0, 0, 0, 0));
                        ops.forEach((function(_a) {
                            var fn = _a.fn, val = _a.val;
                            return parsedDate = fn(parsedDate, val, locale) || parsedDate;
                        }));
                        parsedDate = matched ? parsedDate : void 0;
                    }
                }
                if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
                    config.errorHandler(new Error("Invalid date provided: " + dateOrig));
                    return;
                }
                if (true === timeless) parsedDate.setHours(0, 0, 0, 0);
                return parsedDate;
            };
        };
        function compareDates(date1, date2, timeless) {
            if (void 0 === timeless) timeless = true;
            if (false !== timeless) return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
            return date1.getTime() - date2.getTime();
        }
        var isBetween = function(ts, ts1, ts2) {
            return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
        };
        var calculateSecondsSinceMidnight = function(hours, minutes, seconds) {
            return 3600 * hours + 60 * minutes + seconds;
        };
        var parseSeconds = function(secondsSinceMidnight) {
            var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - 3600 * hours) / 60;
            return [ hours, minutes, secondsSinceMidnight - 3600 * hours - 60 * minutes ];
        };
        var duration = {
            DAY: 864e5
        };
        function getDefaultHours(config) {
            var hours = config.defaultHour;
            var minutes = config.defaultMinute;
            var seconds = config.defaultSeconds;
            if (void 0 !== config.minDate) {
                var minHour = config.minDate.getHours();
                var minMinutes = config.minDate.getMinutes();
                var minSeconds = config.minDate.getSeconds();
                if (hours < minHour) hours = minHour;
                if (hours === minHour && minutes < minMinutes) minutes = minMinutes;
                if (hours === minHour && minutes === minMinutes && seconds < minSeconds) seconds = config.minDate.getSeconds();
            }
            if (void 0 !== config.maxDate) {
                var maxHr = config.maxDate.getHours();
                var maxMinutes = config.maxDate.getMinutes();
                hours = Math.min(hours, maxHr);
                if (hours === maxHr) minutes = Math.min(maxMinutes, minutes);
                if (hours === maxHr && minutes === maxMinutes) seconds = config.maxDate.getSeconds();
            }
            return {
                hours,
                minutes,
                seconds
            };
        }
        __webpack_require__(1895);
        var esm_assign = void 0 && (void 0).__assign || function() {
            esm_assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return esm_assign.apply(this, arguments);
        };
        var esm_spreadArrays = void 0 && (void 0).__spreadArrays || function() {
            for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
            var r = Array(s), k = 0;
            for (i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, 
            k++) r[k] = a[j];
            return r;
        };
        var DEBOUNCED_CHANGE_MS = 300;
        function FlatpickrInstance(element, instanceConfig) {
            var self = {
                config: esm_assign(esm_assign({}, options_defaults), esm_flatpickr.defaultConfig),
                l10n: l10n_default
            };
            self.parseDate = createDateParser({
                config: self.config,
                l10n: self.l10n
            });
            self._handlers = [];
            self.pluginElements = [];
            self.loadedPlugins = [];
            self._bind = bind;
            self._setHoursFromDate = setHoursFromDate;
            self._positionCalendar = positionCalendar;
            self.changeMonth = changeMonth;
            self.changeYear = changeYear;
            self.clear = clear;
            self.close = close;
            self.onMouseOver = onMouseOver;
            self._createElement = createElement;
            self.createDay = createDay;
            self.destroy = destroy;
            self.isEnabled = isEnabled;
            self.jumpToDate = jumpToDate;
            self.updateValue = updateValue;
            self.open = open;
            self.redraw = redraw;
            self.set = set;
            self.setDate = setDate;
            self.toggle = toggle;
            function setupHelperFunctions() {
                self.utils = {
                    getDaysInMonth: function(month, yr) {
                        if (void 0 === month) month = self.currentMonth;
                        if (void 0 === yr) yr = self.currentYear;
                        if (1 === month && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;
                        return self.l10n.daysInMonth[month];
                    }
                };
            }
            function init() {
                self.element = self.input = element;
                self.isOpen = false;
                parseConfig();
                setupLocale();
                setupInputs();
                setupDates();
                setupHelperFunctions();
                if (!self.isMobile) build();
                bindEvents();
                if (self.selectedDates.length || self.config.noCalendar) {
                    if (self.config.enableTime) setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj : void 0);
                    updateValue(false);
                }
                setCalendarWidth();
                var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                if (!self.isMobile && isSafari) positionCalendar();
                triggerEvent("onReady");
            }
            function getClosestActiveElement() {
                var _a;
                return (null === (_a = self.calendarContainer) || void 0 === _a ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
            }
            function bindToInstance(fn) {
                return fn.bind(self);
            }
            function setCalendarWidth() {
                var config = self.config;
                if (false === config.weekNumbers && 1 === config.showMonths) return; else if (true !== config.noCalendar) window.requestAnimationFrame((function() {
                    if (void 0 !== self.calendarContainer) {
                        self.calendarContainer.style.visibility = "hidden";
                        self.calendarContainer.style.display = "block";
                    }
                    if (void 0 !== self.daysContainer) {
                        var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
                        self.daysContainer.style.width = daysWidth + "px";
                        self.calendarContainer.style.width = daysWidth + (void 0 !== self.weekWrapper ? self.weekWrapper.offsetWidth : 0) + "px";
                        self.calendarContainer.style.removeProperty("visibility");
                        self.calendarContainer.style.removeProperty("display");
                    }
                }));
            }
            function updateTime(e) {
                if (0 === self.selectedDates.length) {
                    var defaultDate = void 0 === self.config.minDate || compareDates(new Date, self.config.minDate) >= 0 ? new Date : new Date(self.config.minDate.getTime());
                    var defaults = getDefaultHours(self.config);
                    defaultDate.setHours(defaults.hours, defaults.minutes, defaults.seconds, defaultDate.getMilliseconds());
                    self.selectedDates = [ defaultDate ];
                    self.latestSelectedDateObj = defaultDate;
                }
                if (void 0 !== e && "blur" !== e.type) timeWrapper(e);
                var prevValue = self._input.value;
                setHoursFromInputs();
                updateValue();
                if (self._input.value !== prevValue) self._debouncedChange();
            }
            function ampm2military(hour, amPM) {
                return hour % 12 + 12 * utils_int(amPM === self.l10n.amPM[1]);
            }
            function military2ampm(hour) {
                switch (hour % 24) {
                  case 0:
                  case 12:
                    return 12;

                  default:
                    return hour % 12;
                }
            }
            function setHoursFromInputs() {
                if (void 0 === self.hourElement || void 0 === self.minuteElement) return;
                var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = void 0 !== self.secondElement ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;
                if (void 0 !== self.amPM) hours = ampm2military(hours, self.amPM.textContent);
                var limitMinHours = void 0 !== self.config.minTime || self.config.minDate && self.minDateHasTime && self.latestSelectedDateObj && 0 === compareDates(self.latestSelectedDateObj, self.config.minDate, true);
                var limitMaxHours = void 0 !== self.config.maxTime || self.config.maxDate && self.maxDateHasTime && self.latestSelectedDateObj && 0 === compareDates(self.latestSelectedDateObj, self.config.maxDate, true);
                if (void 0 !== self.config.maxTime && void 0 !== self.config.minTime && self.config.minTime > self.config.maxTime) {
                    var minBound = calculateSecondsSinceMidnight(self.config.minTime.getHours(), self.config.minTime.getMinutes(), self.config.minTime.getSeconds());
                    var maxBound = calculateSecondsSinceMidnight(self.config.maxTime.getHours(), self.config.maxTime.getMinutes(), self.config.maxTime.getSeconds());
                    var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
                    if (currentTime > maxBound && currentTime < minBound) {
                        var result = parseSeconds(minBound);
                        hours = result[0];
                        minutes = result[1];
                        seconds = result[2];
                    }
                } else {
                    if (limitMaxHours) {
                        var maxTime = void 0 !== self.config.maxTime ? self.config.maxTime : self.config.maxDate;
                        hours = Math.min(hours, maxTime.getHours());
                        if (hours === maxTime.getHours()) minutes = Math.min(minutes, maxTime.getMinutes());
                        if (minutes === maxTime.getMinutes()) seconds = Math.min(seconds, maxTime.getSeconds());
                    }
                    if (limitMinHours) {
                        var minTime = void 0 !== self.config.minTime ? self.config.minTime : self.config.minDate;
                        hours = Math.max(hours, minTime.getHours());
                        if (hours === minTime.getHours() && minutes < minTime.getMinutes()) minutes = minTime.getMinutes();
                        if (minutes === minTime.getMinutes()) seconds = Math.max(seconds, minTime.getSeconds());
                    }
                }
                setHours(hours, minutes, seconds);
            }
            function setHoursFromDate(dateObj) {
                var date = dateObj || self.latestSelectedDateObj;
                if (date && date instanceof Date) setHours(date.getHours(), date.getMinutes(), date.getSeconds());
            }
            function setHours(hours, minutes, seconds) {
                if (void 0 !== self.latestSelectedDateObj) self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
                if (!self.hourElement || !self.minuteElement || self.isMobile) return;
                self.hourElement.value = pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * utils_int(hours % 12 === 0) : hours);
                self.minuteElement.value = pad(minutes);
                if (void 0 !== self.amPM) self.amPM.textContent = self.l10n.amPM[utils_int(hours >= 12)];
                if (void 0 !== self.secondElement) self.secondElement.value = pad(seconds);
            }
            function onYearInput(event) {
                var eventTarget = getEventTarget(event);
                var year = parseInt(eventTarget.value) + (event.delta || 0);
                if (year / 1e3 > 1 || "Enter" === event.key && !/[^\d]/.test(year.toString())) changeYear(year);
            }
            function bind(element, event, handler, options) {
                if (event instanceof Array) return event.forEach((function(ev) {
                    return bind(element, ev, handler, options);
                }));
                if (element instanceof Array) return element.forEach((function(el) {
                    return bind(el, event, handler, options);
                }));
                element.addEventListener(event, handler, options);
                self._handlers.push({
                    remove: function() {
                        return element.removeEventListener(event, handler, options);
                    }
                });
            }
            function triggerChange() {
                triggerEvent("onChange");
            }
            function bindEvents() {
                if (self.config.wrap) [ "open", "close", "toggle", "clear" ].forEach((function(evt) {
                    Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), (function(el) {
                        return bind(el, "click", self[evt]);
                    }));
                }));
                if (self.isMobile) {
                    setupMobile();
                    return;
                }
                var debouncedResize = utils_debounce(onResize, 50);
                self._debouncedChange = utils_debounce(triggerChange, DEBOUNCED_CHANGE_MS);
                if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent)) bind(self.daysContainer, "mouseover", (function(e) {
                    if ("range" === self.config.mode) onMouseOver(getEventTarget(e));
                }));
                bind(self._input, "keydown", onKeyDown);
                if (void 0 !== self.calendarContainer) bind(self.calendarContainer, "keydown", onKeyDown);
                if (!self.config.inline && !self.config.static) bind(window, "resize", debouncedResize);
                if (void 0 !== window.ontouchstart) bind(window.document, "touchstart", documentClick); else bind(window.document, "mousedown", documentClick);
                bind(window.document, "focus", documentClick, {
                    capture: true
                });
                if (true === self.config.clickOpens) {
                    bind(self._input, "focus", self.open);
                    bind(self._input, "click", self.open);
                }
                if (void 0 !== self.daysContainer) {
                    bind(self.monthNav, "click", onMonthNavClick);
                    bind(self.monthNav, [ "keyup", "increment" ], onYearInput);
                    bind(self.daysContainer, "click", selectDate);
                }
                if (void 0 !== self.timeContainer && void 0 !== self.minuteElement && void 0 !== self.hourElement) {
                    var selText = function(e) {
                        return getEventTarget(e).select();
                    };
                    bind(self.timeContainer, [ "increment" ], updateTime);
                    bind(self.timeContainer, "blur", updateTime, {
                        capture: true
                    });
                    bind(self.timeContainer, "click", timeIncrement);
                    bind([ self.hourElement, self.minuteElement ], [ "focus", "click" ], selText);
                    if (void 0 !== self.secondElement) bind(self.secondElement, "focus", (function() {
                        return self.secondElement && self.secondElement.select();
                    }));
                    if (void 0 !== self.amPM) bind(self.amPM, "click", (function(e) {
                        updateTime(e);
                    }));
                }
                if (self.config.allowInput) bind(self._input, "blur", onBlur);
            }
            function jumpToDate(jumpDate, triggerChange) {
                var jumpTo = void 0 !== jumpDate ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate && self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);
                var oldYear = self.currentYear;
                var oldMonth = self.currentMonth;
                try {
                    if (void 0 !== jumpTo) {
                        self.currentYear = jumpTo.getFullYear();
                        self.currentMonth = jumpTo.getMonth();
                    }
                } catch (e) {
                    e.message = "Invalid date supplied: " + jumpTo;
                    self.config.errorHandler(e);
                }
                if (triggerChange && self.currentYear !== oldYear) {
                    triggerEvent("onYearChange");
                    buildMonthSwitch();
                }
                if (triggerChange && (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) triggerEvent("onMonthChange");
                self.redraw();
            }
            function timeIncrement(e) {
                var eventTarget = getEventTarget(e);
                if (~eventTarget.className.indexOf("arrow")) incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
            }
            function incrementNumInput(e, delta, inputElem) {
                var target = e && getEventTarget(e);
                var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
                var event = createEvent("increment");
                event.delta = delta;
                input && input.dispatchEvent(event);
            }
            function build() {
                var fragment = window.document.createDocumentFragment();
                self.calendarContainer = createElement("div", "flatpickr-calendar");
                self.calendarContainer.tabIndex = -1;
                if (!self.config.noCalendar) {
                    fragment.appendChild(buildMonthNav());
                    self.innerContainer = createElement("div", "flatpickr-innerContainer");
                    if (self.config.weekNumbers) {
                        var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
                        self.innerContainer.appendChild(weekWrapper);
                        self.weekNumbers = weekNumbers;
                        self.weekWrapper = weekWrapper;
                    }
                    self.rContainer = createElement("div", "flatpickr-rContainer");
                    self.rContainer.appendChild(buildWeekdays());
                    if (!self.daysContainer) {
                        self.daysContainer = createElement("div", "flatpickr-days");
                        self.daysContainer.tabIndex = -1;
                    }
                    buildDays();
                    self.rContainer.appendChild(self.daysContainer);
                    self.innerContainer.appendChild(self.rContainer);
                    fragment.appendChild(self.innerContainer);
                }
                if (self.config.enableTime) fragment.appendChild(buildTime());
                dom_toggleClass(self.calendarContainer, "rangeMode", "range" === self.config.mode);
                dom_toggleClass(self.calendarContainer, "animate", true === self.config.animate);
                dom_toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
                self.calendarContainer.appendChild(fragment);
                var customAppend = void 0 !== self.config.appendTo && void 0 !== self.config.appendTo.nodeType;
                if (self.config.inline || self.config.static) {
                    self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
                    if (self.config.inline) if (!customAppend && self.element.parentNode) self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling); else if (void 0 !== self.config.appendTo) self.config.appendTo.appendChild(self.calendarContainer);
                    if (self.config.static) {
                        var wrapper = createElement("div", "flatpickr-wrapper");
                        if (self.element.parentNode) self.element.parentNode.insertBefore(wrapper, self.element);
                        wrapper.appendChild(self.element);
                        if (self.altInput) wrapper.appendChild(self.altInput);
                        wrapper.appendChild(self.calendarContainer);
                    }
                }
                if (!self.config.static && !self.config.inline) (void 0 !== self.config.appendTo ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
            }
            function createDay(className, date, dayNumber, i) {
                var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", className, date.getDate().toString());
                dayElement.dateObj = date;
                dayElement.$i = i;
                dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
                if (-1 === className.indexOf("hidden") && 0 === compareDates(date, self.now)) {
                    self.todayDateElem = dayElement;
                    dayElement.classList.add("today");
                    dayElement.setAttribute("aria-current", "date");
                }
                if (dateIsEnabled) {
                    dayElement.tabIndex = -1;
                    if (isDateSelected(date)) {
                        dayElement.classList.add("selected");
                        self.selectedDateElem = dayElement;
                        if ("range" === self.config.mode) {
                            dom_toggleClass(dayElement, "startRange", self.selectedDates[0] && 0 === compareDates(date, self.selectedDates[0], true));
                            dom_toggleClass(dayElement, "endRange", self.selectedDates[1] && 0 === compareDates(date, self.selectedDates[1], true));
                            if ("nextMonthDay" === className) dayElement.classList.add("inRange");
                        }
                    }
                } else dayElement.classList.add("flatpickr-disabled");
                if ("range" === self.config.mode) if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add("inRange");
                if (self.weekNumbers && 1 === self.config.showMonths && "prevMonthDay" !== className && dayNumber % 7 === 1) self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
                triggerEvent("onDayCreate", dayElement);
                return dayElement;
            }
            function focusOnDayElem(targetNode) {
                targetNode.focus();
                if ("range" === self.config.mode) onMouseOver(targetNode);
            }
            function getFirstAvailableDay(delta) {
                var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
                var endMonth = delta > 0 ? self.config.showMonths : -1;
                for (var m = startMonth; m != endMonth; m += delta) {
                    var month = self.daysContainer.children[m];
                    var startIndex = delta > 0 ? 0 : month.children.length - 1;
                    var endIndex = delta > 0 ? month.children.length : -1;
                    for (var i = startIndex; i != endIndex; i += delta) {
                        var c = month.children[i];
                        if (-1 === c.className.indexOf("hidden") && isEnabled(c.dateObj)) return c;
                    }
                }
                return;
            }
            function getNextAvailableDay(current, delta) {
                var givenMonth = -1 === current.className.indexOf("Month") ? current.dateObj.getMonth() : self.currentMonth;
                var endMonth = delta > 0 ? self.config.showMonths : -1;
                var loopDelta = delta > 0 ? 1 : -1;
                for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
                    var month = self.daysContainer.children[m];
                    var startIndex = givenMonth - self.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
                    var numMonthDays = month.children.length;
                    for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
                        var c = month.children[i];
                        if (-1 === c.className.indexOf("hidden") && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta)) return focusOnDayElem(c);
                    }
                }
                self.changeMonth(loopDelta);
                focusOnDay(getFirstAvailableDay(loopDelta), 0);
                return;
            }
            function focusOnDay(current, offset) {
                var activeElement = getClosestActiveElement();
                var dayFocused = isInView(activeElement || document.body);
                var startElem = void 0 !== current ? current : dayFocused ? activeElement : void 0 !== self.selectedDateElem && isInView(self.selectedDateElem) ? self.selectedDateElem : void 0 !== self.todayDateElem && isInView(self.todayDateElem) ? self.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);
                if (void 0 === startElem) self._input.focus(); else if (!dayFocused) focusOnDayElem(startElem); else getNextAvailableDay(startElem, offset);
            }
            function buildMonthDays(year, month) {
                var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
                var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12, year);
                var daysInMonth = self.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
                var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
                for (;dayNumber <= prevMonthDays; dayNumber++, dayIndex++) days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
                for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
                for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (1 === self.config.showMonths || dayIndex % 7 !== 0); dayNum++, 
                dayIndex++) days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
                var dayContainer = createElement("div", "dayContainer");
                dayContainer.appendChild(days);
                return dayContainer;
            }
            function buildDays() {
                if (void 0 === self.daysContainer) return;
                clearNode(self.daysContainer);
                if (self.weekNumbers) clearNode(self.weekNumbers);
                var frag = document.createDocumentFragment();
                for (var i = 0; i < self.config.showMonths; i++) {
                    var d = new Date(self.currentYear, self.currentMonth, 1);
                    d.setMonth(self.currentMonth + i);
                    frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
                }
                self.daysContainer.appendChild(frag);
                self.days = self.daysContainer.firstChild;
                if ("range" === self.config.mode && 1 === self.selectedDates.length) onMouseOver();
            }
            function buildMonthSwitch() {
                if (self.config.showMonths > 1 || "dropdown" !== self.config.monthSelectorType) return;
                var shouldBuildMonth = function(month) {
                    if (void 0 !== self.config.minDate && self.currentYear === self.config.minDate.getFullYear() && month < self.config.minDate.getMonth()) return false;
                    return !(void 0 !== self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear() && month > self.config.maxDate.getMonth());
                };
                self.monthsDropdownContainer.tabIndex = -1;
                self.monthsDropdownContainer.innerHTML = "";
                for (var i = 0; i < 12; i++) {
                    if (!shouldBuildMonth(i)) continue;
                    var month = createElement("option", "flatpickr-monthDropdown-month");
                    month.value = new Date(self.currentYear, i).getMonth().toString();
                    month.textContent = monthToStr(i, self.config.shorthandCurrentMonth, self.l10n);
                    month.tabIndex = -1;
                    if (self.currentMonth === i) month.selected = true;
                    self.monthsDropdownContainer.appendChild(month);
                }
            }
            function buildMonth() {
                var container = createElement("div", "flatpickr-month");
                var monthNavFragment = window.document.createDocumentFragment();
                var monthElement;
                if (self.config.showMonths > 1 || "static" === self.config.monthSelectorType) monthElement = createElement("span", "cur-month"); else {
                    self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
                    self.monthsDropdownContainer.setAttribute("aria-label", self.l10n.monthAriaLabel);
                    bind(self.monthsDropdownContainer, "change", (function(e) {
                        var target = getEventTarget(e);
                        var selectedMonth = parseInt(target.value, 10);
                        self.changeMonth(selectedMonth - self.currentMonth);
                        triggerEvent("onMonthChange");
                    }));
                    buildMonthSwitch();
                    monthElement = self.monthsDropdownContainer;
                }
                var yearInput = createNumberInput("cur-year", {
                    tabindex: "-1"
                });
                var yearElement = yearInput.getElementsByTagName("input")[0];
                yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
                if (self.config.minDate) yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
                if (self.config.maxDate) {
                    yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
                    yearElement.disabled = !!self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
                }
                var currentMonth = createElement("div", "flatpickr-current-month");
                currentMonth.appendChild(monthElement);
                currentMonth.appendChild(yearInput);
                monthNavFragment.appendChild(currentMonth);
                container.appendChild(monthNavFragment);
                return {
                    container,
                    yearElement,
                    monthElement
                };
            }
            function buildMonths() {
                clearNode(self.monthNav);
                self.monthNav.appendChild(self.prevMonthNav);
                if (self.config.showMonths) {
                    self.yearElements = [];
                    self.monthElements = [];
                }
                for (var m = self.config.showMonths; m--; ) {
                    var month = buildMonth();
                    self.yearElements.push(month.yearElement);
                    self.monthElements.push(month.monthElement);
                    self.monthNav.appendChild(month.container);
                }
                self.monthNav.appendChild(self.nextMonthNav);
            }
            function buildMonthNav() {
                self.monthNav = createElement("div", "flatpickr-months");
                self.yearElements = [];
                self.monthElements = [];
                self.prevMonthNav = createElement("span", "flatpickr-prev-month");
                self.prevMonthNav.innerHTML = self.config.prevArrow;
                self.nextMonthNav = createElement("span", "flatpickr-next-month");
                self.nextMonthNav.innerHTML = self.config.nextArrow;
                buildMonths();
                Object.defineProperty(self, "_hidePrevMonthArrow", {
                    get: function() {
                        return self.__hidePrevMonthArrow;
                    },
                    set: function(bool) {
                        if (self.__hidePrevMonthArrow !== bool) {
                            dom_toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
                            self.__hidePrevMonthArrow = bool;
                        }
                    }
                });
                Object.defineProperty(self, "_hideNextMonthArrow", {
                    get: function() {
                        return self.__hideNextMonthArrow;
                    },
                    set: function(bool) {
                        if (self.__hideNextMonthArrow !== bool) {
                            dom_toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
                            self.__hideNextMonthArrow = bool;
                        }
                    }
                });
                self.currentYearElement = self.yearElements[0];
                updateNavigationCurrentMonth();
                return self.monthNav;
            }
            function buildTime() {
                self.calendarContainer.classList.add("hasTime");
                if (self.config.noCalendar) self.calendarContainer.classList.add("noCalendar");
                var defaults = getDefaultHours(self.config);
                self.timeContainer = createElement("div", "flatpickr-time");
                self.timeContainer.tabIndex = -1;
                var separator = createElement("span", "flatpickr-time-separator", ":");
                var hourInput = createNumberInput("flatpickr-hour", {
                    "aria-label": self.l10n.hourAriaLabel
                });
                self.hourElement = hourInput.getElementsByTagName("input")[0];
                var minuteInput = createNumberInput("flatpickr-minute", {
                    "aria-label": self.l10n.minuteAriaLabel
                });
                self.minuteElement = minuteInput.getElementsByTagName("input")[0];
                self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
                self.hourElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.time_24hr ? defaults.hours : military2ampm(defaults.hours));
                self.minuteElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : defaults.minutes);
                self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
                self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
                self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
                self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
                self.hourElement.setAttribute("maxlength", "2");
                self.minuteElement.setAttribute("min", "0");
                self.minuteElement.setAttribute("max", "59");
                self.minuteElement.setAttribute("maxlength", "2");
                self.timeContainer.appendChild(hourInput);
                self.timeContainer.appendChild(separator);
                self.timeContainer.appendChild(minuteInput);
                if (self.config.time_24hr) self.timeContainer.classList.add("time24hr");
                if (self.config.enableSeconds) {
                    self.timeContainer.classList.add("hasSeconds");
                    var secondInput = createNumberInput("flatpickr-second");
                    self.secondElement = secondInput.getElementsByTagName("input")[0];
                    self.secondElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : defaults.seconds);
                    self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
                    self.secondElement.setAttribute("min", "0");
                    self.secondElement.setAttribute("max", "59");
                    self.secondElement.setAttribute("maxlength", "2");
                    self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
                    self.timeContainer.appendChild(secondInput);
                }
                if (!self.config.time_24hr) {
                    self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[utils_int((self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11)]);
                    self.amPM.title = self.l10n.toggleTitle;
                    self.amPM.tabIndex = -1;
                    self.timeContainer.appendChild(self.amPM);
                }
                return self.timeContainer;
            }
            function buildWeekdays() {
                if (!self.weekdayContainer) self.weekdayContainer = createElement("div", "flatpickr-weekdays"); else clearNode(self.weekdayContainer);
                for (var i = self.config.showMonths; i--; ) {
                    var container = createElement("div", "flatpickr-weekdaycontainer");
                    self.weekdayContainer.appendChild(container);
                }
                updateWeekdays();
                return self.weekdayContainer;
            }
            function updateWeekdays() {
                if (!self.weekdayContainer) return;
                var firstDayOfWeek = self.l10n.firstDayOfWeek;
                var weekdays = esm_spreadArrays(self.l10n.weekdays.shorthand);
                if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) weekdays = esm_spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
                for (var i = self.config.showMonths; i--; ) self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
            }
            function buildWeeks() {
                self.calendarContainer.classList.add("hasWeeks");
                var weekWrapper = createElement("div", "flatpickr-weekwrapper");
                weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
                var weekNumbers = createElement("div", "flatpickr-weeks");
                weekWrapper.appendChild(weekNumbers);
                return {
                    weekWrapper,
                    weekNumbers
                };
            }
            function changeMonth(value, isOffset) {
                if (void 0 === isOffset) isOffset = true;
                var delta = isOffset ? value : value - self.currentMonth;
                if (delta < 0 && true === self._hidePrevMonthArrow || delta > 0 && true === self._hideNextMonthArrow) return;
                self.currentMonth += delta;
                if (self.currentMonth < 0 || self.currentMonth > 11) {
                    self.currentYear += self.currentMonth > 11 ? 1 : -1;
                    self.currentMonth = (self.currentMonth + 12) % 12;
                    triggerEvent("onYearChange");
                    buildMonthSwitch();
                }
                buildDays();
                triggerEvent("onMonthChange");
                updateNavigationCurrentMonth();
            }
            function clear(triggerChangeEvent, toInitial) {
                if (void 0 === triggerChangeEvent) triggerChangeEvent = true;
                if (void 0 === toInitial) toInitial = true;
                self.input.value = "";
                if (void 0 !== self.altInput) self.altInput.value = "";
                if (void 0 !== self.mobileInput) self.mobileInput.value = "";
                self.selectedDates = [];
                self.latestSelectedDateObj = void 0;
                if (true === toInitial) {
                    self.currentYear = self._initialDate.getFullYear();
                    self.currentMonth = self._initialDate.getMonth();
                }
                if (true === self.config.enableTime) {
                    var _a = getDefaultHours(self.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
                    setHours(hours, minutes, seconds);
                }
                self.redraw();
                if (triggerChangeEvent) triggerEvent("onChange");
            }
            function close() {
                self.isOpen = false;
                if (!self.isMobile) {
                    if (void 0 !== self.calendarContainer) self.calendarContainer.classList.remove("open");
                    if (void 0 !== self._input) self._input.classList.remove("active");
                }
                triggerEvent("onClose");
            }
            function destroy() {
                if (void 0 !== self.config) triggerEvent("onDestroy");
                for (var i = self._handlers.length; i--; ) self._handlers[i].remove();
                self._handlers = [];
                if (self.mobileInput) {
                    if (self.mobileInput.parentNode) self.mobileInput.parentNode.removeChild(self.mobileInput);
                    self.mobileInput = void 0;
                } else if (self.calendarContainer && self.calendarContainer.parentNode) if (self.config.static && self.calendarContainer.parentNode) {
                    var wrapper = self.calendarContainer.parentNode;
                    wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
                    if (wrapper.parentNode) {
                        while (wrapper.firstChild) wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                        wrapper.parentNode.removeChild(wrapper);
                    }
                } else self.calendarContainer.parentNode.removeChild(self.calendarContainer);
                if (self.altInput) {
                    self.input.type = "text";
                    if (self.altInput.parentNode) self.altInput.parentNode.removeChild(self.altInput);
                    delete self.altInput;
                }
                if (self.input) {
                    self.input.type = self.input._type;
                    self.input.classList.remove("flatpickr-input");
                    self.input.removeAttribute("readonly");
                }
                [ "_showTimeInput", "latestSelectedDateObj", "_hideNextMonthArrow", "_hidePrevMonthArrow", "__hideNextMonthArrow", "__hidePrevMonthArrow", "isMobile", "isOpen", "selectedDateElem", "minDateHasTime", "maxDateHasTime", "days", "daysContainer", "_input", "_positionElement", "innerContainer", "rContainer", "monthNav", "todayDateElem", "calendarContainer", "weekdayContainer", "prevMonthNav", "nextMonthNav", "monthsDropdownContainer", "currentMonthElement", "currentYearElement", "navigationCurrentMonth", "selectedDateElem", "config" ].forEach((function(k) {
                    try {
                        delete self[k];
                    } catch (_) {}
                }));
            }
            function isCalendarElem(elem) {
                return self.calendarContainer.contains(elem);
            }
            function documentClick(e) {
                if (self.isOpen && !self.config.inline) {
                    var eventTarget_1 = getEventTarget(e);
                    var isCalendarElement = isCalendarElem(eventTarget_1);
                    var isInput = eventTarget_1 === self.input || eventTarget_1 === self.altInput || self.element.contains(eventTarget_1) || e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));
                    var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
                    var isIgnored = !self.config.ignoredFocusElements.some((function(elem) {
                        return elem.contains(eventTarget_1);
                    }));
                    if (lostFocus && isIgnored) {
                        if (self.config.allowInput) self.setDate(self._input.value, false, self.config.altInput ? self.config.altFormat : self.config.dateFormat);
                        if (void 0 !== self.timeContainer && void 0 !== self.minuteElement && void 0 !== self.hourElement && "" !== self.input.value && void 0 !== self.input.value) updateTime();
                        self.close();
                        if (self.config && "range" === self.config.mode && 1 === self.selectedDates.length) self.clear(false);
                    }
                }
            }
            function changeYear(newYear) {
                if (!newYear || self.config.minDate && newYear < self.config.minDate.getFullYear() || self.config.maxDate && newYear > self.config.maxDate.getFullYear()) return;
                var newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
                self.currentYear = newYearNum || self.currentYear;
                if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth); else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
                if (isNewYear) {
                    self.redraw();
                    triggerEvent("onYearChange");
                    buildMonthSwitch();
                }
            }
            function isEnabled(date, timeless) {
                var _a;
                if (void 0 === timeless) timeless = true;
                var dateToCheck = self.parseDate(date, void 0, timeless);
                if (self.config.minDate && dateToCheck && compareDates(dateToCheck, self.config.minDate, void 0 !== timeless ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && dateToCheck && compareDates(dateToCheck, self.config.maxDate, void 0 !== timeless ? timeless : !self.maxDateHasTime) > 0) return false;
                if (!self.config.enable && 0 === self.config.disable.length) return true;
                if (void 0 === dateToCheck) return false;
                var bool = !!self.config.enable, array = null !== (_a = self.config.enable) && void 0 !== _a ? _a : self.config.disable;
                for (var i = 0, d = void 0; i < array.length; i++) {
                    d = array[i];
                    if ("function" === typeof d && d(dateToCheck)) return bool; else if (d instanceof Date && void 0 !== dateToCheck && d.getTime() === dateToCheck.getTime()) return bool; else if ("string" === typeof d) {
                        var parsed = self.parseDate(d, void 0, true);
                        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
                    } else if ("object" === typeof d && void 0 !== dateToCheck && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime()) return bool;
                }
                return !bool;
            }
            function isInView(elem) {
                if (void 0 !== self.daysContainer) return -1 === elem.className.indexOf("hidden") && -1 === elem.className.indexOf("flatpickr-disabled") && self.daysContainer.contains(elem);
                return false;
            }
            function onBlur(e) {
                var isInput = e.target === self._input;
                if (isInput && (self.selectedDates.length > 0 || self._input.value.length > 0) && !(e.relatedTarget && isCalendarElem(e.relatedTarget))) self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
            }
            function onKeyDown(e) {
                var eventTarget = getEventTarget(e);
                var isInput = self.config.wrap ? element.contains(eventTarget) : eventTarget === self._input;
                var allowInput = self.config.allowInput;
                var allowKeydown = self.isOpen && (!allowInput || !isInput);
                var allowInlineKeydown = self.config.inline && isInput && !allowInput;
                if (13 === e.keyCode && isInput) if (allowInput) {
                    self.setDate(self._input.value, true, eventTarget === self.altInput ? self.config.altFormat : self.config.dateFormat);
                    self.close();
                    return eventTarget.blur();
                } else self.open(); else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
                    var isTimeObj = !!self.timeContainer && self.timeContainer.contains(eventTarget);
                    switch (e.keyCode) {
                      case 13:
                        if (isTimeObj) {
                            e.preventDefault();
                            updateTime();
                            focusAndClose();
                        } else selectDate(e);
                        break;

                      case 27:
                        e.preventDefault();
                        focusAndClose();
                        break;

                      case 8:
                      case 46:
                        if (isInput && !self.config.allowInput) {
                            e.preventDefault();
                            self.clear();
                        }
                        break;

                      case 37:
                      case 39:
                        if (!isTimeObj && !isInput) {
                            e.preventDefault();
                            var activeElement = getClosestActiveElement();
                            if (void 0 !== self.daysContainer && (false === allowInput || activeElement && isInView(activeElement))) {
                                var delta_1 = 39 === e.keyCode ? 1 : -1;
                                if (!e.ctrlKey) focusOnDay(void 0, delta_1); else {
                                    e.stopPropagation();
                                    changeMonth(delta_1);
                                    focusOnDay(getFirstAvailableDay(1), 0);
                                }
                            }
                        } else if (self.hourElement) self.hourElement.focus();
                        break;

                      case 38:
                      case 40:
                        e.preventDefault();
                        var delta = 40 === e.keyCode ? 1 : -1;
                        if (self.daysContainer && void 0 !== eventTarget.$i || eventTarget === self.input || eventTarget === self.altInput) {
                            if (e.ctrlKey) {
                                e.stopPropagation();
                                changeYear(self.currentYear - delta);
                                focusOnDay(getFirstAvailableDay(1), 0);
                            } else if (!isTimeObj) focusOnDay(void 0, 7 * delta);
                        } else if (eventTarget === self.currentYearElement) changeYear(self.currentYear - delta); else if (self.config.enableTime) {
                            if (!isTimeObj && self.hourElement) self.hourElement.focus();
                            updateTime(e);
                            self._debouncedChange();
                        }
                        break;

                      case 9:
                        if (isTimeObj) {
                            var elems = [ self.hourElement, self.minuteElement, self.secondElement, self.amPM ].concat(self.pluginElements).filter((function(x) {
                                return x;
                            }));
                            var i = elems.indexOf(eventTarget);
                            if (-1 !== i) {
                                var target = elems[i + (e.shiftKey ? -1 : 1)];
                                e.preventDefault();
                                (target || self._input).focus();
                            }
                        } else if (!self.config.noCalendar && self.daysContainer && self.daysContainer.contains(eventTarget) && e.shiftKey) {
                            e.preventDefault();
                            self._input.focus();
                        }
                        break;

                      default:
                        break;
                    }
                }
                if (void 0 !== self.amPM && eventTarget === self.amPM) switch (e.key) {
                  case self.l10n.amPM[0].charAt(0):
                  case self.l10n.amPM[0].charAt(0).toLowerCase():
                    self.amPM.textContent = self.l10n.amPM[0];
                    setHoursFromInputs();
                    updateValue();
                    break;

                  case self.l10n.amPM[1].charAt(0):
                  case self.l10n.amPM[1].charAt(0).toLowerCase():
                    self.amPM.textContent = self.l10n.amPM[1];
                    setHoursFromInputs();
                    updateValue();
                    break;
                }
                if (isInput || isCalendarElem(eventTarget)) triggerEvent("onKeyDown", e);
            }
            function onMouseOver(elem, cellClass) {
                if (void 0 === cellClass) cellClass = "flatpickr-day";
                if (1 !== self.selectedDates.length || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled"))) return;
                var hoverDate = elem ? elem.dateObj.getTime() : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
                var containsDisabled = false;
                var minRange = 0, maxRange = 0;
                for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) if (!isEnabled(new Date(t), true)) {
                    containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
                    if (t < initialDate && (!minRange || t > minRange)) minRange = t; else if (t > initialDate && (!maxRange || t < maxRange)) maxRange = t;
                }
                var hoverableCells = Array.from(self.rContainer.querySelectorAll("*:nth-child(-n+" + self.config.showMonths + ") > ." + cellClass));
                hoverableCells.forEach((function(dayElem) {
                    var date = dayElem.dateObj;
                    var timestamp = date.getTime();
                    var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
                    if (outOfRange) {
                        dayElem.classList.add("notAllowed");
                        [ "inRange", "startRange", "endRange" ].forEach((function(c) {
                            dayElem.classList.remove(c);
                        }));
                        return;
                    } else if (containsDisabled && !outOfRange) return;
                    [ "startRange", "inRange", "endRange", "notAllowed" ].forEach((function(c) {
                        dayElem.classList.remove(c);
                    }));
                    if (void 0 !== elem) {
                        elem.classList.add(hoverDate <= self.selectedDates[0].getTime() ? "startRange" : "endRange");
                        if (initialDate < hoverDate && timestamp === initialDate) dayElem.classList.add("startRange"); else if (initialDate > hoverDate && timestamp === initialDate) dayElem.classList.add("endRange");
                        if (timestamp >= minRange && (0 === maxRange || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate)) dayElem.classList.add("inRange");
                    }
                }));
            }
            function onResize() {
                if (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();
            }
            function open(e, positionElement) {
                if (void 0 === positionElement) positionElement = self._positionElement;
                if (true === self.isMobile) {
                    if (e) {
                        e.preventDefault();
                        var eventTarget = getEventTarget(e);
                        if (eventTarget) eventTarget.blur();
                    }
                    if (void 0 !== self.mobileInput) {
                        self.mobileInput.focus();
                        self.mobileInput.click();
                    }
                    triggerEvent("onOpen");
                    return;
                } else if (self._input.disabled || self.config.inline) return;
                var wasOpen = self.isOpen;
                self.isOpen = true;
                if (!wasOpen) {
                    self.calendarContainer.classList.add("open");
                    self._input.classList.add("active");
                    triggerEvent("onOpen");
                    positionCalendar(positionElement);
                }
                if (true === self.config.enableTime && true === self.config.noCalendar) if (false === self.config.allowInput && (void 0 === e || !self.timeContainer.contains(e.relatedTarget))) setTimeout((function() {
                    return self.hourElement.select();
                }), 50);
            }
            function minMaxDateSetter(type) {
                return function(date) {
                    var dateObj = self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat);
                    var inverseDateObj = self.config["_" + ("min" === type ? "max" : "min") + "Date"];
                    if (void 0 !== dateObj) self["min" === type ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
                    if (self.selectedDates) {
                        self.selectedDates = self.selectedDates.filter((function(d) {
                            return isEnabled(d);
                        }));
                        if (!self.selectedDates.length && "min" === type) setHoursFromDate(dateObj);
                        updateValue();
                    }
                    if (self.daysContainer) {
                        redraw();
                        if (void 0 !== dateObj) self.currentYearElement[type] = dateObj.getFullYear().toString(); else self.currentYearElement.removeAttribute(type);
                        self.currentYearElement.disabled = !!inverseDateObj && void 0 !== dateObj && inverseDateObj.getFullYear() === dateObj.getFullYear();
                    }
                };
            }
            function parseConfig() {
                var boolOpts = [ "wrap", "weekNumbers", "allowInput", "allowInvalidPreload", "clickOpens", "time_24hr", "enableTime", "noCalendar", "altInput", "shorthandCurrentMonth", "inline", "static", "enableSeconds", "disableMobile" ];
                var userConfig = esm_assign(esm_assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
                var formats = {};
                self.config.parseDate = userConfig.parseDate;
                self.config.formatDate = userConfig.formatDate;
                Object.defineProperty(self.config, "enable", {
                    get: function() {
                        return self.config._enable;
                    },
                    set: function(dates) {
                        self.config._enable = parseDateRules(dates);
                    }
                });
                Object.defineProperty(self.config, "disable", {
                    get: function() {
                        return self.config._disable;
                    },
                    set: function(dates) {
                        self.config._disable = parseDateRules(dates);
                    }
                });
                var timeMode = "time" === userConfig.mode;
                if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
                    var defaultDateFormat = esm_flatpickr.defaultConfig.dateFormat || options_defaults.dateFormat;
                    formats.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
                }
                if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
                    var defaultAltFormat = esm_flatpickr.defaultConfig.altFormat || options_defaults.altFormat;
                    formats.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + " h:i" + (userConfig.enableSeconds ? ":S" : "") + " K";
                }
                Object.defineProperty(self.config, "minDate", {
                    get: function() {
                        return self.config._minDate;
                    },
                    set: minMaxDateSetter("min")
                });
                Object.defineProperty(self.config, "maxDate", {
                    get: function() {
                        return self.config._maxDate;
                    },
                    set: minMaxDateSetter("max")
                });
                var minMaxTimeSetter = function(type) {
                    return function(val) {
                        self.config["min" === type ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i:S");
                    };
                };
                Object.defineProperty(self.config, "minTime", {
                    get: function() {
                        return self.config._minTime;
                    },
                    set: minMaxTimeSetter("min")
                });
                Object.defineProperty(self.config, "maxTime", {
                    get: function() {
                        return self.config._maxTime;
                    },
                    set: minMaxTimeSetter("max")
                });
                if ("time" === userConfig.mode) {
                    self.config.noCalendar = true;
                    self.config.enableTime = true;
                }
                Object.assign(self.config, formats, userConfig);
                for (var i = 0; i < boolOpts.length; i++) self.config[boolOpts[i]] = true === self.config[boolOpts[i]] || "true" === self.config[boolOpts[i]];
                HOOKS.filter((function(hook) {
                    return void 0 !== self.config[hook];
                })).forEach((function(hook) {
                    self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
                }));
                self.isMobile = !self.config.disableMobile && !self.config.inline && "single" === self.config.mode && !self.config.disable.length && !self.config.enable && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                for (i = 0; i < self.config.plugins.length; i++) {
                    var pluginConf = self.config.plugins[i](self) || {};
                    for (var key in pluginConf) if (HOOKS.indexOf(key) > -1) self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]); else if ("undefined" === typeof userConfig[key]) self.config[key] = pluginConf[key];
                }
                if (!userConfig.altInputClass) self.config.altInputClass = getInputElem().className + " " + self.config.altInputClass;
                triggerEvent("onParseConfig");
            }
            function getInputElem() {
                return self.config.wrap ? element.querySelector("[data-input]") : element;
            }
            function setupLocale() {
                if ("object" !== typeof self.config.locale && "undefined" === typeof esm_flatpickr.l10ns[self.config.locale]) self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
                self.l10n = esm_assign(esm_assign({}, esm_flatpickr.l10ns.default), "object" === typeof self.config.locale ? self.config.locale : "default" !== self.config.locale ? esm_flatpickr.l10ns[self.config.locale] : void 0);
                tokenRegex.D = "(" + self.l10n.weekdays.shorthand.join("|") + ")";
                tokenRegex.l = "(" + self.l10n.weekdays.longhand.join("|") + ")";
                tokenRegex.M = "(" + self.l10n.months.shorthand.join("|") + ")";
                tokenRegex.F = "(" + self.l10n.months.longhand.join("|") + ")";
                tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
                var userConfig = esm_assign(esm_assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
                if (void 0 === userConfig.time_24hr && void 0 === esm_flatpickr.defaultConfig.time_24hr) self.config.time_24hr = self.l10n.time_24hr;
                self.formatDate = createDateFormatter(self);
                self.parseDate = createDateParser({
                    config: self.config,
                    l10n: self.l10n
                });
            }
            function positionCalendar(customPositionElement) {
                if ("function" === typeof self.config.position) return void self.config.position(self, customPositionElement);
                if (void 0 === self.calendarContainer) return;
                triggerEvent("onPreCalendarPosition");
                var positionElement = customPositionElement || self._positionElement;
                var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, (function(acc, child) {
                    return acc + child.offsetHeight;
                }), 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = "above" === configPosVertical || "below" !== configPosVertical && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
                var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
                dom_toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
                dom_toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
                if (self.config.inline) return;
                var left = window.pageXOffset + inputBounds.left;
                var isCenter = false;
                var isRight = false;
                if ("center" === configPosHorizontal) {
                    left -= (calendarWidth - inputBounds.width) / 2;
                    isCenter = true;
                } else if ("right" === configPosHorizontal) {
                    left -= calendarWidth - inputBounds.width;
                    isRight = true;
                }
                dom_toggleClass(self.calendarContainer, "arrowLeft", !isCenter && !isRight);
                dom_toggleClass(self.calendarContainer, "arrowCenter", isCenter);
                dom_toggleClass(self.calendarContainer, "arrowRight", isRight);
                var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
                var rightMost = left + calendarWidth > window.document.body.offsetWidth;
                var centerMost = right + calendarWidth > window.document.body.offsetWidth;
                dom_toggleClass(self.calendarContainer, "rightMost", rightMost);
                if (self.config.static) return;
                self.calendarContainer.style.top = top + "px";
                if (!rightMost) {
                    self.calendarContainer.style.left = left + "px";
                    self.calendarContainer.style.right = "auto";
                } else if (!centerMost) {
                    self.calendarContainer.style.left = "auto";
                    self.calendarContainer.style.right = right + "px";
                } else {
                    var doc = getDocumentStyleSheet();
                    if (void 0 === doc) return;
                    var bodyWidth = window.document.body.offsetWidth;
                    var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
                    var centerBefore = ".flatpickr-calendar.centerMost:before";
                    var centerAfter = ".flatpickr-calendar.centerMost:after";
                    var centerIndex = doc.cssRules.length;
                    var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
                    dom_toggleClass(self.calendarContainer, "rightMost", false);
                    dom_toggleClass(self.calendarContainer, "centerMost", true);
                    doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
                    self.calendarContainer.style.left = centerLeft + "px";
                    self.calendarContainer.style.right = "auto";
                }
            }
            function getDocumentStyleSheet() {
                var editableSheet = null;
                for (var i = 0; i < document.styleSheets.length; i++) {
                    var sheet = document.styleSheets[i];
                    if (!sheet.cssRules) continue;
                    try {
                        sheet.cssRules;
                    } catch (err) {
                        continue;
                    }
                    editableSheet = sheet;
                    break;
                }
                return null != editableSheet ? editableSheet : createStyleSheet();
            }
            function createStyleSheet() {
                var style = document.createElement("style");
                document.head.appendChild(style);
                return style.sheet;
            }
            function redraw() {
                if (self.config.noCalendar || self.isMobile) return;
                buildMonthSwitch();
                updateNavigationCurrentMonth();
                buildDays();
            }
            function focusAndClose() {
                self._input.focus();
                if (-1 !== window.navigator.userAgent.indexOf("MSIE") || void 0 !== navigator.msMaxTouchPoints) setTimeout(self.close, 0); else self.close();
            }
            function selectDate(e) {
                e.preventDefault();
                e.stopPropagation();
                var isSelectable = function(day) {
                    return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
                };
                var t = findParent(getEventTarget(e), isSelectable);
                if (void 0 === t) return;
                var target = t;
                var selectedDate = self.latestSelectedDateObj = new Date(target.dateObj.getTime());
                var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth || selectedDate.getMonth() > self.currentMonth + self.config.showMonths - 1) && "range" !== self.config.mode;
                self.selectedDateElem = target;
                if ("single" === self.config.mode) self.selectedDates = [ selectedDate ]; else if ("multiple" === self.config.mode) {
                    var selectedIndex = isDateSelected(selectedDate);
                    if (selectedIndex) self.selectedDates.splice(parseInt(selectedIndex), 1); else self.selectedDates.push(selectedDate);
                } else if ("range" === self.config.mode) {
                    if (2 === self.selectedDates.length) self.clear(false, false);
                    self.latestSelectedDateObj = selectedDate;
                    self.selectedDates.push(selectedDate);
                    if (0 !== compareDates(selectedDate, self.selectedDates[0], true)) self.selectedDates.sort((function(a, b) {
                        return a.getTime() - b.getTime();
                    }));
                }
                setHoursFromInputs();
                if (shouldChangeMonth) {
                    var isNewYear = self.currentYear !== selectedDate.getFullYear();
                    self.currentYear = selectedDate.getFullYear();
                    self.currentMonth = selectedDate.getMonth();
                    if (isNewYear) {
                        triggerEvent("onYearChange");
                        buildMonthSwitch();
                    }
                    triggerEvent("onMonthChange");
                }
                updateNavigationCurrentMonth();
                buildDays();
                updateValue();
                if (!shouldChangeMonth && "range" !== self.config.mode && 1 === self.config.showMonths) focusOnDayElem(target); else if (void 0 !== self.selectedDateElem && void 0 === self.hourElement) self.selectedDateElem && self.selectedDateElem.focus();
                if (void 0 !== self.hourElement) void 0 !== self.hourElement && self.hourElement.focus();
                if (self.config.closeOnSelect) {
                    var single = "single" === self.config.mode && !self.config.enableTime;
                    var range = "range" === self.config.mode && 2 === self.selectedDates.length && !self.config.enableTime;
                    if (single || range) focusAndClose();
                }
                triggerChange();
            }
            var CALLBACKS = {
                locale: [ setupLocale, updateWeekdays ],
                showMonths: [ buildMonths, setCalendarWidth, buildWeekdays ],
                minDate: [ jumpToDate ],
                maxDate: [ jumpToDate ],
                positionElement: [ updatePositionElement ],
                clickOpens: [ function() {
                    if (true === self.config.clickOpens) {
                        bind(self._input, "focus", self.open);
                        bind(self._input, "click", self.open);
                    } else {
                        self._input.removeEventListener("focus", self.open);
                        self._input.removeEventListener("click", self.open);
                    }
                } ]
            };
            function set(option, value) {
                if (null !== option && "object" === typeof option) {
                    Object.assign(self.config, option);
                    for (var key in option) if (void 0 !== CALLBACKS[key]) CALLBACKS[key].forEach((function(x) {
                        return x();
                    }));
                } else {
                    self.config[option] = value;
                    if (void 0 !== CALLBACKS[option]) CALLBACKS[option].forEach((function(x) {
                        return x();
                    })); else if (HOOKS.indexOf(option) > -1) self.config[option] = arrayify(value);
                }
                self.redraw();
                updateValue(true);
            }
            function setSelectedDate(inputDate, format) {
                var dates = [];
                if (inputDate instanceof Array) dates = inputDate.map((function(d) {
                    return self.parseDate(d, format);
                })); else if (inputDate instanceof Date || "number" === typeof inputDate) dates = [ self.parseDate(inputDate, format) ]; else if ("string" === typeof inputDate) switch (self.config.mode) {
                  case "single":
                  case "time":
                    dates = [ self.parseDate(inputDate, format) ];
                    break;

                  case "multiple":
                    dates = inputDate.split(self.config.conjunction).map((function(date) {
                        return self.parseDate(date, format);
                    }));
                    break;

                  case "range":
                    dates = inputDate.split(self.l10n.rangeSeparator).map((function(date) {
                        return self.parseDate(date, format);
                    }));
                    break;

                  default:
                    break;
                } else self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
                self.selectedDates = self.config.allowInvalidPreload ? dates : dates.filter((function(d) {
                    return d instanceof Date && isEnabled(d, false);
                }));
                if ("range" === self.config.mode) self.selectedDates.sort((function(a, b) {
                    return a.getTime() - b.getTime();
                }));
            }
            function setDate(date, triggerChange, format) {
                if (void 0 === triggerChange) triggerChange = false;
                if (void 0 === format) format = self.config.dateFormat;
                if (0 !== date && !date || date instanceof Array && 0 === date.length) return self.clear(triggerChange);
                setSelectedDate(date, format);
                self.latestSelectedDateObj = self.selectedDates[self.selectedDates.length - 1];
                self.redraw();
                jumpToDate(void 0, triggerChange);
                setHoursFromDate();
                if (0 === self.selectedDates.length) self.clear(false);
                updateValue(triggerChange);
                if (triggerChange) triggerEvent("onChange");
            }
            function parseDateRules(arr) {
                return arr.slice().map((function(rule) {
                    if ("string" === typeof rule || "number" === typeof rule || rule instanceof Date) return self.parseDate(rule, void 0, true); else if (rule && "object" === typeof rule && rule.from && rule.to) return {
                        from: self.parseDate(rule.from, void 0),
                        to: self.parseDate(rule.to, void 0)
                    };
                    return rule;
                })).filter((function(x) {
                    return x;
                }));
            }
            function setupDates() {
                self.selectedDates = [];
                self.now = self.parseDate(self.config.now) || new Date;
                var preloadedDate = self.config.defaultDate || (("INPUT" === self.input.nodeName || "TEXTAREA" === self.input.nodeName) && self.input.placeholder && self.input.value === self.input.placeholder ? null : self.input.value);
                if (preloadedDate) setSelectedDate(preloadedDate, self.config.dateFormat);
                self._initialDate = self.selectedDates.length > 0 ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now.getTime() ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now.getTime() ? self.config.maxDate : self.now;
                self.currentYear = self._initialDate.getFullYear();
                self.currentMonth = self._initialDate.getMonth();
                if (self.selectedDates.length > 0) self.latestSelectedDateObj = self.selectedDates[0];
                if (void 0 !== self.config.minTime) self.config.minTime = self.parseDate(self.config.minTime, "H:i");
                if (void 0 !== self.config.maxTime) self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
                self.minDateHasTime = !!self.config.minDate && (self.config.minDate.getHours() > 0 || self.config.minDate.getMinutes() > 0 || self.config.minDate.getSeconds() > 0);
                self.maxDateHasTime = !!self.config.maxDate && (self.config.maxDate.getHours() > 0 || self.config.maxDate.getMinutes() > 0 || self.config.maxDate.getSeconds() > 0);
            }
            function setupInputs() {
                self.input = getInputElem();
                if (!self.input) {
                    self.config.errorHandler(new Error("Invalid input element specified"));
                    return;
                }
                self.input._type = self.input.type;
                self.input.type = "text";
                self.input.classList.add("flatpickr-input");
                self._input = self.input;
                if (self.config.altInput) {
                    self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
                    self._input = self.altInput;
                    self.altInput.placeholder = self.input.placeholder;
                    self.altInput.disabled = self.input.disabled;
                    self.altInput.required = self.input.required;
                    self.altInput.tabIndex = self.input.tabIndex;
                    self.altInput.type = "text";
                    self.input.setAttribute("type", "hidden");
                    if (!self.config.static && self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
                }
                if (!self.config.allowInput) self._input.setAttribute("readonly", "readonly");
                updatePositionElement();
            }
            function updatePositionElement() {
                self._positionElement = self.config.positionElement || self._input;
            }
            function setupMobile() {
                var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";
                self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
                self.mobileInput.tabIndex = 1;
                self.mobileInput.type = inputType;
                self.mobileInput.disabled = self.input.disabled;
                self.mobileInput.required = self.input.required;
                self.mobileInput.placeholder = self.input.placeholder;
                self.mobileFormatStr = "datetime-local" === inputType ? "Y-m-d\\TH:i:S" : "date" === inputType ? "Y-m-d" : "H:i:S";
                if (self.selectedDates.length > 0) self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
                if (self.config.minDate) self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
                if (self.config.maxDate) self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
                if (self.input.getAttribute("step")) self.mobileInput.step = String(self.input.getAttribute("step"));
                self.input.type = "hidden";
                if (void 0 !== self.altInput) self.altInput.type = "hidden";
                try {
                    if (self.input.parentNode) self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
                } catch (_a) {}
                bind(self.mobileInput, "change", (function(e) {
                    self.setDate(getEventTarget(e).value, false, self.mobileFormatStr);
                    triggerEvent("onChange");
                    triggerEvent("onClose");
                }));
            }
            function toggle(e) {
                if (true === self.isOpen) return self.close();
                self.open(e);
            }
            function triggerEvent(event, data) {
                if (void 0 === self.config) return;
                var hooks = self.config[event];
                if (void 0 !== hooks && hooks.length > 0) for (var i = 0; hooks[i] && i < hooks.length; i++) hooks[i](self.selectedDates, self.input.value, self, data);
                if ("onChange" === event) {
                    self.input.dispatchEvent(createEvent("change"));
                    self.input.dispatchEvent(createEvent("input"));
                }
            }
            function createEvent(name) {
                var e = document.createEvent("Event");
                e.initEvent(name, true, true);
                return e;
            }
            function isDateSelected(date) {
                for (var i = 0; i < self.selectedDates.length; i++) {
                    var selectedDate = self.selectedDates[i];
                    if (selectedDate instanceof Date && 0 === compareDates(selectedDate, date)) return "" + i;
                }
                return false;
            }
            function isDateInRange(date) {
                if ("range" !== self.config.mode || self.selectedDates.length < 2) return false;
                return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
            }
            function updateNavigationCurrentMonth() {
                if (self.config.noCalendar || self.isMobile || !self.monthNav) return;
                self.yearElements.forEach((function(yearElement, i) {
                    var d = new Date(self.currentYear, self.currentMonth, 1);
                    d.setMonth(self.currentMonth + i);
                    if (self.config.showMonths > 1 || "static" === self.config.monthSelectorType) self.monthElements[i].textContent = monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " "; else self.monthsDropdownContainer.value = d.getMonth().toString();
                    yearElement.value = d.getFullYear().toString();
                }));
                self._hidePrevMonthArrow = void 0 !== self.config.minDate && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());
                self._hideNextMonthArrow = void 0 !== self.config.maxDate && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
            }
            function getDateStr(format) {
                return self.selectedDates.map((function(dObj) {
                    return self.formatDate(dObj, format);
                })).filter((function(d, i, arr) {
                    return "range" !== self.config.mode || self.config.enableTime || arr.indexOf(d) === i;
                })).join("range" !== self.config.mode ? self.config.conjunction : self.l10n.rangeSeparator);
            }
            function updateValue(triggerChange) {
                if (void 0 === triggerChange) triggerChange = true;
                if (void 0 !== self.mobileInput && self.mobileFormatStr) self.mobileInput.value = void 0 !== self.latestSelectedDateObj ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
                self.input.value = getDateStr(self.config.dateFormat);
                if (void 0 !== self.altInput) self.altInput.value = getDateStr(self.config.altFormat);
                if (false !== triggerChange) triggerEvent("onValueUpdate");
            }
            function onMonthNavClick(e) {
                var eventTarget = getEventTarget(e);
                var isPrevMonth = self.prevMonthNav.contains(eventTarget);
                var isNextMonth = self.nextMonthNav.contains(eventTarget);
                if (isPrevMonth || isNextMonth) changeMonth(isPrevMonth ? -1 : 1); else if (self.yearElements.indexOf(eventTarget) >= 0) eventTarget.select(); else if (eventTarget.classList.contains("arrowUp")) self.changeYear(self.currentYear + 1); else if (eventTarget.classList.contains("arrowDown")) self.changeYear(self.currentYear - 1);
            }
            function timeWrapper(e) {
                e.preventDefault();
                var isKeyDown = "keydown" === e.type, eventTarget = getEventTarget(e), input = eventTarget;
                if (void 0 !== self.amPM && eventTarget === self.amPM) self.amPM.textContent = self.l10n.amPM[utils_int(self.amPM.textContent === self.l10n.amPM[0])];
                var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta || (isKeyDown ? 38 === e.which ? 1 : -1 : 0);
                var newValue = curValue + step * delta;
                if ("undefined" !== typeof input.value && 2 === input.value.length) {
                    var isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
                    if (newValue < min) {
                        newValue = max + newValue + utils_int(!isHourElem) + (utils_int(isHourElem) && utils_int(!self.amPM));
                        if (isMinuteElem) incrementNumInput(void 0, -1, self.hourElement);
                    } else if (newValue > max) {
                        newValue = input === self.hourElement ? newValue - max - utils_int(!self.amPM) : min;
                        if (isMinuteElem) incrementNumInput(void 0, 1, self.hourElement);
                    }
                    if (self.amPM && isHourElem && (1 === step ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) self.amPM.textContent = self.l10n.amPM[utils_int(self.amPM.textContent === self.l10n.amPM[0])];
                    input.value = pad(newValue);
                }
            }
            init();
            return self;
        }
        function _flatpickr(nodeList, config) {
            var nodes = Array.prototype.slice.call(nodeList).filter((function(x) {
                return x instanceof HTMLElement;
            }));
            var instances = [];
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                try {
                    if (null !== node.getAttribute("data-fp-omit")) continue;
                    if (void 0 !== node._flatpickr) {
                        node._flatpickr.destroy();
                        node._flatpickr = void 0;
                    }
                    node._flatpickr = FlatpickrInstance(node, config || {});
                    instances.push(node._flatpickr);
                } catch (e) {
                    console.error(e);
                }
            }
            return 1 === instances.length ? instances[0] : instances;
        }
        if ("undefined" !== typeof HTMLElement && "undefined" !== typeof HTMLCollection && "undefined" !== typeof NodeList) {
            HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config) {
                return _flatpickr(this, config);
            };
            HTMLElement.prototype.flatpickr = function(config) {
                return _flatpickr([ this ], config);
            };
        }
        var esm_flatpickr = function(selector, config) {
            if ("string" === typeof selector) return _flatpickr(window.document.querySelectorAll(selector), config); else if (selector instanceof Node) return _flatpickr([ selector ], config); else return _flatpickr(selector, config);
        };
        esm_flatpickr.defaultConfig = {};
        esm_flatpickr.l10ns = {
            en: esm_assign({}, l10n_default),
            default: esm_assign({}, l10n_default)
        };
        esm_flatpickr.localize = function(l10n) {
            esm_flatpickr.l10ns.default = esm_assign(esm_assign({}, esm_flatpickr.l10ns.default), l10n);
        };
        esm_flatpickr.setDefaults = function(config) {
            esm_flatpickr.defaultConfig = esm_assign(esm_assign({}, esm_flatpickr.defaultConfig), config);
        };
        esm_flatpickr.parseDate = createDateParser({});
        esm_flatpickr.formatDate = createDateFormatter({});
        esm_flatpickr.compareDates = compareDates;
        if ("undefined" !== typeof jQuery && "undefined" !== typeof jQuery.fn) jQuery.fn.flatpickr = function(config) {
            return _flatpickr(this, config);
        };
        Date.prototype.fp_incr = function(days) {
            return new Date(this.getFullYear(), this.getMonth(), this.getDate() + ("string" === typeof days ? parseInt(days, 10) : days));
        };
        if ("undefined" !== typeof window) window.flatpickr = esm_flatpickr;
        __webpack_require__(8809);
        __webpack_require__(3550);
        var lib = __webpack_require__(9429);
        var dashboard_lib = __webpack_require__(3121);
        var tus_lib = __webpack_require__(5753);
        var ru_RU = __webpack_require__(4811);
        document.addEventListener("DOMContentLoaded", (() => {
            const uppy = new lib({
                locale: ru_RU
            });
            uppy.use(dashboard_lib, {
                target: ".UppyDragDrop",
                inline: true,
                width: 1600
            });
            uppy.use(tus_lib, {
                endpoint: "https://tusd.tusdemo.net/files/"
            });
        }));
        class index_esm_t extends Date {
            static parseDateTime(e, s = "YYYY-MM-DD", n = "en-US") {
                if (!e) return new Date((new Date).setHours(0, 0, 0, 0));
                if (e instanceof index_esm_t) return e.toJSDate();
                if (e instanceof Date) return e;
                if (/^-?\d{10,}$/.test(String(e))) return new Date(Number(e));
                if ("string" == typeof e) {
                    const r = [];
                    let a = null;
                    for (;null != (a = index_esm_t.regex.exec(s)); ) "\\" !== a[1] && r.push(a);
                    if (r.length) {
                        const s = {
                            year: null,
                            month: null,
                            shortMonth: null,
                            longMonth: null,
                            day: null,
                            hour: 0,
                            minute: 0,
                            second: 0,
                            ampm: null,
                            value: ""
                        };
                        r[0].index > 0 && (s.value += ".*?");
                        for (const [e, a] of Object.entries(r)) {
                            const r = Number(e), {group: i, pattern: h} = index_esm_t.formatPatterns(a[0], n);
                            s[i] = r + 1, s.value += h, s.value += ".*?";
                        }
                        const a = new RegExp(`^${s.value}$`);
                        if (a.test(e)) {
                            const r = a.exec(e), i = Number(r[s.year]);
                            let h = null;
                            s.month ? h = Number(r[s.month]) - 1 : s.shortMonth ? h = index_esm_t.shortMonths(n).indexOf(r[s.shortMonth]) : s.longMonth && (h = index_esm_t.longMonths(n).indexOf(r[s.longMonth]));
                            const g = Number(r[s.day]) || 1, o = Number(r[s.hour]);
                            let u = Number.isNaN(o) ? 0 : o;
                            const c = Number(r[s.minute]), l = Number.isNaN(c) ? 0 : c, m = Number(r[s.second]), d = Number.isNaN(m) ? 0 : m, M = r[s.ampm];
                            return M && "PM" === M && (u += 12, 24 === u && (u = 0)), new Date(i, h, g, u, l, d, 0);
                        }
                    }
                }
                return new Date((new Date).setHours(0, 0, 0, 0));
            }
            static regex=/(\\)?(Y{2,4}|M{1,4}|D{1,2}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|A|a)/g;
            static MONTH_JS=[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];
            static shortMonths(e) {
                return index_esm_t.MONTH_JS.map((t => new Date(2019, t).toLocaleString(e, {
                    month: "short"
                })));
            }
            static longMonths(e) {
                return index_esm_t.MONTH_JS.map((t => new Date(2019, t).toLocaleString(e, {
                    month: "long"
                })));
            }
            static formatPatterns(e, s) {
                switch (e) {
                  case "YY":
                  case "YYYY":
                    return {
                        group: "year",
                        pattern: `(\\d{${e.length}})`
                    };

                  case "M":
                    return {
                        group: "month",
                        pattern: "(\\d{1,2})"
                    };

                  case "MM":
                    return {
                        group: "month",
                        pattern: "(\\d{2})"
                    };

                  case "MMM":
                    return {
                        group: "shortMonth",
                        pattern: `(${index_esm_t.shortMonths(s).join("|")})`
                    };

                  case "MMMM":
                    return {
                        group: "longMonth",
                        pattern: `(${index_esm_t.longMonths(s).join("|")})`
                    };

                  case "D":
                    return {
                        group: "day",
                        pattern: "(\\d{1,2})"
                    };

                  case "DD":
                    return {
                        group: "day",
                        pattern: "(\\d{2})"
                    };

                  case "h":
                  case "H":
                    return {
                        group: "hour",
                        pattern: "(\\d{1,2})"
                    };

                  case "hh":
                  case "HH":
                    return {
                        group: "hour",
                        pattern: "(\\d{2})"
                    };

                  case "m":
                    return {
                        group: "minute",
                        pattern: "(\\d{1,2})"
                    };

                  case "mm":
                    return {
                        group: "minute",
                        pattern: "(\\d{2})"
                    };

                  case "s":
                    return {
                        group: "second",
                        pattern: "(\\d{1,2})"
                    };

                  case "ss":
                    return {
                        group: "second",
                        pattern: "(\\d{2})"
                    };

                  case "a":
                  case "A":
                    return {
                        group: "ampm",
                        pattern: "(AM|PM|am|pm)"
                    };
                }
            }
            lang;
            constructor(e = null, s = "YYYY-MM-DD", n = "en-US") {
                super(index_esm_t.parseDateTime(e, s, n)), this.lang = n;
            }
            getWeek(t) {
                const e = new Date(this.midnight_ts(this)), s = (this.getDay() + (7 - t)) % 7;
                e.setDate(e.getDate() - s);
                const n = e.getTime();
                return e.setMonth(0, 1), e.getDay() !== t && e.setMonth(0, 1 + (4 - e.getDay() + 7) % 7), 
                1 + Math.ceil((n - e.getTime()) / 6048e5);
            }
            clone() {
                return new index_esm_t(this);
            }
            toJSDate() {
                return new Date(this);
            }
            inArray(t, e = "[]") {
                return t.some((t => t instanceof Array ? this.isBetween(t[0], t[1], e) : this.isSame(t, "day")));
            }
            isBetween(t, e, s = "()") {
                switch (s) {
                  default:
                  case "()":
                    return this.midnight_ts(this) > this.midnight_ts(t) && this.midnight_ts(this) < this.midnight_ts(e);

                  case "[)":
                    return this.midnight_ts(this) >= this.midnight_ts(t) && this.midnight_ts(this) < this.midnight_ts(e);

                  case "(]":
                    return this.midnight_ts(this) > this.midnight_ts(t) && this.midnight_ts(this) <= this.midnight_ts(e);

                  case "[]":
                    return this.midnight_ts() >= this.midnight_ts(t) && this.midnight_ts() <= this.midnight_ts(e);
                }
            }
            isBefore(t, e = "days") {
                switch (e) {
                  case "day":
                  case "days":
                    return new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime() > new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime();

                  case "month":
                  case "months":
                    return new Date(t.getFullYear(), t.getMonth(), 1).getTime() > new Date(this.getFullYear(), this.getMonth(), 1).getTime();

                  case "year":
                  case "years":
                    return t.getFullYear() > this.getFullYear();
                }
                throw new Error("isBefore: Invalid unit!");
            }
            isSameOrBefore(t, e = "days") {
                switch (e) {
                  case "day":
                  case "days":
                    return new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime() >= new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime();

                  case "month":
                  case "months":
                    return new Date(t.getFullYear(), t.getMonth(), 1).getTime() >= new Date(this.getFullYear(), this.getMonth(), 1).getTime();
                }
                throw new Error("isSameOrBefore: Invalid unit!");
            }
            isAfter(t, e = "days") {
                switch (e) {
                  case "day":
                  case "days":
                    return new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime() > new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime();

                  case "month":
                  case "months":
                    return new Date(this.getFullYear(), this.getMonth(), 1).getTime() > new Date(t.getFullYear(), t.getMonth(), 1).getTime();

                  case "year":
                  case "years":
                    return this.getFullYear() > t.getFullYear();
                }
                throw new Error("isAfter: Invalid unit!");
            }
            isSameOrAfter(t, e = "days") {
                switch (e) {
                  case "day":
                  case "days":
                    return new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime() >= new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime();

                  case "month":
                  case "months":
                    return new Date(this.getFullYear(), this.getMonth(), 1).getTime() >= new Date(t.getFullYear(), t.getMonth(), 1).getTime();
                }
                throw new Error("isSameOrAfter: Invalid unit!");
            }
            isSame(t, e = "days") {
                switch (e) {
                  case "day":
                  case "days":
                    return new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime() === new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime();

                  case "month":
                  case "months":
                    return new Date(this.getFullYear(), this.getMonth(), 1).getTime() === new Date(t.getFullYear(), t.getMonth(), 1).getTime();
                }
                throw new Error("isSame: Invalid unit!");
            }
            add(t, e = "days") {
                switch (e) {
                  case "day":
                  case "days":
                    this.setDate(this.getDate() + t);
                    break;

                  case "month":
                  case "months":
                    this.setMonth(this.getMonth() + t);
                }
                return this;
            }
            subtract(t, e = "days") {
                switch (e) {
                  case "day":
                  case "days":
                    this.setDate(this.getDate() - t);
                    break;

                  case "month":
                  case "months":
                    this.setMonth(this.getMonth() - t);
                }
                return this;
            }
            diff(t, e = "days") {
                switch (e) {
                  default:
                  case "day":
                  case "days":
                    return Math.round((this.midnight_ts() - this.midnight_ts(t)) / 864e5);

                  case "month":
                  case "months":
                    let e = 12 * (t.getFullYear() - this.getFullYear());
                    return e -= t.getMonth(), e += this.getMonth(), e;
                }
            }
            format(e, s = "en-US") {
                let n = "";
                const r = [];
                let a = null;
                for (;null != (a = index_esm_t.regex.exec(e)); ) "\\" !== a[1] && r.push(a);
                if (r.length) {
                    r[0].index > 0 && (n += e.substring(0, r[0].index));
                    for (const [t, a] of Object.entries(r)) {
                        const i = Number(t);
                        n += this.formatTokens(a[0], s), r[i + 1] && (n += e.substring(a.index + a[0].length, r[i + 1].index)), 
                        i === r.length - 1 && (n += e.substring(a.index + a[0].length));
                    }
                }
                return n.replace(/\\/g, "");
            }
            midnight_ts(t) {
                return t ? new Date(t.getFullYear(), t.getMonth(), t.getDate(), 0, 0, 0, 0).getTime() : new Date(this.getFullYear(), this.getMonth(), this.getDate(), 0, 0, 0, 0).getTime();
            }
            formatTokens(e, s) {
                switch (e) {
                  case "YY":
                    return String(this.getFullYear()).slice(-2);

                  case "YYYY":
                    return String(this.getFullYear());

                  case "M":
                    return String(this.getMonth() + 1);

                  case "MM":
                    return `0${this.getMonth() + 1}`.slice(-2);

                  case "MMM":
                    return index_esm_t.shortMonths(s)[this.getMonth()];

                  case "MMMM":
                    return index_esm_t.longMonths(s)[this.getMonth()];

                  case "D":
                    return String(this.getDate());

                  case "DD":
                    return `0${this.getDate()}`.slice(-2);

                  case "H":
                    return String(this.getHours());

                  case "HH":
                    return `0${this.getHours()}`.slice(-2);

                  case "h":
                    return String(this.getHours() % 12 || 12);

                  case "hh":
                    return `0${this.getHours() % 12 || 12}`.slice(-2);

                  case "m":
                    return String(this.getMinutes());

                  case "mm":
                    return `0${this.getMinutes()}`.slice(-2);

                  case "s":
                    return String(this.getSeconds());

                  case "ss":
                    return `0${this.getSeconds()}`.slice(-2);

                  case "a":
                    return this.getHours() < 12 || 24 === this.getHours() ? "am" : "pm";

                  case "A":
                    return this.getHours() < 12 || 24 === this.getHours() ? "AM" : "PM";

                  default:
                    return "";
                }
            }
        }
        class t {
            picker;
            constructor(e) {
                this.picker = e;
            }
            render(t, i) {
                t || (t = new index_esm_t), t.setDate(1), t.setHours(0, 0, 0, 0), "function" == typeof this[`get${i}View`] && this[`get${i}View`](t);
            }
            getContainerView(e) {
                this.picker.ui.container.innerHTML = "", this.picker.options.header && this.picker.trigger("render", {
                    date: e.clone(),
                    view: "Header"
                }), this.picker.trigger("render", {
                    date: e.clone(),
                    view: "Main"
                }), this.picker.options.autoApply || this.picker.trigger("render", {
                    date: e.clone(),
                    view: "Footer"
                });
            }
            getHeaderView(e) {
                const t = document.createElement("header");
                this.picker.options.header instanceof HTMLElement && t.appendChild(this.picker.options.header), 
                "string" == typeof this.picker.options.header && (t.innerHTML = this.picker.options.header), 
                this.picker.ui.container.appendChild(t), this.picker.trigger("view", {
                    target: t,
                    date: e.clone(),
                    view: "Header"
                });
            }
            getMainView(e) {
                const t = document.createElement("main");
                this.picker.ui.container.appendChild(t);
                const i = document.createElement("div");
                i.className = `calendars grid-${this.picker.options.grid}`;
                for (let t = 0; t < this.picker.options.calendars; t++) {
                    const n = document.createElement("div");
                    n.className = "calendar", i.appendChild(n);
                    const s = this.getCalendarHeaderView(e.clone());
                    n.appendChild(s), this.picker.trigger("view", {
                        date: e.clone(),
                        view: "CalendarHeader",
                        index: t,
                        target: s
                    });
                    const a = this.getCalendarDayNamesView();
                    n.appendChild(a), this.picker.trigger("view", {
                        date: e.clone(),
                        view: "CalendarDayNames",
                        index: t,
                        target: a
                    });
                    const o = this.getCalendarDaysView(e.clone());
                    n.appendChild(o), this.picker.trigger("view", {
                        date: e.clone(),
                        view: "CalendarDays",
                        index: t,
                        target: o
                    });
                    const r = this.getCalendarFooterView(this.picker.options.lang, e.clone());
                    n.appendChild(r), this.picker.trigger("view", {
                        date: e.clone(),
                        view: "CalendarFooter",
                        index: t,
                        target: r
                    }), this.picker.trigger("view", {
                        date: e.clone(),
                        view: "CalendarItem",
                        index: t,
                        target: n
                    }), e.add(1, "month");
                }
                t.appendChild(i), this.picker.trigger("view", {
                    date: e.clone(),
                    view: "Calendars",
                    target: i
                }), this.picker.trigger("view", {
                    date: e.clone(),
                    view: "Main",
                    target: t
                });
            }
            getFooterView(e) {
                const t = document.createElement("footer"), i = document.createElement("div");
                i.className = "footer-buttons";
                const n = document.createElement("button");
                n.className = "cancel-button unit", n.innerHTML = this.picker.options.locale.cancel, 
                i.appendChild(n);
                const s = document.createElement("button");
                s.className = "apply-button unit", s.innerHTML = this.picker.options.locale.apply, 
                s.disabled = !0, i.appendChild(s), t.appendChild(i), this.picker.ui.container.appendChild(t), 
                this.picker.trigger("view", {
                    date: e,
                    target: t,
                    view: "Footer"
                });
            }
            getCalendarHeaderView(e) {
                const t = document.createElement("div");
                t.className = "header";
                const i = document.createElement("div");
                i.className = "month-name", i.innerHTML = `<span>${e.toLocaleString(this.picker.options.lang, {
                    month: "long"
                })}</span> ${e.format("YYYY")}`, t.appendChild(i);
                const n = document.createElement("button");
                n.className = "previous-button unit", n.innerHTML = this.picker.options.locale.previousMonth, 
                t.appendChild(n);
                const s = document.createElement("button");
                return s.className = "next-button unit", s.innerHTML = this.picker.options.locale.nextMonth, 
                t.appendChild(s), t;
            }
            getCalendarDayNamesView() {
                const e = document.createElement("div");
                e.className = "daynames-row";
                for (let t = 1; t <= 7; t++) {
                    const i = 3 + this.picker.options.firstDay + t, n = document.createElement("div");
                    n.className = "dayname", n.innerHTML = new Date(1970, 0, i, 12, 0, 0, 0).toLocaleString(this.picker.options.lang, {
                        weekday: "short"
                    }), n.title = new Date(1970, 0, i, 12, 0, 0, 0).toLocaleString(this.picker.options.lang, {
                        weekday: "long"
                    }), e.appendChild(n), this.picker.trigger("view", {
                        dayIdx: i,
                        view: "CalendarDayName",
                        target: n
                    });
                }
                return e;
            }
            getCalendarDaysView(e) {
                const t = document.createElement("div");
                t.className = "days-grid";
                const i = this.calcOffsetDays(e, this.picker.options.firstDay), n = 32 - new Date(e.getFullYear(), e.getMonth(), 32).getDate();
                for (let e = 0; e < i; e++) {
                    const e = document.createElement("div");
                    e.className = "offset", t.appendChild(e);
                }
                for (let i = 1; i <= n; i++) {
                    e.setDate(i);
                    const n = this.getCalendarDayView(e);
                    t.appendChild(n), this.picker.trigger("view", {
                        date: e,
                        view: "CalendarDay",
                        target: n
                    });
                }
                return t;
            }
            getCalendarDayView(t) {
                const i = this.picker.options.date ? new index_esm_t(this.picker.options.date) : null, n = new index_esm_t, s = document.createElement("div");
                return s.className = "day unit", s.innerHTML = t.format("D"), s.dataset.time = String(t.getTime()), 
                t.isSame(n, "day") && s.classList.add("today"), [ 0, 6 ].includes(t.getDay()) && s.classList.add("weekend"), 
                this.picker.datePicked.length ? this.picker.datePicked[0].isSame(t, "day") && s.classList.add("selected") : i && t.isSame(i, "day") && s.classList.add("selected"), 
                this.picker.trigger("view", {
                    date: t,
                    view: "CalendarDay",
                    target: s
                }), s;
            }
            getCalendarFooterView(e, t) {
                const i = document.createElement("div");
                return i.className = "footer", i;
            }
            calcOffsetDays(e, t) {
                let i = e.getDay() - t;
                return i < 0 && (i += 7), i;
            }
        }
        class i {
            picker;
            instances={};
            constructor(e) {
                this.picker = e;
            }
            initialize() {
                const e = [];
                this.picker.options.plugins.forEach((t => {
                    "function" == typeof t ? e.push(new t) : "string" == typeof t && "undefined" != typeof easepick && Object.prototype.hasOwnProperty.call(easepick, t) ? e.push(new easepick[t]) : console.warn(`easepick: ${t} not found.`);
                })), e.sort(((e, t) => e.priority > t.priority ? -1 : e.priority < t.priority || e.dependencies.length > t.dependencies.length ? 1 : e.dependencies.length < t.dependencies.length ? -1 : 0)), 
                e.forEach((e => {
                    e.attach(this.picker), this.instances[e.getName()] = e;
                }));
            }
            getInstance(e) {
                return this.instances[e];
            }
            addInstance(e) {
                if (Object.prototype.hasOwnProperty.call(this.instances, e)) console.warn(`easepick: ${e} already added.`); else {
                    if ("undefined" != typeof easepick && Object.prototype.hasOwnProperty.call(easepick, e)) {
                        const t = new easepick[e];
                        return t.attach(this.picker), this.instances[t.getName()] = t, t;
                    }
                    if ("undefined" !== this.getPluginFn(e)) {
                        const t = new (this.getPluginFn(e));
                        return t.attach(this.picker), this.instances[t.getName()] = t, t;
                    }
                    console.warn(`easepick: ${e} not found.`);
                }
                return null;
            }
            removeInstance(e) {
                return e in this.instances && this.instances[e].detach(), delete this.instances[e];
            }
            reloadInstance(e) {
                return this.removeInstance(e), this.addInstance(e);
            }
            getPluginFn(e) {
                return [ ...this.picker.options.plugins ].filter((t => "function" == typeof t && (new t).getName() === e)).shift();
            }
        }
        class n {
            Calendar=new t(this);
            PluginManager=new i(this);
            calendars=[];
            datePicked=[];
            cssLoaded=0;
            binds={
                hidePicker: this.hidePicker.bind(this),
                show: this.show.bind(this)
            };
            options={
                doc: document,
                css: [],
                element: null,
                firstDay: 1,
                grid: 1,
                calendars: 1,
                lang: "en-US",
                date: null,
                format: "YYYY-MM-DD",
                readonly: !0,
                autoApply: !0,
                header: !1,
                inline: !1,
                locale: {
                    nextMonth: '<svg width="11" height="16" xmlns="http://www.w3.org/2000/svg"><path d="M2.748 16L0 13.333 5.333 8 0 2.667 2.748 0l7.919 8z" fill-rule="nonzero"/></svg>',
                    previousMonth: '<svg width="11" height="16" xmlns="http://www.w3.org/2000/svg"><path d="M7.919 0l2.748 2.667L5.333 8l5.334 5.333L7.919 16 0 8z" fill-rule="nonzero"/></svg>',
                    cancel: "Cancel",
                    apply: "Apply"
                },
                documentClick: this.binds.hidePicker,
                plugins: []
            };
            ui={
                container: null,
                shadowRoot: null,
                wrapper: null
            };
            version="1.1.7";
            constructor(e) {
                const t = {
                    ...this.options.locale,
                    ...e.locale
                };
                this.options = {
                    ...this.options,
                    ...e
                }, this.options.locale = t, this.handleOptions(), this.ui.wrapper = document.createElement("span"), 
                this.ui.wrapper.style.display = "none", this.ui.wrapper.style.position = "absolute", 
                this.ui.wrapper.style.pointerEvents = "none", this.ui.wrapper.className = "easepick-wrapper", 
                this.ui.wrapper.attachShadow({
                    mode: "open"
                }), this.ui.shadowRoot = this.ui.wrapper.shadowRoot, this.ui.container = document.createElement("div"), 
                this.ui.container.className = "container", this.options.zIndex && (this.ui.container.style.zIndex = String(this.options.zIndex)), 
                this.options.inline && (this.ui.wrapper.style.position = "relative", this.ui.container.classList.add("inline")), 
                this.ui.shadowRoot.appendChild(this.ui.container), this.options.element.after(this.ui.wrapper), 
                this.handleCSS(), this.options.element.addEventListener("click", this.binds.show), 
                this.on("view", this.onView.bind(this)), this.on("render", this.onRender.bind(this)), 
                this.PluginManager.initialize(), this.parseValues(), "function" == typeof this.options.setup && this.options.setup(this), 
                this.on("click", this.onClick.bind(this)), this.renderAll();
            }
            on(e, t, i = {}) {
                this.ui.container.addEventListener(e, t, i);
            }
            off(e, t, i = {}) {
                this.ui.container.removeEventListener(e, t, i);
            }
            trigger(e, t = {}) {
                return this.ui.container.dispatchEvent(new CustomEvent(e, {
                    detail: t
                }));
            }
            destroy() {
                this.options.element.removeEventListener("click", this.binds.show), "function" == typeof this.options.documentClick && document.removeEventListener("click", this.options.documentClick, !0), 
                Object.keys(this.PluginManager.instances).forEach((e => {
                    this.PluginManager.removeInstance(e);
                })), this.ui.wrapper.remove();
            }
            onRender(e) {
                const {view: t, date: i} = e.detail;
                this.Calendar.render(i, t);
            }
            onView(e) {
                const {view: t, target: i} = e.detail;
                if ("Footer" === t && this.datePicked.length) i.querySelector(".apply-button").disabled = !1;
            }
            onClickHeaderButton(e) {
                this.isCalendarHeaderButton(e) && (e.classList.contains("next-button") ? this.calendars[0].add(1, "month") : this.calendars[0].subtract(1, "month"), 
                this.renderAll(this.calendars[0]));
            }
            onClickCalendarDay(t) {
                if (this.isCalendarDay(t)) {
                    const i = new index_esm_t(t.dataset.time);
                    this.options.autoApply ? (this.setDate(i), this.trigger("select", {
                        date: this.getDate()
                    }), this.hide()) : (this.datePicked[0] = i, this.trigger("preselect", {
                        date: this.getDate()
                    }), this.renderAll());
                }
            }
            onClickApplyButton(e) {
                if (this.isApplyButton(e)) {
                    if (this.datePicked[0] instanceof Date) {
                        const e = this.datePicked[0].clone();
                        this.setDate(e);
                    }
                    this.hide(), this.trigger("select", {
                        date: this.getDate()
                    });
                }
            }
            onClickCancelButton(e) {
                this.isCancelButton(e) && this.hide();
            }
            onClick(e) {
                const t = e.target;
                if (t instanceof HTMLElement) {
                    const e = t.closest(".unit");
                    if (!(e instanceof HTMLElement)) return;
                    this.onClickHeaderButton(e), this.onClickCalendarDay(e), this.onClickApplyButton(e), 
                    this.onClickCancelButton(e);
                }
            }
            isShown() {
                return this.ui.container.classList.contains("inline") || this.ui.container.classList.contains("show");
            }
            show(e) {
                if (this.isShown()) return;
                const t = e && "target" in e ? e.target : this.options.element, {top: i, left: n} = this.adjustPosition(t);
                this.ui.container.style.top = `${i}px`, this.ui.container.style.left = `${n}px`, 
                this.ui.container.classList.add("show"), this.trigger("show", {
                    target: t
                });
            }
            hide() {
                this.ui.container.classList.remove("show"), this.datePicked.length = 0, this.renderAll(), 
                this.trigger("hide");
            }
            setDate(t) {
                const i = new index_esm_t(t, this.options.format);
                this.options.date = i.clone(), this.updateValues(), this.calendars.length && this.renderAll();
            }
            getDate() {
                return this.options.date instanceof index_esm_t ? this.options.date.clone() : null;
            }
            parseValues() {
                this.options.date ? this.setDate(this.options.date) : this.options.element instanceof HTMLInputElement && this.options.element.value.length && this.setDate(this.options.element.value), 
                this.options.date instanceof Date || (this.options.date = null);
            }
            updateValues() {
                const e = this.getDate(), t = e instanceof Date ? e.format(this.options.format, this.options.lang) : "", i = this.options.element;
                i instanceof HTMLInputElement ? i.value = t : i instanceof HTMLElement && (i.innerText = t);
            }
            hidePicker(e) {
                let t = e.target, i = null;
                t.shadowRoot && (t = e.composedPath()[0], i = t.getRootNode().host), this.isShown() && i !== this.ui.wrapper && t !== this.options.element && this.hide();
            }
            renderAll(e) {
                this.trigger("render", {
                    view: "Container",
                    date: (e || this.calendars[0]).clone()
                });
            }
            isCalendarHeaderButton(e) {
                return [ "previous-button", "next-button" ].some((t => e.classList.contains(t)));
            }
            isCalendarDay(e) {
                return e.classList.contains("day");
            }
            isApplyButton(e) {
                return e.classList.contains("apply-button");
            }
            isCancelButton(e) {
                return e.classList.contains("cancel-button");
            }
            gotoDate(t) {
                const i = new index_esm_t(t, this.options.format);
                i.setDate(1), this.calendars[0] = i.clone(), this.renderAll();
            }
            clear() {
                this.options.date = null, this.datePicked.length = 0, this.updateValues(), this.renderAll();
            }
            handleOptions() {
                this.options.element instanceof HTMLElement || (this.options.element = this.options.doc.querySelector(this.options.element)), 
                "function" == typeof this.options.documentClick && document.addEventListener("click", this.options.documentClick, !0), 
                this.options.element instanceof HTMLInputElement && (this.options.element.readOnly = this.options.readonly), 
                this.options.date ? this.calendars[0] = new index_esm_t(this.options.date, this.options.format) : this.calendars[0] = new index_esm_t;
            }
            handleCSS() {
                if (Array.isArray(this.options.css)) this.options.css.forEach((e => {
                    const t = document.createElement("link");
                    t.href = e, t.rel = "stylesheet";
                    const i = () => {
                        this.cssLoaded++, this.cssLoaded === this.options.css.length && (this.ui.wrapper.style.display = "");
                    };
                    t.addEventListener("load", i), t.addEventListener("error", i), this.ui.shadowRoot.append(t);
                })); else if ("string" == typeof this.options.css) {
                    const e = document.createElement("style"), t = document.createTextNode(this.options.css);
                    e.appendChild(t), this.ui.shadowRoot.append(e), this.ui.wrapper.style.display = "";
                } else "function" == typeof this.options.css && (this.options.css.call(this, this), 
                this.ui.wrapper.style.display = "");
            }
            adjustPosition(e) {
                const t = e.getBoundingClientRect(), i = this.ui.wrapper.getBoundingClientRect();
                this.ui.container.classList.add("calc");
                const n = this.ui.container.getBoundingClientRect();
                this.ui.container.classList.remove("calc");
                let s = t.bottom - i.bottom, a = t.left - i.left;
                return "undefined" != typeof window && (window.innerHeight < s + n.height && s - n.height >= 0 && (s = t.top - i.top - n.height), 
                window.innerWidth < a + n.width && t.right - n.width >= 0 && (a = t.right - i.right - n.width)), 
                {
                    left: a,
                    top: s
                };
            }
        }
        var s = Object.freeze({
            __proto__: null,
            Core: n,
            create: n
        });
        class e {
            picker;
            options;
            priority=0;
            dependencies=[];
            attach(e) {
                const t = this.getName(), s = {
                    ...this.options
                };
                this.options = {
                    ...this.options,
                    ...e.options[t] || {}
                };
                for (const i of Object.keys(s)) if (null !== s[i] && "object" == typeof s[i] && Object.keys(s[i]).length && t in e.options && i in e.options[t]) {
                    const n = {
                        ...e.options[t][i]
                    };
                    null !== n && "object" == typeof n && Object.keys(n).length && Object.keys(n).every((e => Object.keys(s[i]).includes(e))) && (this.options[i] = {
                        ...s[i],
                        ...n
                    });
                }
                if (this.picker = e, this.dependenciesNotFound()) {
                    const e = this.dependencies.filter((e => !this.pluginsAsStringArray().includes(e)));
                    return void console.warn(`${this.getName()}: required dependencies (${e.join(", ")}).`);
                }
                const i = this.camelCaseToKebab(this.getName());
                this.picker.ui.container.classList.add(i), this.onAttach();
            }
            detach() {
                const e = this.camelCaseToKebab(this.getName());
                this.picker.ui.container.classList.remove(e), "function" == typeof this.onDetach && this.onDetach();
            }
            dependenciesNotFound() {
                return this.dependencies.length && !this.dependencies.every((e => this.pluginsAsStringArray().includes(e)));
            }
            pluginsAsStringArray() {
                return this.picker.options.plugins.map((e => "function" == typeof e ? (new e).getName() : e));
            }
            camelCaseToKebab(e) {
                return e.replace(/([a-zA-Z])(?=[A-Z])/g, "$1-").toLowerCase();
            }
        }
        class index_esm_i extends e {
            tooltipElement;
            triggerElement;
            binds={
                setStartDate: this.setStartDate.bind(this),
                setEndDate: this.setEndDate.bind(this),
                setDateRange: this.setDateRange.bind(this),
                getStartDate: this.getStartDate.bind(this),
                getEndDate: this.getEndDate.bind(this),
                onView: this.onView.bind(this),
                onShow: this.onShow.bind(this),
                onMouseEnter: this.onMouseEnter.bind(this),
                onMouseLeave: this.onMouseLeave.bind(this),
                onClickCalendarDay: this.onClickCalendarDay.bind(this),
                onClickApplyButton: this.onClickApplyButton.bind(this),
                parseValues: this.parseValues.bind(this),
                updateValues: this.updateValues.bind(this),
                clear: this.clear.bind(this)
            };
            options={
                elementEnd: null,
                startDate: null,
                endDate: null,
                repick: !1,
                strict: !0,
                delimiter: " - ",
                tooltip: !0,
                tooltipNumber: t => t,
                locale: {
                    zero: "",
                    one: "day",
                    two: "",
                    few: "",
                    many: "",
                    other: "days"
                },
                documentClick: this.hidePicker.bind(this)
            };
            getName() {
                return "RangePlugin";
            }
            onAttach() {
                this.binds._setStartDate = this.picker.setStartDate, this.binds._setEndDate = this.picker.setEndDate, 
                this.binds._setDateRange = this.picker.setDateRange, this.binds._getStartDate = this.picker.getStartDate, 
                this.binds._getEndDate = this.picker.getEndDate, this.binds._parseValues = this.picker.parseValues, 
                this.binds._updateValues = this.picker.updateValues, this.binds._clear = this.picker.clear, 
                this.binds._onClickCalendarDay = this.picker.onClickCalendarDay, this.binds._onClickApplyButton = this.picker.onClickApplyButton, 
                Object.defineProperties(this.picker, {
                    setStartDate: {
                        configurable: !0,
                        value: this.binds.setStartDate
                    },
                    setEndDate: {
                        configurable: !0,
                        value: this.binds.setEndDate
                    },
                    setDateRange: {
                        configurable: !0,
                        value: this.binds.setDateRange
                    },
                    getStartDate: {
                        configurable: !0,
                        value: this.binds.getStartDate
                    },
                    getEndDate: {
                        configurable: !0,
                        value: this.binds.getEndDate
                    },
                    parseValues: {
                        configurable: !0,
                        value: this.binds.parseValues
                    },
                    updateValues: {
                        configurable: !0,
                        value: this.binds.updateValues
                    },
                    clear: {
                        configurable: !0,
                        value: this.binds.clear
                    },
                    onClickCalendarDay: {
                        configurable: !0,
                        value: this.binds.onClickCalendarDay
                    },
                    onClickApplyButton: {
                        configurable: !0,
                        value: this.binds.onClickApplyButton
                    }
                }), this.options.elementEnd && (this.options.elementEnd instanceof HTMLElement || (this.options.elementEnd = this.picker.options.doc.querySelector(this.options.elementEnd)), 
                this.options.elementEnd instanceof HTMLInputElement && (this.options.elementEnd.readOnly = this.picker.options.readonly), 
                "function" == typeof this.picker.options.documentClick && (document.removeEventListener("click", this.picker.options.documentClick, !0), 
                "function" == typeof this.options.documentClick && document.addEventListener("click", this.options.documentClick, !0)), 
                this.options.elementEnd.addEventListener("click", this.picker.show.bind(this.picker))), 
                this.options.repick = this.options.repick && this.options.elementEnd instanceof HTMLElement, 
                this.picker.options.date = null, this.picker.on("view", this.binds.onView), this.picker.on("show", this.binds.onShow), 
                this.picker.on("mouseenter", this.binds.onMouseEnter, !0), this.picker.on("mouseleave", this.binds.onMouseLeave, !0), 
                this.checkIntlPluralLocales();
            }
            onDetach() {
                Object.defineProperties(this.picker, {
                    setStartDate: {
                        configurable: !0,
                        value: this.binds._setStartDate
                    },
                    setEndDate: {
                        configurable: !0,
                        value: this.binds._setEndDate
                    },
                    setDateRange: {
                        configurable: !0,
                        value: this.binds._setDateRange
                    },
                    getStartDate: {
                        configurable: !0,
                        value: this.binds._getStartDate
                    },
                    getEndDate: {
                        configurable: !0,
                        value: this.binds._getEndDate
                    },
                    parseValues: {
                        configurable: !0,
                        value: this.binds._parseValues
                    },
                    updateValues: {
                        configurable: !0,
                        value: this.binds._updateValues
                    },
                    clear: {
                        configurable: !0,
                        value: this.binds._clear
                    },
                    onClickCalendarDay: {
                        configurable: !0,
                        value: this.binds._onClickCalendarDay
                    },
                    onClickApplyButton: {
                        configurable: !0,
                        value: this.binds._onClickApplyButton
                    }
                }), this.picker.off("view", this.binds.onView), this.picker.off("show", this.binds.onShow), 
                this.picker.off("mouseenter", this.binds.onMouseEnter, !0), this.picker.off("mouseleave", this.binds.onMouseLeave, !0);
            }
            parseValues() {
                if (this.options.startDate || this.options.endDate) this.options.strict ? this.options.startDate && this.options.endDate ? this.setDateRange(this.options.startDate, this.options.endDate) : (this.options.startDate = null, 
                this.options.endDate = null) : (this.options.startDate && this.setStartDate(this.options.startDate), 
                this.options.endDate && this.setEndDate(this.options.endDate)); else if (this.options.elementEnd) this.options.strict ? this.picker.options.element instanceof HTMLInputElement && this.picker.options.element.value.length && this.options.elementEnd instanceof HTMLInputElement && this.options.elementEnd.value.length && this.setDateRange(this.picker.options.element.value, this.options.elementEnd.value) : (this.picker.options.element instanceof HTMLInputElement && this.picker.options.element.value.length && this.setStartDate(this.picker.options.element.value), 
                this.options.elementEnd instanceof HTMLInputElement && this.options.elementEnd.value.length && this.setEndDate(this.options.elementEnd.value)); else if (this.picker.options.element instanceof HTMLInputElement && this.picker.options.element.value.length) {
                    const [t, e] = this.picker.options.element.value.split(this.options.delimiter);
                    this.options.strict ? t && e && this.setDateRange(t, e) : (t && this.setStartDate(t), 
                    e && this.setEndDate(e));
                }
            }
            updateValues() {
                const t = this.picker.options.element, e = this.options.elementEnd, i = this.picker.getStartDate(), s = this.picker.getEndDate(), n = i instanceof Date ? i.format(this.picker.options.format, this.picker.options.lang) : "", a = s instanceof Date ? s.format(this.picker.options.format, this.picker.options.lang) : "";
                if (e) t instanceof HTMLInputElement ? t.value = n : t instanceof HTMLElement && (t.innerText = n), 
                e instanceof HTMLInputElement ? e.value = a : e instanceof HTMLElement && (e.innerText = a); else {
                    const e = `${n}${n || a ? this.options.delimiter : ""}${a}`;
                    t instanceof HTMLInputElement ? t.value = e : t instanceof HTMLElement && (t.innerText = e);
                }
            }
            clear() {
                this.options.startDate = null, this.options.endDate = null, this.picker.datePicked.length = 0, 
                this.updateValues(), this.picker.renderAll();
            }
            onShow(t) {
                const {target: e} = t.detail;
                this.triggerElement = e, this.initializeRepick();
            }
            onView(e) {
                const {view: i, target: s} = e.detail;
                if ("Main" === i && (this.tooltipElement = document.createElement("span"), this.tooltipElement.className = "range-plugin-tooltip", 
                s.appendChild(this.tooltipElement)), "CalendarDay" === i) {
                    const e = new index_esm_t(s.dataset.time), i = this.picker.datePicked, n = i.length ? this.picker.datePicked[0] : this.getStartDate(), a = i.length ? this.picker.datePicked[1] : this.getEndDate();
                    n && n.isSame(e, "day") && s.classList.add("start"), n && a && (a.isSame(e, "day") && s.classList.add("end"), 
                    e.isBetween(n, a) && s.classList.add("in-range"));
                }
                if ("Footer" === i) {
                    const t = 1 === this.picker.datePicked.length && !this.options.strict || 2 === this.picker.datePicked.length;
                    s.querySelector(".apply-button").disabled = !t;
                }
            }
            hidePicker(t) {
                let e = t.target, i = null;
                e.shadowRoot && (e = t.composedPath()[0], i = e.getRootNode().host), this.picker.isShown() && i !== this.picker.ui.wrapper && e !== this.picker.options.element && e !== this.options.elementEnd && this.picker.hide();
            }
            setStartDate(e) {
                const i = new index_esm_t(e, this.picker.options.format);
                this.options.startDate = i ? i.clone() : null, this.updateValues(), this.picker.renderAll();
            }
            setEndDate(e) {
                const i = new index_esm_t(e, this.picker.options.format);
                this.options.endDate = i ? i.clone() : null, this.updateValues(), this.picker.renderAll();
            }
            setDateRange(e, i) {
                const s = new index_esm_t(e, this.picker.options.format), n = new index_esm_t(i, this.picker.options.format);
                this.options.startDate = s ? s.clone() : null, this.options.endDate = n ? n.clone() : null, 
                this.updateValues(), this.picker.renderAll();
            }
            getStartDate() {
                return this.options.startDate instanceof Date ? this.options.startDate.clone() : null;
            }
            getEndDate() {
                return this.options.endDate instanceof Date ? this.options.endDate.clone() : null;
            }
            onMouseEnter(e) {
                const i = e.target;
                if (i instanceof HTMLElement) {
                    this.isContainer(i) && this.initializeRepick();
                    const e = i.closest(".unit");
                    if (!(e instanceof HTMLElement)) return;
                    if (this.picker.isCalendarDay(e)) {
                        if (1 !== this.picker.datePicked.length) return;
                        let i = this.picker.datePicked[0].clone(), s = new index_esm_t(e.dataset.time), n = !1;
                        if (i.isAfter(s, "day")) {
                            const t = i.clone();
                            i = s.clone(), s = t.clone(), n = !0;
                        }
                        if ([ ...this.picker.ui.container.querySelectorAll(".day") ].forEach((a => {
                            const o = new index_esm_t(a.dataset.time), l = this.picker.Calendar.getCalendarDayView(o);
                            o.isBetween(i, s) && l.classList.add("in-range"), o.isSame(this.picker.datePicked[0], "day") && (l.classList.add("start"), 
                            l.classList.toggle("flipped", n)), a === e && (l.classList.add("end"), l.classList.toggle("flipped", n)), 
                            a.className = l.className;
                        })), this.options.tooltip) {
                            const t = this.options.tooltipNumber(s.diff(i, "day") + 1);
                            if (t > 0) {
                                const i = new Intl.PluralRules(this.picker.options.lang).select(t), s = `${t} ${this.options.locale[i]}`;
                                this.showTooltip(e, s);
                            } else this.hideTooltip();
                        }
                    }
                }
            }
            onMouseLeave(t) {
                if (this.isContainer(t.target) && this.options.repick) {
                    const t = this.getStartDate(), e = this.getEndDate();
                    t && e && (this.picker.datePicked.length = 0, this.picker.renderAll());
                }
            }
            onClickCalendarDay(e) {
                if (this.picker.isCalendarDay(e)) {
                    2 === this.picker.datePicked.length && (this.picker.datePicked.length = 0);
                    const i = new index_esm_t(e.dataset.time);
                    if (this.picker.datePicked[this.picker.datePicked.length] = i, 2 === this.picker.datePicked.length && this.picker.datePicked[0].isAfter(this.picker.datePicked[1])) {
                        const t = this.picker.datePicked[1].clone();
                        this.picker.datePicked[1] = this.picker.datePicked[0].clone(), this.picker.datePicked[0] = t.clone();
                    }
                    1 !== this.picker.datePicked.length && this.picker.options.autoApply || this.picker.trigger("preselect", {
                        start: this.picker.datePicked[0] instanceof Date ? this.picker.datePicked[0].clone() : null,
                        end: this.picker.datePicked[1] instanceof Date ? this.picker.datePicked[1].clone() : null
                    }), 1 === this.picker.datePicked.length && (!this.options.strict && this.picker.options.autoApply && (this.picker.options.element === this.triggerElement && this.setStartDate(this.picker.datePicked[0]), 
                    this.options.elementEnd === this.triggerElement && this.setEndDate(this.picker.datePicked[0]), 
                    this.picker.trigger("select", {
                        start: this.picker.getStartDate(),
                        end: this.picker.getEndDate()
                    })), this.picker.renderAll()), 2 === this.picker.datePicked.length && (this.picker.options.autoApply ? (this.setDateRange(this.picker.datePicked[0], this.picker.datePicked[1]), 
                    this.picker.trigger("select", {
                        start: this.picker.getStartDate(),
                        end: this.picker.getEndDate()
                    }), this.picker.hide()) : (this.hideTooltip(), this.picker.renderAll()));
                }
            }
            onClickApplyButton(t) {
                this.picker.isApplyButton(t) && (1 !== this.picker.datePicked.length || this.options.strict || (this.picker.options.element === this.triggerElement && (this.options.endDate = null, 
                this.setStartDate(this.picker.datePicked[0])), this.options.elementEnd === this.triggerElement && (this.options.startDate = null, 
                this.setEndDate(this.picker.datePicked[0]))), 2 === this.picker.datePicked.length && this.setDateRange(this.picker.datePicked[0], this.picker.datePicked[1]), 
                this.picker.trigger("select", {
                    start: this.picker.getStartDate(),
                    end: this.picker.getEndDate()
                }), this.picker.hide());
            }
            showTooltip(t, e) {
                this.tooltipElement.style.visibility = "visible", this.tooltipElement.innerHTML = e;
                const i = this.picker.ui.container.getBoundingClientRect(), s = this.tooltipElement.getBoundingClientRect(), n = t.getBoundingClientRect();
                let a = n.top, o = n.left;
                a -= i.top, o -= i.left, a -= s.height, o -= s.width / 2, o += n.width / 2, this.tooltipElement.style.top = `${a}px`, 
                this.tooltipElement.style.left = `${o}px`;
            }
            hideTooltip() {
                this.tooltipElement.style.visibility = "hidden";
            }
            checkIntlPluralLocales() {
                if (!this.options.tooltip) return;
                const t = [ ...new Set([ new Intl.PluralRules(this.picker.options.lang).select(0), new Intl.PluralRules(this.picker.options.lang).select(1), new Intl.PluralRules(this.picker.options.lang).select(2), new Intl.PluralRules(this.picker.options.lang).select(6), new Intl.PluralRules(this.picker.options.lang).select(18) ]) ], e = Object.keys(this.options.locale);
                t.every((t => e.includes(t))) || console.warn(`${this.getName()}: provide locales (${t.join(", ")}) for correct tooltip text.`);
            }
            initializeRepick() {
                if (!this.options.repick) return;
                const t = this.getStartDate(), e = this.getEndDate();
                e && this.triggerElement === this.picker.options.element && (this.picker.datePicked[0] = e), 
                t && this.triggerElement === this.options.elementEnd && (this.picker.datePicked[0] = t);
            }
            isContainer(t) {
                return t === this.picker.ui.container;
            }
        }
        class index_esm_n extends e {
            rangePlugin;
            lockPlugin;
            priority=10;
            binds={
                onView: this.onView.bind(this),
                onColorScheme: this.onColorScheme.bind(this)
            };
            options={
                dropdown: {
                    months: !1,
                    years: !1,
                    minYear: 1950,
                    maxYear: null
                },
                darkMode: !0,
                locale: {
                    resetButton: '<svg xmlns="http://www.w3.org/2000/svg" height="24" width="24"><path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"/></svg>'
                }
            };
            matchMedia;
            getName() {
                return "AmpPlugin";
            }
            onAttach() {
                this.options.darkMode && window && "matchMedia" in window && (this.matchMedia = window.matchMedia("(prefers-color-scheme: dark)"), 
                this.matchMedia.matches && (this.picker.ui.container.dataset.theme = "dark"), this.matchMedia.addEventListener("change", this.binds.onColorScheme)), 
                this.options.weekNumbers && this.picker.ui.container.classList.add("week-numbers"), 
                this.picker.on("view", this.binds.onView);
            }
            onDetach() {
                this.options.darkMode && window && "matchMedia" in window && this.matchMedia.removeEventListener("change", this.binds.onColorScheme), 
                this.picker.ui.container.removeAttribute("data-theme"), this.picker.ui.container.classList.remove("week-numbers"), 
                this.picker.off("view", this.binds.onView);
            }
            onView(e) {
                this.lockPlugin = this.picker.PluginManager.getInstance("LockPlugin"), this.rangePlugin = this.picker.PluginManager.getInstance("RangePlugin"), 
                this.handleDropdown(e), this.handleResetButton(e), this.handleWeekNumbers(e);
            }
            onColorScheme(e) {
                const t = e.matches ? "dark" : "light";
                this.picker.ui.container.dataset.theme = t;
            }
            handleDropdown(e) {
                const {view: n, target: i, date: o, index: s} = e.detail;
                if ("CalendarHeader" === n) {
                    const e = i.querySelector(".month-name");
                    if (this.options.dropdown.months) {
                        e.childNodes[0].remove();
                        const n = document.createElement("select");
                        n.className = "month-name--select month-name--dropdown";
                        for (let e = 0; e < 12; e += 1) {
                            const i = document.createElement("option"), s = new index_esm_t(new Date(o.getFullYear(), e, 2, 0, 0, 0)), a = new index_esm_t(new Date(o.getFullYear(), e, 1, 0, 0, 0));
                            i.value = String(e), i.text = s.toLocaleString(this.picker.options.lang, {
                                month: "long"
                            }), this.lockPlugin && (i.disabled = this.lockPlugin.options.minDate && a.isBefore(new index_esm_t(this.lockPlugin.options.minDate), "month") || this.lockPlugin.options.maxDate && a.isAfter(new index_esm_t(this.lockPlugin.options.maxDate), "month")), 
                            i.selected = a.getMonth() === o.getMonth(), n.appendChild(i);
                        }
                        n.addEventListener("change", (e => {
                            const t = e.target;
                            this.picker.calendars[0].setDate(1), this.picker.calendars[0].setMonth(Number(t.value)), 
                            this.picker.renderAll();
                        })), e.prepend(n);
                    }
                    if (this.options.dropdown.years) {
                        e.childNodes[1].remove();
                        const n = document.createElement("select");
                        n.className = "month-name--select";
                        const i = this.options.dropdown.minYear, s = this.options.dropdown.maxYear ? this.options.dropdown.maxYear : (new Date).getFullYear();
                        if (o.getFullYear() > s) {
                            const e = document.createElement("option");
                            e.value = String(o.getFullYear()), e.text = String(o.getFullYear()), e.selected = !0, 
                            e.disabled = !0, n.appendChild(e);
                        }
                        for (let e = s; e >= i; e -= 1) {
                            const i = document.createElement("option"), s = new index_esm_t(new Date(e, 0, 1, 0, 0, 0));
                            i.value = String(e), i.text = String(e), this.lockPlugin && (i.disabled = this.lockPlugin.options.minDate && s.isBefore(new index_esm_t(this.lockPlugin.options.minDate), "year") || this.lockPlugin.options.maxDate && s.isAfter(new index_esm_t(this.lockPlugin.options.maxDate), "year")), 
                            i.selected = o.getFullYear() === e, n.appendChild(i);
                        }
                        if (o.getFullYear() < i) {
                            const e = document.createElement("option");
                            e.value = String(o.getFullYear()), e.text = String(o.getFullYear()), e.selected = !0, 
                            e.disabled = !0, n.appendChild(e);
                        }
                        if ("asc" === this.options.dropdown.years) {
                            const e = Array.prototype.slice.call(n.childNodes).reverse();
                            n.innerHTML = "", e.forEach((e => {
                                e.innerHTML = e.value, n.appendChild(e);
                            }));
                        }
                        n.addEventListener("change", (e => {
                            const t = e.target;
                            this.picker.calendars[0].setFullYear(Number(t.value)), this.picker.renderAll();
                        })), e.appendChild(n);
                    }
                }
            }
            handleResetButton(e) {
                const {view: t, target: n} = e.detail;
                if ("CalendarHeader" === t && this.options.resetButton) {
                    const e = document.createElement("button");
                    e.className = "reset-button unit", e.innerHTML = this.options.locale.resetButton, 
                    e.addEventListener("click", (e => {
                        e.preventDefault();
                        let t = !0;
                        "function" == typeof this.options.resetButton && (t = this.options.resetButton.call(this)), 
                        t && this.picker.clear();
                    })), n.appendChild(e);
                }
            }
            handleWeekNumbers(e) {
                if (this.options.weekNumbers) {
                    const {view: n, target: i} = e.detail;
                    if ("CalendarDayNames" === n) {
                        const e = document.createElement("div");
                        e.className = "wnum-header", e.innerHTML = "Wk", i.prepend(e);
                    }
                    "CalendarDays" === n && [ ...i.children ].forEach(((e, n) => {
                        if (0 === n || n % 7 == 0) {
                            let n;
                            if (e.classList.contains("day")) n = new index_esm_t(e.dataset.time); else {
                                const e = i.querySelector(".day");
                                n = new index_esm_t(e.dataset.time);
                            }
                            let o = n.getWeek(this.picker.options.firstDay);
                            53 === o && 0 === n.getMonth() && (o = "53/1");
                            const s = document.createElement("div");
                            s.className = "wnum-item", s.innerHTML = String(o), i.insertBefore(s, e);
                        }
                    }));
                }
            }
        }
        window["FLS"] = true;
        isWebp();
        tabs();
        formQuantity();
        const dates = [ "2022-04-03", "2022-04-07", "2022-04-08", "2022-04-11", "2022-04-15", "2022-04-16", "2022-04-17", "2022-04-21", "2022-04-30" ];
        new s.create({
            element: document.getElementById("datepicker"),
            inline: true,
            lang: "ru-RU",
            format: "DD MMMM YYYY",
            plugins: [ index_esm_i, index_esm_n ],
            grid: 2,
            calendars: 2,
            AmpPlugin: {
                resetButton: true
            },
            RangePlugin: {
                tooltip: true,
                locale: {
                    zero: "день",
                    one: "день",
                    two: "дня",
                    few: "дня",
                    many: "дней",
                    other: "дней"
                }
            },
            css: [ "https://cdn.jsdelivr.net/npm/@easepick/bundle@1.1.7/dist/index.css", "https://easepick.com/assets/css/demo_prices.css" ],
            setup(picker) {
                const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);
                const prices = {};
                dates.forEach((x => {
                    prices[x] = randomInt(50, 200);
                }));
                picker.on("view", (evt => {
                    const {view, date, target} = evt.detail;
                    const d = date ? date.format("YYYY-MM-DD") : null;
                    if ("CalendarDay" === view && prices[d]) {
                        const span = target.querySelector(".day-price") || document.createElement("span");
                        span.className = "day-price";
                        span.innerHTML = `${prices[d]} ₽`;
                        target.append(span);
                    }
                }));
            }
        });
    })();
})();